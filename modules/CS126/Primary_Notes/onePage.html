<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>
    
    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link id="mainCS" rel="stylesheet" href="/assets/css/style.css">
    <title>onePage 126 One Page Notes</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            
            
            <h1 class="project-name">126 One Page Notes</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#arrays-and-lists">Arrays and Lists</a><ul><li><a href="#abstract-data-type-adt">Abstract Data Type (ADT)</a></li><li><a href="#arrays-adt">Arrays (ADT)</a><ul><li><a href="#implementation">Implementation</a></li></ul></li><li><a href="#lists-adt">Lists (ADT)</a><ul><li><a href="#array-based-implementation">Array based implementation</a></li></ul></li><li><a href="#positional-lists-adt">Positional lists (ADT)</a></li><li><a href="#linked-lists-adt">Linked lists (ADT)</a><ul><li><a href="#singly-linked-lists">Singly linked lists</a></li><li><a href="#doubly-linked-lists">Doubly Linked Lists</a></li></ul></li></ul></li><li><a href="#analysis-of-algorithms">Analysis of algorithms</a><ul><li><a href="#running-time">Running time</a></li><li><a href="#experimental-trials">Experimental trials</a></li><li><a href="#theoretical-analysis">Theoretical analysis</a></li><li><a href="#common-functions-of-running-time">Common functions of running time</a></li><li><a href="#random-access-machine-ram-model">Random Access Machine (RAM) model</a></li><li><a href="#asymptotic-algorithm-analysis">Asymptotic Algorithm Analysis</a><ul><li><a href="#big-o-notation">Big-O Notation</a><ul><li><a href="#big-o-of-a-function">Big-O of a Function</a></li></ul></li><li><a href="#worst-case-analysis-on">Worst Case Analysis \(O(n)\)</a></li><li><a href="#big-omega-omegan">Big-Omega \(\Omega(n)\)</a></li><li><a href="#big-theta-thetan">Big-Theta \(\Theta(n)\)</a></li></ul></li></ul></li><li><a href="#recursive-algorithms">Recursive algorithms</a><ul><li><a href="#definition">Definition</a></li><li><a href="#structure">Structure</a></li><li><a href="#examples">Examples</a></li><li><a href="#types-of-recursion">Types of recursion</a></li><li><a href="#divide-and-conquer">Divide and Conquer</a></li></ul></li><li><a href="#stacks-and-queues">Stacks and Queues</a><ul><li><a href="#stacks-adt">Stacks (ADT)</a><ul><li><a href="#array-based-implementation">Array Based Implementation</a></li></ul></li><li><a href="#queues-adt">Queues (ADT)</a><ul><li><a href="#array-based-implementation-1">Array Based Implementation</a></li></ul></li></ul></li><li><a href="#maps-hash-tables-and-sets">Maps, Hash tables and Sets</a><ul><li><a href="#maps-adt">Maps (ADT)</a></li><li><a href="#hash-tables">Hash tables</a><ul><li><a href="#hash-functions">Hash functions</a><ul><li><a href="#choosing-n">Choosing \(N\)</a></li></ul></li><li><a href="#memory-address">Memory address</a></li><li><a href="#integer-cast">Integer cast</a></li><li><a href="#component-sum">Component sum</a></li><li><a href="#polynomial-accumulation">Polynomial accumulation</a></li><li><a href="#java-hash-implementations">Java hash implementations</a></li></ul></li><li><a href="#collisions">Collisions</a><ul><li><a href="#separate-chaining-closed-bucket">Separate Chaining (closed-bucket)</a></li><li><a href="#linear-probing-open-bucket">Linear Probing (open-bucket)</a></li><li><a href="#double-hashing-open-bucket">Double Hashing (open-bucket)</a></li></ul></li><li><a href="#resizing-a-hash-table">Resizing a hash table</a></li><li><a href="#performance-of-hashing">Performance of Hashing</a></li><li><a href="#sets-adt">Sets (ADT)</a></li><li><a href="#implementations">Implementations</a><ul><li><a href="#list-based">List based</a><ul><li><a href="#generic-merging-algorithm">Generic Merging Algorithm</a></li></ul></li><li><a href="#hash-set-based">Hash-set based</a></li></ul></li></ul></li><li><a href="#trees">Trees</a><ul><li><a href="#trees-adt">Trees (ADT)</a></li><li><a href="#tree-traversals">Tree Traversals</a><ul><li><a href="#in-order-traversal">In-Order Traversal</a></li><li><a href="#pre-order-traversal">Pre-order traversal</a></li><li><a href="#post-order-traversal">Post-order traversal</a></li></ul></li><li><a href="#binary-trees-adt">Binary trees (ADT)</a><ul><li><a href="#properties">Properties</a></li><li><a href="#implementations">Implementations</a></li><li><a href="#linked-structure">Linked structure</a></li><li><a href="#array-based">Array based</a></li></ul></li></ul></li><li><a href="#priority-queues--heaps">Priority Queues &amp; Heaps</a><ul><li><a href="#priority-queues-adt">Priority queues (ADT)</a></li><li><a href="#implementations">Implementations</a><ul><li><a href="#unsorted-list-based">Unsorted list based</a></li><li><a href="#sorted-list-based">Sorted list based</a></li><li><a href="#heap-based">Heap based</a></li></ul></li><li><a href="#comparators">Comparators</a></li><li><a href="#sorting-with-list-based-priority-queues">Sorting with list based priority queues</a></li><li><a href="#heaps-adt">Heaps (ADT)</a></li><li><a href="#heap-properties">Heap properties</a><ul><li><a href="#height-of-a-heap">Height of a Heap</a></li></ul></li><li><a href="#heap-methods">Heap methods</a><ul><li><a href="#inserting-into-a-heap">Inserting into a heap</a></li><li><a href="#removal-from-a-heap">Removal from a heap</a></li></ul></li><li><a href="#use-in-sorting">Use in sorting</a></li><li><a href="#concrete-implementations">Concrete implementations</a><ul><li><a href="#array-based-heap-implementation">Array-based Heap Implementation</a></li></ul></li><li><a href="#building-heaps-in-linear-time">Building heaps in linear time</a></li></ul></li><li><a href="#skip-lists">Skip Lists</a><ul><li><a href="#motivations-for-skip-lists">Motivations for skip lists</a></li><li><a href="#skip-lists-adt">Skip Lists (ADT)</a></li><li><a href="#searching">Searching</a></li><li><a href="#inserting">Inserting</a></li><li><a href="#deleting">Deleting</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#performance">Performance</a><ul><li><a href="#space-usage">Space usage</a></li><li><a href="#height">Height</a></li><li><a href="#search-time">Search time</a></li><li><a href="#update-time">Update time</a></li><li><a href="#expectation-explanation">Expectation Explanation</a></li></ul></li></ul></li><li><a href="#binary-search--self-balancing-trees">Binary Search &amp; Self-Balancing Trees</a><ul><li><a href="#ordered-maps">Ordered Maps</a></li><li><a href="#binary-search-trees">Binary Search Trees</a><ul><li><a href="#operations">Operations</a><ul><li><a href="#searching">Searching</a></li><li><a href="#insertion">Insertion</a></li><li><a href="#deletion">Deletion</a></li></ul></li><li><a href="#algorithm">Algorithm</a></li></ul></li><li><a href="#avl-trees">AVL trees</a><ul><li><a href="#properties-of-avl-trees">Properties of AVL Trees</a></li><li><a href="#operations-1">Operations</a></li><li><a href="#trinode-restructuring">Trinode Restructuring</a><ul><li><a href="#double-rotation">Double Rotation</a></li><li><a href="#rebalancing">Rebalancing</a></li></ul></li></ul></li><li><a href="#performance">Performance</a></li></ul></li><li><a href="#graphs">Graphs</a><ul><li><a href="#graphs-as-a-mathematical-concept">Graphs as a mathematical concept</a><ul><li><a href="#graph-properties">Graph properties</a></li></ul></li><li><a href="#graphs-as-an-adt">Graphs as an ADT</a><ul><li><a href="#concrete-implementations">Concrete Implementations</a><ul><li><a href="#edge-list-structure">Edge List Structure</a></li><li><a href="#adjacency-list">Adjacency list</a></li><li><a href="#adjacency-matrix">Adjacency matrix</a></li><li><a href="#performance">Performance</a></li><li><a href="#space-complexity-choosing-between-an-adjacency-matrix-and-an-adjacency-list">Space complexity (choosing between an adjacency matrix and an adjacency list)</a></li></ul></li></ul></li><li><a href="#subgraphs">Subgraphs</a></li><li><a href="#depth-first-search">Depth-first search</a><ul><li><a href="#uses-cases">Uses Cases</a></li></ul></li><li><a href="#breadth-first-search">Breadth-first search</a><ul><li><a href="#applications">Applications</a></li><li><a href="#dfs-and-bfs-visualization">DFS and BFS visualization</a></li></ul></li></ul></li><li><a href="#directed-graphs">Directed Graphs</a><ul><li><a href="#directed-graphs">Directed graphs</a><ul><li><a href="#properties">Properties</a></li><li><a href="#strong-connectivity-algorithm">Strong Connectivity Algorithm</a></li></ul></li><li><a href="#transitive-closure">Transitive closure</a><ul><li><a href="#computing-with-dfs">Computing with DFS</a></li><li><a href="#floyd-warshall-algorithm">Floyd-Warshall Algorithm</a><ul><li><a href="#fw-in-python">FW in Python</a></li><li><a href="#speed-analysis-of-fw">Speed Analysis of FW</a></li></ul></li></ul></li><li><a href="#topological-ordering">Topological ordering</a><ul><li><a href="#topological-sorting-with-dfs">Topological Sorting with DFS</a></li></ul></li></ul></li><li><a href="#general-algorithms">General Algorithms</a><ul><li><a href="#searching-data-structures">Searching data structures</a><ul><li><a href="#linear-search">Linear search</a></li><li><a href="#binary-search">Binary search</a><ul><li><a href="#iterative-algorithm">Iterative algorithm</a></li><li><a href="#recursive-algorithm">Recursive algorithm</a></li></ul></li></ul></li><li><a href="#sorting-data-structures">Sorting data structures</a><ul><li><a href="#insertion-sort">Insertion sort</a></li><li><a href="#selection-sort">Selection sort</a></li><li><a href="#heap-sort">Heap sort</a></li><li><a href="#merge-sort">Merge sort</a></li></ul></li><li><a href="#reversing-data-structures">Reversing data structures</a><ul><li><a href="#reversing-a-stack">Reversing a stack</a></li><li><a href="#reversing-a-linked-list">Reversing a linked list</a></li></ul></li><li><a href="#set-operations">Set operations</a><ul><li><a href="#generic-merging">Generic merging</a></li></ul></li><li><a href="#graph-algorithms">Graph algorithms</a><ul><li><a href="#depth-first-search">Depth-first search</a><ul><li><a href="#dfs-for-an-entire-graph">DFS for an entire graph:</a></li><li><a href="#path-finding-with-dfs">Path Finding with DFS</a></li><li><a href="#cycle-finding-with-dfs">Cycle Finding with DFS</a></li><li><a href="#topological-ordering-using-dfs">Topological ordering using DFS</a></li></ul></li><li><a href="#breadth-first-search">Breadth-first search</a></li><li><a href="#directed-graphs">Directed graphs</a></li></ul></li><li><a href="#miscellaneous">Miscellaneous</a><ul><li><a href="#computing-spans">Computing spans</a></li><li><a href="#fibonacci">Fibonacci</a></li><li><a href="#exponential-time">Exponential time</a><ul><li><a href="#linear-time">Linear time</a></li></ul></li></ul></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="../">üè°Module Home</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Layout for One Page Notes -->
<!-- 
    Works for all modules as long as they 
    - Are defined in the relevant module data file
-->





<!-- not the best and a little O-horrible  but the easiest way to do it --><h1 id="arrays-and-lists">Arrays and Lists</h1>
       
            <h2 id="abstract-data-type-adt">Abstract Data Type (ADT)</h2>

<blockquote>
  <p>An abstract data type (ADT) is an <strong>abstraction</strong> of a data structure that specifies</p>

  <ul>
    <li>The data that is stored.</li>
    <li>The operations that can be performed on said data.</li>
    <li>The error conditions associated with said operations.</li>
  </ul>

  <p>The ADT does not define the implementation of the data structure but <strong>seeks to describe</strong> what it does.</p>
</blockquote>

<h2 id="arrays-adt">Arrays (ADT)</h2>

<blockquote>
  <p>Arrays are <strong>indexable</strong>, <strong>fixed length</strong>, sequence of variables of a <strong>single type</strong> (homogenous).</p>

  <ul>
    <li>They are homogenous as it is otherwise much harder to calculate the memory address of the data to look up given an index.</li>
  </ul>
</blockquote>

<p>Arrays have the following fundamental operations:</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(i)</code></td>
      <td>The item at the <code class="language-plaintext highlighter-rouge">i</code>th index in the array</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(i,e)</code></td>
      <td>-</td>
      <td>Set the item at the <code class="language-plaintext highlighter-rouge">i</code>th index in the array to the value <code class="language-plaintext highlighter-rouge">e</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>The size of the array</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>Whether the array is empty</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<p>This table is an overview of the time complexity of certain operations for an array.</p>

<table>
  <thead>
    <tr>
      <th>Methods/Operations</th>
      <th>Time</th>
      <th>Reason</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(i)</code>, <code class="language-plaintext highlighter-rouge">set(i,e)</code></td>
      <td>O(1)</td>
      <td>Indexable</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>O(1)</td>
      <td>Arrays are of fixed size when created, they know their size.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>O(n)</td>
      <td>Has to check every index</td>
    </tr>
    <tr>
      <td>Insertion, Deletion</td>
      <td>O(n)</td>
      <td>Fixed length ‚Äì have to shift proceeding elements up or down to accommodate inserted/deleted element</td>
    </tr>
    <tr>
      <td>Resizing the array</td>
      <td>O(n)</td>
      <td>Fixed length ‚Äì have to create a larger array, then copy contents over.</td>
    </tr>
  </tbody>
</table>

<h3 id="implementation">Implementation</h3>

<p>Arrays can be <strong>concretely</strong> implemented by <strong>allocating</strong> a <strong>contiguous section</strong> of memory, with cells being indexable by memory location, as the data at an index can be found at:</p>

<p>[S + D \cdot I]</p>

<p>where \(S\) is the pointer to the start of the array, \(D\) is the size of the data type, and \(I\) is the index.</p>

<h2 id="lists-adt">Lists (ADT)</h2>
<blockquote>
  <p><strong>Lists</strong> are a finite sequence of ordered values, which may contain duplicates (more abstract than an array). A list is called homogenous if every element it contains is of the same type.</p>
</blockquote>

<h3 id="array-based-implementation">Array based implementation</h3>

<p><em>Concrete implementation of lists</em></p>

<blockquote>
  <p>Arrays provide all the required properties, except being able to change size. To ‚Äúgrow‚Äù an array, we make a new array of a larger size, and copy all the data across to it.</p>
</blockquote>

<p>To do this, we need to decide how large the new array should be. There are two strategies which are commonly used to do this:</p>

<ul>
  <li><strong>Incremental strategy</strong> ‚Äì when the capacity is exceeded, grow it by a constant number of elements <strong><em>c</em></strong>
    <ul>
      <li>Amortized (average) time of each push is Œ©(n<sup>2</sup>)</li>
      <li>Space grows linearly, so quite space efficient</li>
    </ul>
  </li>
  <li><strong>Doubling strategy</strong> ‚Äì when the capacity is exceeded, double it
    <ul>
      <li>Amortized (average) time of each push is Œ©(n)</li>
      <li>Space grows exponentially, so less space efficient</li>
    </ul>
  </li>
</ul>

<p>Array based implementations have the fundamental operations</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get(i)</code></td>
      <td>The item at the <code class="language-plaintext highlighter-rouge">i</code>th index in the list</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(i,e)</code></td>
      <td>-</td>
      <td>Set the item at the <code class="language-plaintext highlighter-rouge">i</code>th index in the list to the value <code class="language-plaintext highlighter-rouge">e</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> to the end of the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(i)</code></td>
      <td>-</td>
      <td>Remove the value at the <code class="language-plaintext highlighter-rouge">i</code>th index of the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>The size of the array</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>Whether the array is empty</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<h2 id="positional-lists-adt">Positional lists (ADT)</h2>

<blockquote>
  <p><strong>Positional lists</strong> are a ‚Äúgeneral abstraction of a sequence of elements with the ability to identify the location of an element, without indices‚Äù</p>

  <p><em>‚ÄúData Structures and Algorithms in Java‚Äù, Goodrich, Tamassia, Goldwasser</em></p>
</blockquote>

<p>A ‚Äúposition‚Äù is a marker within the list, which is unaffected by changes elsewhere. For example, insertion or deletion of other elements doesn‚Äôt change it, the only time it changes is when it itself is deleted.</p>

<p>Positional lists have the fundamental operations</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addFirst(e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> to the beginning of the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addLast(e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> to the end of the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addBefore(p,e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> below the position <code class="language-plaintext highlighter-rouge">p</code> in the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addAfter(p,e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> after the position <code class="language-plaintext highlighter-rouge">p</code> in the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(p,e)</code></td>
      <td>-</td>
      <td>Set the item at the position <code class="language-plaintext highlighter-rouge">p</code> in the list to the value <code class="language-plaintext highlighter-rouge">e</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(p)</code></td>
      <td>-</td>
      <td>Remove the item at the position <code class="language-plaintext highlighter-rouge">p</code> in the list</td>
    </tr>
  </tbody>
</table>

<p>It is generally implemented as a <a href="#doubly-linked-lists">doubly linked list</a>.</p>

<h2 id="linked-lists-adt">Linked lists (ADT)</h2>

<blockquote>
  <p><strong>Linked lists</strong> are a collection of elements that can be accessed in a sequential way, meaning they are not indexable. <a href="https://lucasmagnum.medium.com/sidenotes-linked-list-abstract-data-type-and-data-structure-fd2f8276ab53">Additional resource.</a></p>
</blockquote>

<p>This means they can more easily implement non-homogenous lists, as opposed to using arrays, as cells can be of different ‚Äúsizes‚Äù, so different data types requiring different amounts of data can be stored.</p>

<h3 id="singly-linked-lists">Singly linked lists</h3>

<p><em>Concrete implementation of linked lists</em></p>

<blockquote>
  <p><strong>Singly linked lists</strong> are a sequence of nodes, each of which stores both a value and a pointer to the next node in the sequence. There is a pointer to the first node in the sequence, and the final node in the sequence is a null pointer ‚àÖ</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Method/Operation</th>
      <th>Time</th>
      <th>Reason | Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(p,e)</code>, <code class="language-plaintext highlighter-rouge">addAfter(p,e)</code>, get,</td>
      <td>O(n)</td>
      <td>Need to go through the list from head until index.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addFirst(e)</code></td>
      <td>O(1)</td>
      <td>Quick to add items to head because we have a pointer reference</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(p)</code> (Deletion), Insertion</td>
      <td>O(n)</td>
      <td>Similar to getting and <code class="language-plaintext highlighter-rouge">set</code>, but pointers are changed instead of values, either to bypass or include a new node in the sequence.</td>
    </tr>
  </tbody>
</table>

<p>Singly linked lists have the fundamental operations</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addFirst(e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> to the beginning of the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">addAfter(p,e)</code></td>
      <td>-</td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> after the position <code class="language-plaintext highlighter-rouge">p</code> in the list</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">set(p,e)</code></td>
      <td>-</td>
      <td>Set the item at the position <code class="language-plaintext highlighter-rouge">p</code> in the list to the value <code class="language-plaintext highlighter-rouge">e</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(p)</code></td>
      <td>-</td>
      <td>Remove the item at the position <code class="language-plaintext highlighter-rouge">p</code> in the list</td>
    </tr>
  </tbody>
</table>

<h3 id="doubly-linked-lists">Doubly Linked Lists</h3>

<p><em>Concrete implementation of positional lists and linked lists</em></p>

<blockquote>
  <p><strong>Doubly linked lists</strong> are a sequence of nodes, each of which stores both a value and a pointer to both the <strong>next</strong> and the <strong>previous</strong> node in the sequence. At <strong>each end</strong> there are <strong>special header</strong> and <strong>trailer nodes</strong>, which are <strong>just references</strong> to the first and last nodes in the sequence</p>
</blockquote>

<p>Similarly to singly linked lists, getting, setting, insertion, deletion all O(n) ‚Äì need to iterate from start to end of the list to get to the position of the item.</p>

<p>Head and tail operations are O(1) ‚Äì head and tail references (pointers) and the list can be traversed <strong>both</strong> forwards and backwards.</p>

<p>Doubly linked lists have the same fundamental operations as positional lists, as they are a concrete implementation of them</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="analysis-of-algorithms">Analysis of algorithms</h1>
       
            <h2 id="running-time">Running time</h2>

<p>To assess how good an algorithm is, we often use the metric of running time compared with the size of the input to the algorithm.</p>

<ul>
  <li><strong>Worst case</strong> \(O(n)\) ‚Äì which we usually focus on, since it is both <strong>easy to analyse and useful</strong></li>
  <li><strong>Average Case</strong> \(\Theta(n)\) ‚Äì often more <strong>difficult to assess</strong></li>
  <li><strong>Best Case</strong> \(\Omega(n)\) ‚Äì often <strong>not sufficiently representative</strong> of the algorithm</li>
</ul>

<h2 id="experimental-trials">Experimental trials</h2>

<blockquote>
  <p>One of the ways to assess the running time is to write a program implementing the algorithm, then running for inputs of different sizes. Then fit curves to a plot of the results to try to classify the algorithm.</p>
</blockquote>

<p>This has a few <strong>drawbacks</strong> though</p>

<ul>
  <li>Need to implement the algorithm ‚Äì might be difficult.</li>
  <li>Many ways to implement ‚Äì reason for analysis is to decide which one to implement</li>
  <li>Not all inputs can be covered ‚Äì not representative</li>
  <li>Dependent on machine hardware and software environments ‚Äì difficult to equate between different tests, same specs and same environment needed.</li>
</ul>

<h2 id="theoretical-analysis">Theoretical analysis</h2>

<blockquote>
  <p>Theoretical analysis is given a high-level description of the algorithm (not a full implementation), expressing the running time as a function of the input size \(n\).</p>

  <p>Pseudocode is used for this high-level description, which lies between English prose and program code. It has <strong>no formal syntax</strong>, and allows omission of some aspects of the implementation to make analysis easier.</p>
</blockquote>

<p>This has the benefits of:</p>

<ul>
  <li>Allowing all possible inputs to be covered</li>
  <li>Being independent of machine hardware and software environments, so easier to equate between different tests</li>
</ul>

<h2 id="common-functions-of-running-time">Common functions of running time</h2>

<p><img src="https://miro.medium.com/max/2928/1*5ZLci3SuR0zM_QlZOADv8Q.jpeg" alt="Complexity chart" class="center" /></p>

<p><a href="https://towardsdatascience.com/understanding-time-complexity-with-python-examples-2bda6e8158a7">Image source</a></p>

<h2 id="random-access-machine-ram-model">Random Access Machine (RAM) model</h2>

<blockquote>
  <p>To analyse programs, we use a <strong>simplified model</strong> of how computers work to <strong>help</strong> think about the time an high level operation takes to run by expressing it as fundamental operations which are equivocal to real computers.</p>
</blockquote>

<p>In the RAM model, we consider a computer with (assumptions):</p>
<ul>
  <li>A single CPU executing a single program</li>
  <li>An arbitrarily large indexable array of memory</li>
  <li>A set of registers memory can be copied into</li>
  <li>Basic arithmetic and memory allocation operations</li>
</ul>

<p>Generally, we tend to abstract beyond this model to just consider a set of <strong>primitive operations</strong> (usually single lines of pseudocode) that take constant time <strong>irrespective</strong> of input size in the RAM model.</p>

<blockquote>
  <p>We then <strong>analyse performance</strong> by <strong>counting</strong> the number of operations needed, as their number is proportional to running time.</p>
</blockquote>

<p>This allows us to express the running time of the program as being between the best and worst cases of number of operations needed, multiplied their running time</p>
<ul>
  <li>Let \(T(n)\) denote the running time, \(b(n)\) the best case, \(w(n)\) the worst case, and \(t\) the time taken for 1 primitive operation</li>
  <li>The running time is bounded as \(t \times b(n) \leq¬†T(n) \leq¬†t \times w(n)\)</li>
  <li>This metric of running time \(T(n)\) is <strong>not dependent</strong> on machine hardware or software environment ‚Äì it is an <strong>intrinsic property</strong> of the algorithm.</li>
</ul>

<h2 id="asymptotic-algorithm-analysis">Asymptotic Algorithm Analysis</h2>

<blockquote>
  <p><strong>Asymptotic algorithm analysis</strong> is a way we can take pseudocode and use it to analyse an algorithm.</p>
</blockquote>

<p>We most commonly conduct worst case analysis, \(O(n)\), but there is also \(\Omega(n)\) (best case) and \(\Theta(n)\) (average case).</p>

<h3 id="big-o-notation">Big-O Notation</h3>

<blockquote>
  <p><strong>Big-O</strong> is a way of quantifying the running time of an algorithm, allowing easy comparison. Given the functions \(f(n)\) and \(g(n)\), we say that \(f(n)\) is \(O(g(n))\) if:</p>

\[\begin{align}
&amp;f(n) \leq¬†g(n) \cdot c,&amp; &amp;\text{for all } n \geq n_0, n \in \mathbb{N}&amp; \\
&amp;&amp; &amp;\text{with some positive} \\ 
&amp;&amp; &amp;\text{constants } c \text{ and } n_0
\end{align}\]

  <p>Informally, this means that \(f(n)\) is ‚Äúovertaken‚Äù by \(g(n)\) for all values above <strong>some threshold</strong> \(n _0\) usually we consider \(n \rightarrow \infty\), <strong>allowing scaling</strong> by a linear factor \(c\).</p>
</blockquote>

<p>This can be phrased as ‚Äú\(f(n)\) is \(O(g(n))\) if \(g(n)\) grows as fast or faster than \(f(n)\) in the limit of \(n \rightarrow \infty\)‚Äù (<a href="https://math.stackexchange.com/questions/620145/understanding-definition-of-big-o-notation/620150#620150">Source</a>)</p>

<p>Big-O notation, thus, <strong>gives an upper bound</strong> on the growth rate of a function as its input size <em>n</em> tends to infinity. Hence, \(f(n)\) is \(O(g(n))\) means that the <strong>growth rate of \(f(n)\)</strong> is <strong>no greater</strong> than that of the <strong>growth rate of \(g(n)\)</strong>.</p>

<h4 id="big-o-of-a-function">Big-O of a Function</h4>

<p>Informally, the Big-O of a function is the term that grows the fastest, as it will come to <strong>dominate</strong> for a very large <em>n</em>, and we then just pick <em>n<sub>0</sub></em> where that term is dominating, and use <em>c</em> to shift the function to fit.</p>

<blockquote>
  <p>So, if \(f(n)\) is a polynomial of degree \(d\), then \(f(n)\) is \(O(n^d)\), as we can drop all <strong>but</strong> the fastest growing term.</p>
</blockquote>

<p>When writing Big-O, we:</p>

<ul>
  <li>Try to use the smallest possible class of functions which fulfils the criteria.
    <ul>
      <li>E.g. <em>O(n)</em> not <em>O(n<sup>2</sup>)</em>, whilst both technically are Big-O of linear functions. (<a href="https://cs.stackexchange.com/questions/77653/why-the-big-oh-of-a-linear-function-is-n2">Why is O(n<sup>2</sup>) valid for linear functions?</a>)</li>
    </ul>
  </li>
  <li>Use the simplest expression of the class.
    <ul>
      <li>E.g. <em>O(n)</em> not <em>O(5n)</em>.</li>
    </ul>
  </li>
</ul>

<h3 id="worst-case-analysis-on">Worst Case Analysis \(O(n)\)</h3>

<blockquote>
  <p>To prove something is \(O(f(n))\), we need to show that we can pick a \(c\) and an \(n\) which <strong>satisfy the condition</strong>.</p>

  <p>To prove something is <strong>not</strong> ,\(O(f(n))\) we show that there is <strong>no</strong> \(c\) for any arbitrarily large \(n_0\) which satisfies the condition.</p>
</blockquote>

<p>To analyse</p>

<ol>
  <li>Consider the <strong>worst-case</strong> number of primitive operations that the algorithm could require to run as a <strong>function of its input size</strong>.</li>
  <li>Express this derived <strong>function</strong> in <strong>Big-O notation</strong>.</li>
</ol>

<p><strong>An example,</strong> of this being formally calculated (taken from <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em>) is shown below:</p>

<blockquote>
  <p>Consider the function \(2n + 10\). To show that it is \(O(n)\), we take:</p>

\[\begin{align}
 2n + 10 &amp;\le c \cdot n \\
 cn-2n &amp;\ge 10   \\
 n &amp;\ge \frac{10}{c-2}
 \end{align}\]

  <p>Hence, picking <em>c = 3</em> and <em>n<sub>0</sub> = 10</em> the condition is <strong>satisfied</strong>.</p>
</blockquote>

<p><img src="./images/bigOh.png" alt="bigOh" class="center" /></p>

<h3 id="big-omega-omegan">Big-Omega \(\Omega(n)\)</h3>

<blockquote>
  <p>\(\Omega(n)\) looks at <strong>best cases.</strong> \(f(n) = \Omega(g(n))\) if</p>

\[\begin{align}
&amp;f(n) \ge¬†g(n) \cdot c,&amp; &amp;\text{for all } n \geq n_0, n \in \mathbb{N}&amp; \\
&amp;&amp; &amp;\text{with some positive} \\ 
&amp;&amp; &amp;\text{constants } c \text{ and } n_0
\end{align}\]

  <p>This means that \(g(n)\cdot c\) will always be lesser than or equals to \(f(n)\) after a certain threshold \(n_0\). You can think of it as a lower bound to \(f(n)\), where you‚Äôre saying that \(f(n)\) cannot get any ‚Äúbetter/faster‚Äù than this.</p>
</blockquote>

<h3 id="big-theta-thetan">Big-Theta \(\Theta(n)\)</h3>

<blockquote>
  <p>\(\Theta(n)\) looks at <strong>average cases.</strong> We say that \(f(n) = \Theta(g(n))\) when \(f(n)\) is asymptotically <strong>equal to</strong> \(g(n)\), this happens if and only if</p>

\[f(n) = \Theta(g(n)) \iff f(n) = O(g(n)) \land f(n) = \Omega(g(n)) \\
\begin{align}\\
&amp;g(n)\cdot c_\Omega \le f(n) \le¬†g(n) \cdot c_O,&amp; &amp;\text{for all } n \geq n_0, n \in \mathbb{N}&amp; \\
&amp;&amp; &amp;\text{with some positive} \\ 
&amp;&amp; &amp;\text{constants } c_O, c_\Omega, \text{ and } n_0
\end{align}\]

  <p>Here this means that for a specific \(g(n)\), we can scale it by two variables \(c_O\) and \(c_\Omega\) and \(f\) will be always ‚Äúfit in-between‚Äù the two scaled \(g\)s after a certain threshold \(n_0\).</p>
</blockquote>

<p><a href="https://courses.cs.washington.edu/courses/cse326/06au/lectures/lect03.pdf">Additional notes</a></p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="recursive-algorithms">Recursive algorithms</h1>
       
            <h2 id="definition">Definition</h2>

<p>Recursion can be defined in various ways:</p>

<blockquote>
  <p>‚ÄúWhen a method calls itself‚Äù</p>

  <p>‚Äì <em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>

  <p>‚ÄúA method which is expressed in terms of calls to simpler cases of itself, and a base case‚Äù</p>

  <p>‚Äì <em>CSRG, Edmund Goodman</em> (It‚Äôs a recursive reference, get it?) üôÉ</p>
</blockquote>

<h2 id="structure">Structure</h2>

<p>Recursive functions tend to include two main components:</p>

<ol>
  <li>Base cases</li>
  <li>Recursive calls</li>
</ol>

<blockquote>
  <p><strong>Base cases</strong> tend to be simple input values where the return value is a known constant, so no recursive calls are made. They are <strong>required</strong> for a recursive function <strong>to finish evaluating</strong>, so there must be <strong>at least</strong> one</p>

  <p><strong>Recursive calls</strong> are ones to the same recursive function making the call, with a simpler input (since it must ‚Äú<strong>move towards</strong>‚Äù the base case for it to ever finish evaluating)</p>
</blockquote>

<p>We can visualise recursion by drawing diagrams of functions, with functions as boxes and arrows indicating calls and return values. This is fairly self-explanatory.</p>

<h2 id="examples">Examples</h2>

<p>We can often express many functions both iteratively and recursively, such as a <strong>binary search</strong>, which can be implemented recursively with:</p>
<ul>
  <li>The input being a list,</li>
  <li>The recursive call being the half of the list the search has been narrowed down to</li>
  <li>The base cases being a single item, returning the index of that item if it is the item being searched for, or an indicator of absence if not</li>
</ul>

<p>See the page on general algorithms for the <a href="https://csrg-group.github.io/dcs-notes.github.io/CS126/part12.html#recursive-algorithm">pseudocode for a recursive binary search</a></p>

<h2 id="types-of-recursion">Types of recursion</h2>

<p><strong>Linear recursion.</strong> Each functional call makes only one recursive call (there may be multiple different possible calls, but only one is selected), or none if it is a base case.</p>

<p><strong>Binary and multiple recursion.</strong> Each functional call makes two or multiple recursive calls, unless it is a base case.</p>

<h2 id="divide-and-conquer">Divide and Conquer</h2>

<blockquote>
  <p>A <strong>design pattern</strong> that enables efficient problem solving. It consists of the following 3 steps:</p>

  <ol>
    <li><strong>Divide:</strong> Divide input data into 2 or more disjoint subsets <strong>unless</strong> the input size is smaller than a certain threshold ‚Äì if it is smaller then solve the problem directly using a straightforward method and return the solution obtained.</li>
    <li><strong>Conquer:</strong> Recursively solve the <strong>subproblems</strong> associated with each subset.</li>
    <li><strong>Combine:</strong> Take the solutions to the <strong>subproblems</strong> and <strong>merge</strong> them into a solution to the original problem.</li>
  </ol>
</blockquote>

<p>This design pattern is widely used in algorithms like <strong>merge sort</strong> and <strong>quick sort</strong>.</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="stacks-and-queues">Stacks and Queues</h1>
       
            <h2 id="stacks-adt">Stacks (ADT)</h2>
<blockquote>
  <p><strong>Stacks</strong> are a ‚ÄúLast in, first out‚Äù (LIFO) data structure, with both insertions and deletions always occurring at the front of the stack.</p>
</blockquote>

<p>These insertions and deletions are the fundamental operations of the stack, called pushing and popping respectively.</p>

<p>There is an edge case of popping from an empty stack, which normally either returns null or throws an error</p>

<p>Stacks have the fundamental operations:</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">push(e)</code></td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> to the top of the stack</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">pop()</code></td>
      <td>The most recently pushed item from the top of the stack</td>
      <td>Remove the most recently pushed item from the top of the stack</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>The size of the stack</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>Whether the stack is empty</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<h3 id="array-based-implementation">Array Based Implementation</h3>

<p>Index of head stored, and incremented/decremented on pushing/popping operations</p>

<ul>
  <li>
    <p><em>O(n)</em> space complexity</p>
  </li>
  <li>
    <p><em>O(1)</em> time complexity of fundamental operations</p>
  </li>
</ul>

<p><img src="./images/stackArrayImplementation.png" alt="stackArrayImplementation" class="center" /></p>

<h2 id="queues-adt">Queues (ADT)</h2>

<blockquote>
  <p><strong>Queues</strong> are a ‚ÄúFirst in, first out‚Äù (FIFO) data structure, with insertions occurring at the rear and removals at the front of the queue.</p>
</blockquote>

<p>These insertions and deletions are the fundamental operations of the stack, called enqueueing and dequeuing respectively.</p>

<p>There is an edge case of dequeuing from an empty queue, normally either returns null or throws an error</p>

<p>Queues have the fundamental operations</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">enqueue(e)</code></td>
      <td>Add the value <code class="language-plaintext highlighter-rouge">e</code> to the tail of the queue</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dequeue()</code></td>
      <td>The least recently enqueued item from the head of the queue</td>
      <td>Remove the least recently enqueued item from the head of the queue</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>The size of the queue</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>Whether the queue is empty</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<h3 id="array-based-implementation-1">Array Based Implementation</h3>

<p>Uses and array with data wrapping (so like using an array in a <code class="language-plaintext highlighter-rouge">Queue</code> class with extra fields/properties) around as it is added and removed. Both the index of the head <strong><em>f</em></strong> <strong>and</strong> the size of the queue <strong><em>s</em></strong> need to be stored.</p>

<p>The rear of the queue (index to insert to next) is <em>(f + s)</em> mod <em>N</em>, with <em>N</em> as the array size</p>

<p><img src="./images/queueArrayImplementation.png" alt="queueArrayImplementation" class="center" /></p>

<ul>
  <li><em>O(n)</em> space complexity</li>
  <li><em>O(1)</em> time complexity of fundamental operations</li>
</ul>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="maps-hash-tables-and-sets">Maps, Hash tables and Sets</h1>
       
            <h2 id="maps-adt">Maps (ADT)</h2>
<blockquote>
  <p><strong>Maps</strong> are a ‚Äúsearchable collection of key-value entries‚Äù</p>

  <p><em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser.</em></p>
</blockquote>

<p>They cannot contain duplicate keys, as then they would not be able to unambiguously look up values by their keys</p>

<p>Maps have the fundamental operations:</p>

<table>
  <thead>
    <tr>
      <th>Fundamental operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>contains(k)</td>
      <td>Whether the key <code class="language-plaintext highlighter-rouge">k</code> is in the map</td>
      <td>-</td>
    </tr>
    <tr>
      <td>get(k)</td>
      <td>The value associated with the key <code class="language-plaintext highlighter-rouge">k</code>, or null if it is not in the map</td>
      <td>-</td>
    </tr>
    <tr>
      <td>put(k,v)</td>
      <td>-</td>
      <td>Add the key-value pair <code class="language-plaintext highlighter-rouge">k,v</code> to the map</td>
    </tr>
    <tr>
      <td>remove(k)</td>
      <td>-</td>
      <td>Remove the key-value pair of <code class="language-plaintext highlighter-rouge">k</code> from the map</td>
    </tr>
    <tr>
      <td>size()</td>
      <td>The number of key-value pairs stored in the map</td>
      <td>-</td>
    </tr>
    <tr>
      <td>isEmpty()</td>
      <td>Whether the map is empty</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<p><em>Sometimes additional operations for getting lists of all keys or all values are included</em></p>

<p>There are two common concrete implementations:</p>

<ul>
  <li>List based implementation
    <ul>
      <li>\(O(n)\) lookup and insertion, as the whole list needs to be iterated over to check for duplicates</li>
      <li>\(O(n)\) space complexity, as there are no duplicates</li>
    </ul>
  </li>
  <li>Hash table based implementation
    <ul>
      <li>\(O(1)\) lookup and insertion time, as they can be directly indexed</li>
      <li>\(O(k \cdot n)\) space complexity (still linear with number of items, but larger by a big constant factor)</li>
    </ul>
  </li>
</ul>

<h2 id="hash-tables">Hash tables</h2>

<p><em>Concrete implementation</em></p>

<blockquote>
  <p><strong>Hash tables</strong> are a time efficient implementation of the Map abstract data type</p>
</blockquote>

<p>To look up keys in \(O(1)\) time, we want essentially want to be able to index an array of them, but the space of keys are far too large to conceivably keep <strong>just</strong> one element in the array for each key.</p>

<h3 id="hash-functions">Hash functions</h3>

<blockquote>
  <p>We can use a ‚Äúhash function‚Äù to reduce the size of the keyspace, so we can used the hashed outputs of keys for indices in the array storing the map.
\(h : keys \rightarrow indices\)
\(h\) maps keys of a given type to integers in a fixed interval \([0, N-1]\) where \(N\) is the size of the array to store the items in (<strong>bucket</strong> size).</p>
</blockquote>

<p>Modern implementations of hash functions are <strong>very complicated</strong>, and often involve two phases</p>

<ol>
  <li>Mapping keys to integers with a <strong>hash code</strong> \(h_1\)</li>
  <li>Reducing the range of those integers with a <strong>compression function</strong> \(h_2\)</li>
</ol>

<p>But simpler ones exist, for example \(h(x) =  x \!\!\mod \!N\)</p>

<h4 id="choosing-n">Choosing \(N\)</h4>

<blockquote>
  <p>In general, every key \(x\) that shares a <strong>common factor</strong> with \(N\) (the number of buckets) will be hashed to a multiple of this <strong>factor</strong>.</p>
</blockquote>

<p>Therefore, to minimise <strong>collisions</strong> it is best to choose a \(N\) such that it has very few factors. Hence <strong>large prime numbers</strong> are often used for this very reason.</p>

<h3 id="memory-address">Memory address</h3>

<p>Java implements hash functions for all objects with the <code class="language-plaintext highlighter-rouge">.hashCode()</code> method, giving a convenient way to implement hashing.</p>

<p>The <code class="language-plaintext highlighter-rouge">.hashCode()</code> method is dependent on the memory address of the object storing the key, which is then cast to an integer. This then may be resized using a reduction function to map it to the correct size of the table may still be required.</p>

<h3 id="integer-cast">Integer cast</h3>

<p>Taking the bits encoding the object storing the key, and re-interpreting them as an integer. This is only suitable for keys of fewer or equal to the number of bits in the integer type (i.e. primitives: <code class="language-plaintext highlighter-rouge">byte</code>, <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>)</p>

<h3 id="component-sum">Component sum</h3>

<p>The process is:</p>

<ol>
  <li>Partition the bits of the key into a number of fixed length components (e.g. 8 bits)</li>
  <li>Sum together the components, discarding overflows</li>
</ol>

<p>This is suitable for keys of a greater number of bits than the integer type (e.g. <code class="language-plaintext highlighter-rouge">long</code> and <code class="language-plaintext highlighter-rouge">double</code>)</p>

<h3 id="polynomial-accumulation">Polynomial accumulation</h3>

<p>The process is:</p>

<ol>
  <li>
    <p>Partition the bits of the key into a number of fixed length components (e.g. 8 bits), and name them \(a_0, a_1, ..., a_{n-1}\) respectively</p>
  </li>
  <li>
    <p>Evaluate the polynomial:
\(p(z) = a_0 + a_1 \cdot z + a_2 \cdot z^2 + ... + a_{n-1} \cdot z^{n-1}\)
at a fixed value \(z\), ignoring overflows</p>

    <p>This can be evaluated quickly using Horner‚Äôs rule</p>
  </li>
</ol>

<p>This is especially suitable for strings, with \(z=33\) giving at most \(6\) collisions from \(50,000\) English words</p>

<h3 id="java-hash-implementations">Java hash implementations</h3>

<p>Java implements hash functions for all objects with the <code class="language-plaintext highlighter-rouge">.hashCode()</code> method, giving a convenient way to implement hashing, but a reduction function to map it to the correct size of the table may still be required.</p>

<p>Additionally, ‚ÄúYou must override <code class="language-plaintext highlighter-rouge">hashCode()</code> in every class that overrides <code class="language-plaintext highlighter-rouge">equals()</code>.  Failure to do so will result in a violation of the general contract for <code class="language-plaintext highlighter-rouge">Object.hashCode()</code>, which will prevent your class from functioning  properly in conjunction with all hash-based collections, including  <code class="language-plaintext highlighter-rouge">HashMap</code>, <code class="language-plaintext highlighter-rouge">HashSet</code>, and <code class="language-plaintext highlighter-rouge">Hashtable</code>.‚Äù (<em>Effective Java</em>, Joshua Bloch)</p>

<p>This is because the default <code class="language-plaintext highlighter-rouge">.hashcode()</code> method is dependent on the object‚Äôs location on memory, which is the same as the default implementation of the <code class="language-plaintext highlighter-rouge">.equals()</code> method. Then, if the .<code class="language-plaintext highlighter-rouge">equals()</code> method is changed to be dependent on an object‚Äôs internal state, two objects could be equal, but have different hash codes, which violates the property of hashing that two equal objects must have the same hash code, as otherwise it is non-deterministic. Hence, the <code class="language-plaintext highlighter-rouge">.hashcode()</code> method should always be updated to hash equal objects to the same hash code to maintain consistency and avoid difficult to debug conceptual errors. This is not a <em>requirement</em>, and the code will still compile if it is not done, but it is very inadvisable not to do so.</p>

<h2 id="collisions">Collisions</h2>

<blockquote>
  <p>Collisions are when two <strong>different</strong> keys are <strong>mapped to</strong> the <strong>same index</strong> by the hash function. Since we cannot store duplicate keys unambiguously in a map, we need a protocol to resolve this.</p>
</blockquote>

<p>When colliding items are placed in different cells in the table, it is called <strong>open addressing</strong>, or <strong>open-bucket hashing</strong>, and when they are put in a separate data structure it is called <strong>closed addressing</strong>, or <strong>closed-bucket chaining</strong> (with linear probing and separate chaining being examples of both respectively) <a href="http://www.iro.umontreal.ca/~nie/IFT1020/Watt/12/tsld009.htm">additional link</a>.</p>

<p>Common approaches to resolving collisions are:</p>

<ul>
  <li>Separate chaining</li>
  <li>Linear probing</li>
  <li>Double hashing</li>
</ul>

<h3 id="separate-chaining-closed-bucket">Separate Chaining (closed-bucket)</h3>

<p>In <strong>separate chaining</strong>, each index in the array can contain a reference to a linked list.</p>

<ul>
  <li>Whenever a key is mapped to that index, the key-value pair is added to the linked-list.</li>
  <li>If there are duplicates, we iterate over the chain till we find the key, or reach the end.</li>
</ul>

<p>This has the <strong>drawback</strong> of requiring additional memory space for each linked list</p>

<p><img src="./images/separateChaining.png" alt="separateChaining" class="center" /></p>

<h3 id="linear-probing-open-bucket">Linear Probing (open-bucket)</h3>

<blockquote>
  <p><strong>Linear probing</strong> handles collisions by placing the colliding item in the next available table cell, wrapping around if necessary.</p>
</blockquote>

<p><strong>Searching</strong></p>

<p>As with the linked list, <strong>searching</strong> is done by iterating over the next cells, stopping when</p>

<ul>
  <li>The item is found</li>
  <li>An empty cell in the table is found</li>
  <li><strong><em>N</em></strong> cells have been unsuccessfully (cannot find key) probed.</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Psuedocode</span>
<span class="n">Algorithm</span> <span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">h</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="c1">// h = hash function</span>
    <span class="n">p</span> <span class="o">&lt;-</span> <span class="mi">0</span>
    <span class="n">repeat</span>
    	<span class="n">c</span> <span class="o">&lt;-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">// A is the table</span>
    	<span class="k">if</span> <span class="n">c</span> <span class="o">=</span> <span class="n">empty</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">c</span><span class="p">.</span><span class="n">getKey</span><span class="p">()</span> <span class="o">=</span> <span class="n">k</span> <span class="c1">// We found our item</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span>
        <span class="k">else</span>
            <span class="n">i</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">N</span> <span class="c1">// mod N takes care of wrap arounds</span>
            <span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span>
   <span class="n">until</span> <span class="n">p</span> <span class="o">=</span> <span class="n">N</span> <span class="c1">// stop if we have repeated N times</span>
   <span class="k">return</span> <span class="n">null</span>
</code></pre></div></div>

<p>This has the <strong>drawback</strong> of colliding items ‚Äúlumping together‚Äù, which can cause many items needed to be iterated over in a probe.</p>

<p><strong>Removing</strong></p>

<p><strong>To remove</strong> an item, we cannot just set it to null again, as that would mean it stops probing, even though there might be subsequent elements. Instead, we replace it with a <code class="language-plaintext highlighter-rouge">DEFUNCT</code> element, which is just skipped over when probing.</p>

<ul>
  <li>Search for an entry with key <strong><em>k</em></strong></li>
  <li>If <strong><em>k</em></strong> is found, we replace it with <code class="language-plaintext highlighter-rouge">DEFUNCT</code> and we return the <strong>value</strong> of the item with key <strong><em>k</em></strong></li>
  <li>Else we return <strong>null</strong></li>
</ul>

<h3 id="double-hashing-open-bucket">Double Hashing (open-bucket)</h3>

<blockquote>
  <p><strong>Double hashing</strong> handles collisions by re-hashing the key with a new hash function</p>

  <p>If cell \(h(k)\) is occupied and not our key, we try \([h(k) + i \cdot f(k)] \!\!\mod \!N, \; i \in \mathbb{Z}\)</p>

  <ul>
    <li>\(h\) and \(f\) are hashing functions, and \(f(k)\) cannot have 0 values.</li>
    <li>\(N\) must be a prime to allow probing of all cells.</li>
  </ul>
</blockquote>

<p>As before, there are many implementations of the hash function, but \(f(k)= q-k \!\!\mod\!q, \;s.t.\;  q&lt;N, q \in primes\) is normally used.</p>

<ul>
  <li>If \(f(k) = 1\) then we have <strong>linear probing</strong>.</li>
</ul>

<p><strong>Searching</strong> is similar to linear probing, but when iterating we look at the hash value for \(i = 1,2,3,\ldots\) rather than just the next index in the table. This helps avoid the issue of colliding items ‚Äúlumping together‚Äù as in linear probing.</p>

<h2 id="resizing-a-hash-table">Resizing a hash table</h2>

<p>As with arrays, we create a new table of a larger size, then iterate over every index in the table, and apply the standard add operation to add it to the new one (re-hashing).</p>

<p>Again, similarly to arrays, the new size of the table can be picked from various algorithms, most commonly constant or exponential growth.</p>

<h2 id="performance-of-hashing">Performance of Hashing</h2>

<p>The load factor of a hash table is the ratio of the number of items it contains to the capacity of the array \(\alpha = \frac{n}{N}\).</p>

<ul>
  <li>If this approaches \(1\), the table becomes time inefficient to lookup in, so we often re-size the table whenever it exceeds a certain value, e.g. \(0.75\)</li>
  <li>If this approaches \(0\), then the table is mostly empty, so is space inefficient, so we try to avoid tables of less than a certain value, e.g. \(0.5\)</li>
</ul>

<p>The time complexity of insertion and lookup is:</p>
<ul>
  <li>\(\Theta(1)\) best case</li>
  <li>\(O(n)\) worst case ‚Äì when all keys inserted into the map collide</li>
  <li>‚ÄúExpected‚Äù number of probes with open addressing is \(\frac{1}{1-\alpha}\)</li>
</ul>

<p>In practice, hash tables are a very efficient implementation of maps assuming the load factor is not very close to \(1\)</p>

<blockquote class="extra">
    Experiments show that as long as \(\alpha \lt 0.9\), there should be no problem with speed.
    However, for \(\alpha \gt 0.9\) the number of collisions increase and becomes slower.
</blockquote>

<h2 id="sets-adt">Sets (ADT)</h2>

<blockquote>
  <p><strong>Sets</strong> are ‚Äúan <strong>unordered</strong> collection of elements, <strong>without duplicates</strong> that typically supports <strong>efficient membership tests</strong>.‚Äù</p>

  <p><em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em></p>
</blockquote>

<p>These are the same as sets in mathematics.</p>

<p><em>If you want to pull request more stuff here, please do - but I‚Äôm not too sure how much more depth is needed</em></p>

<table>
  <thead>
    <tr>
      <th>Fundamental Operations</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">add(e)</code></td>
      <td>-</td>
      <td>Add the element <em>e</em> to <em>S</em> (if not already present)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">remove(e)</code></td>
      <td>-</td>
      <td>Remove the element <em>e</em> from <em>S</em> (if it is present).</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">contains(e)</code></td>
      <td>Whether <em>e</em> is an element of <em>S</em></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">iterator()</code></td>
      <td>An iterator of the elements of <em>S</em></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">union(s2)</code></td>
      <td>-</td>
      <td>Updates <em>S</em> to also include all elements of set <em>T</em>, effectively replacing <em>S</em> with <em>S</em> ‚à™ <em>T</em></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">intersection(s2)</code></td>
      <td>-</td>
      <td>Updates <em>S</em> to only include elements also in set T, effectively replacing <em>S</em> with <em>S</em> ‚à© <em>T</em></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">difference(s2)</code></td>
      <td>-</td>
      <td>Updates <em>S</em> to not include any of the elements of set T, effectively replacing <em>S</em> with <em>S</em> \ <em>T</em></td>
    </tr>
  </tbody>
</table>

<p>And alternate definition for set operations can instead define a third set structure and fill it with the result of <em>S</em> *set operation* <em>T</em> ‚Äì this way we don‚Äôt alter <em>S</em></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">union :: (s1, s2) -&gt; s3</code></li>
  <li><code class="language-plaintext highlighter-rouge">intersection :: (s1, s2) -&gt; s3</code></li>
  <li><code class="language-plaintext highlighter-rouge">difference :: (s1, s2) -&gt; s3</code></li>
</ul>

<h2 id="implementations">Implementations</h2>

<p>There are two common concrete implementations. These are essentially the same as for maps, however, the key and the value are taken to be the same.</p>

<ul>
  <li>Linked lists</li>
  <li>Hash set</li>
</ul>

<h3 id="list-based">List based</h3>

<blockquote>
  <p>In the list implementation we store elements <strong>sorted</strong> according to some canonical ordering. This is <strong>important</strong> for the set operations to be more time efficient.</p>
</blockquote>

<p>Generally, the <strong>space complexity</strong> is \(O(n)\), without overhead of empty cells. Since sets are not indexable, linked lists can be used, <strong>offering efficient re-sizing</strong>.</p>

<p>We need to iterate over each element in the list to lookup items, \(O(n)\) time complexity, which is not efficient, but for most more complex set operations, this becomes less of a drawback.</p>

<h4 id="generic-merging-algorithm">Generic Merging Algorithm</h4>

<p>Set operations can be implemented using a generic <strong>merge</strong> algorithm.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Algorithm</span> <span class="nf">genericMerge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">&lt;-</span> <span class="n">empty</span> <span class="n">set</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">A</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span> <span class="n">and</span> <span class="o">!</span><span class="n">B</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span>
        <span class="c1">// until either of the arrays is empty</span>
        <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">A</span><span class="p">.</span><span class="n">first</span><span class="p">().</span><span class="n">element</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">&lt;-</span>  <span class="n">B</span><span class="p">.</span><span class="n">first</span><span class="p">().</span><span class="n">element</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
            <span class="n">aIsLess</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">A</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">first</span><span class="p">())</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span>
            <span class="n">bIsLess</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">B</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">first</span><span class="p">())</span>
        <span class="k">else</span> <span class="c1">// b == a</span>
            <span class="n">bothAreEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">A</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">first</span><span class="p">());</span> <span class="n">B</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">first</span><span class="p">())</span>
    <span class="c1">// By this point either A is empty or B is empty</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">A</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span>
        <span class="c1">// Populate S with remaining elements in A, if any are still present</span>
        <span class="n">aIsLess</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        <span class="n">A</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">first</span><span class="p">())</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">B</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span>
        <span class="c1">// Populate S with remaining elements in B, if any are still present</span>
        <span class="n">bIsLess</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        <span class="n">B</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">first</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">S</span>
</code></pre></div></div>

<p>This merging algorithm is used in <strong>merge sort</strong> as well! You may have noticed that we have 3 auxiliary methods in this algorithm: <code class="language-plaintext highlighter-rouge">aIsLess</code>, <code class="language-plaintext highlighter-rouge">bIsLess</code>, and <code class="language-plaintext highlighter-rouge">bothAreEqual</code>.</p>

<blockquote>
  <p>Depending on the set operation (or any operation you are using this generic merge for), you define these methods <strong>differently</strong>.</p>
</blockquote>

<p><strong>Example.</strong></p>

<p>For <strong>set intersection</strong> ‚Äì we only want the algorithm to merge when <code class="language-plaintext highlighter-rouge">b == a</code>, so <code class="language-plaintext highlighter-rouge">aIsLess</code> and <code class="language-plaintext highlighter-rouge">bIsLess</code> should do <strong>nothing</strong> and <code class="language-plaintext highlighter-rouge">bothAreEqual</code> should add either one into <strong><em>S</em></strong>.</p>

<p><strong>Set union</strong> is trivial (just add everything).</p>

<p>For <strong>set subtraction</strong> you do nothing if the elements are equal!</p>

<p>This means that each <strong>set operation</strong> runs in <strong>linear time</strong> (i.e \(O(n_A + n_B)\) time), provided that the auxiliary methods run in <em>O(1)</em> time. This is <strong>possible</strong>, as we know that the <strong>elements are sorted</strong>.</p>

<h3 id="hash-set-based">Hash-set based</h3>

<p>Hash-sets are implemented like a hash-table, but using only keys, not key-value pairs. This gives fast \(O(1)\) lookups, and an \(O(n)\) space complexity, but with large overheads.</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="trees">Trees</h1>
       
            <h2 id="trees-adt">Trees (ADT)</h2>
<blockquote>
  <p><strong>Trees</strong> are ‚Äúan abstract model of a hierarchical structure. A tree consists of nodes with a parent-child relation.‚Äù</p>

  <p>*Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Fundamental Operation</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>Number of nodes in the tree</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>Whether the tree is empty</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">iterator()</code></td>
      <td>An iterator for the tree</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">positions()</code></td>
      <td>An iterable container of all nodes in the tree</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">root()</code></td>
      <td>The root node</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">parent(p)</code></td>
      <td>The parent of the node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">children(p)</code></td>
      <td>An iterable container of the children of the node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">numChildren(p)</code></td>
      <td>The number of children of the node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isInternal(p)</code></td>
      <td>Whether the node <code class="language-plaintext highlighter-rouge">p</code> is an <strong>internal node</strong> (node with at least 1 child)</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isExternal(p)</code></td>
      <td>Whether the node <code class="language-plaintext highlighter-rouge">p</code> is an <strong>external node</strong> (node with no children)</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isRoot(p)</code></td>
      <td>Whether the node <code class="language-plaintext highlighter-rouge">p</code> is a <strong>root node</strong> (node without parent)</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">insert(p,e)</code></td>
      <td>-</td>
      <td>Add a node of value <code class="language-plaintext highlighter-rouge">e</code> as a child of the node <code class="language-plaintext highlighter-rouge">p</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">update(p,e)</code></td>
      <td>-</td>
      <td>Update the value of the node <code class="language-plaintext highlighter-rouge">p</code> to be <code class="language-plaintext highlighter-rouge">e</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">delete(p)</code></td>
      <td>The value of the node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>Delete the node <code class="language-plaintext highlighter-rouge">p</code></td>
    </tr>
  </tbody>
</table>

<p>The methods for insertion, deletion, and searching are more complicated, and so are outlined in more detail in the binary search tree section</p>

<h2 id="tree-traversals">Tree Traversals</h2>

<p>There are various ways a tree can be traversed. Shown here is a figure of a binary tree.</p>

<p><img src="https://mermaid.ink/svg/eyJjb2RlIjoiZ3JhcGggVEQ7XG5cdEEgLS0tIEI7XG5cdEEgLS0tIEM7XG5cdEIgLS0tIEQ7XG5cdEIgLS0tIEU7IFxuXHRDIC0tLSBGO1xuXHRDIC0tLSBHO1xuIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" class="center" /></p>

<p><strong>In-order (Left, Root, Right).</strong> DBE A FCG</p>

<p><strong>Pre-order (Root, Left, Right).</strong> A BDE CFG</p>

<p><strong>Post-order (Left, Right, Root).</strong> DEB FGC A</p>

<p><strong>Breadth First/Level Order.</strong> ABCDEFG</p>

<p>We will come back to breadth first traversal in a later topic (Breadth First Search). For now we will focus on the first 3.</p>

<h3 id="in-order-traversal">In-Order Traversal</h3>

<p>For every node, we print the left child, the node itself, then the right child. Since this is a recursive function, if we start at a node <strong><em>n</em></strong>, the algorithm will start from the left-most child <strong>of the tree</strong>, then that child‚Äôs parent then its sibling and on for the entire tree that the <strong><em>n</em></strong> is the <strong>root</strong> of.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span> <span class="nf">inOrder</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span>
    <span class="nf">inOrder</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">leftChild</span><span class="o">())</span>
    <span class="nc">Print</span> <span class="n">n</span>
    <span class="nf">inOrder</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">rightChild</span><span class="o">())</span>
</code></pre></div></div>

<p>Note that the above algorithm applies only to <strong>binary trees</strong>, for a more general form of in-order traversal, there will need to be an <strong>additional</strong> definition of what makes a node a ‚Äúleft child‚Äù. This can either be that left child nodes have a smaller value than the parent/root, or left children are just the first <strong><em>m</em></strong> number of nodes etc.</p>

<h3 id="pre-order-traversal">Pre-order traversal</h3>

<p>Each node is printed before its descendants, and descendants are taking in ascending order</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span> <span class="nf">preOrder</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span>
    <span class="nc">Print</span> <span class="n">n</span>
    <span class="nc">For</span> <span class="n">each</span> <span class="n">child</span> <span class="n">m</span> <span class="n">of</span> <span class="n">n</span>
      <span class="nf">preOrder</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="post-order-traversal">Post-order traversal</h3>

<p>Each node is printed after its descendants, and descendants are taking in ascending order</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span> <span class="nf">postOrder</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span>
    <span class="nc">For</span> <span class="n">each</span> <span class="n">child</span> <span class="n">m</span> <span class="n">of</span> <span class="n">n</span>
      <span class="nf">postOrder</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
    <span class="nc">Print</span> <span class="n">n</span>
</code></pre></div></div>

<h2 id="binary-trees-adt">Binary trees (ADT)</h2>

<blockquote>
  <p><strong>Binary trees</strong> are a specialised tree where each node has at most two children, called left and right</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Fundamental Operations</th>
      <th>Value returned</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">left(p)</code></td>
      <td>The left child of node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">right(p)</code></td>
      <td>The right child of node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sibling(p)</code></td>
      <td>The sibling of node <code class="language-plaintext highlighter-rouge">p</code></td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<h3 id="properties">Properties</h3>

<p>A binary tree with \(n\) nodes, \(e\) external nodes, \(i\) internal nodes, and a height \(h\) has the properties</p>

\[\begin{gather}
e = i + 1 \tag1
\\\\ n = 2e - 1 \tag2 
\\\\ h \leq i \tag3
\\\\ h \leq \frac{(n-1)}{2} \tag4
\\\\ e \leq 2^h \tag5
\\\\ h \geq log_2 e \tag6
\\\\ h \geq log_2 (n+1) - 1 \iff n = 2^{h+1} -1 \tag7
\end{gather}\]

<p>As mentioned <a href="#in-order-traversal">earlier</a>, Binary Trees by definition have a <strong>discrete middle node</strong>, and inherently support <strong>in-order traversal</strong>.</p>

<h3 id="implementations">Implementations</h3>

<p>There are two common concrete implementations of binary trees</p>

<ul>
  <li>Linked structure</li>
  <li>Array based</li>
</ul>

<h3 id="linked-structure">Linked structure</h3>

<p>In the linked structure implementation, each node is an object which stores its value, references to its child nodes (and sometimes a reference to its parent), as shown in the diagram below:</p>

<p><img src="./images/binaryTreeLinkedStructure.png" alt="binaryTreeLinkedStructure" class="center" /></p>

<p>This has a linear space complexity irrespective of the balance of the tree, and has a lookup time of \(O(log_2n)\) for lookup operations.</p>

<h3 id="array-based">Array based</h3>

<p>In the array based implementation, node values are stored in an array, and their children can be found at indices based on arithmetic operations of their own index</p>

<ul>
  <li>
\[index(root) = 0\]
  </li>
  <li>If \(l\) is the left child of \(n\), then \(index(l) = 2 \cdot index(n) + 1\)</li>
  <li>If \(r\) is the right child of \(n\), then \(index(r) = 2 \cdot index(n) + 2\)</li>
</ul>

<p>This can be very inefficient for unbalanced trees, for example, a tree which is just a ‚Äúline‚Äù of nodes would grow with \(O(2^n)\) space, but it has a similarly good lookup time of \(O(log_2n)\)</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="priority-queues--heaps">Priority Queues &amp; Heaps</h1>
       
            <h2 id="priority-queues-adt">Priority queues (ADT)</h2>

<blockquote>
  <p><strong>Priority queues</strong> are (unsurprisingly) similar to queues, but items are sorted in order of a property ‚Äúpriority‚Äù, the assigned priorities specify which element leaves first (is dequeued). Unlike maps, multiple elements can have the same priority.</p>
</blockquote>

<p>These priorities, usually called keys, must form a total order relation, for example \(x \leq y\). We often use comparators on keys to form this total order relation.</p>

<p>If two keys of the same priority are to be dequeued, the most common implementation is reverting to the standard queue property of removing the least recently inserted one</p>

<p>In some implementations, the key and the value are taken to be the same thing, so the total ordering is just based on the values, and no additional keys are required</p>

<table>
  <thead>
    <tr>
      <th>Fundamental Operations</th>
      <th>Returned value</th>
      <th>Effect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">enqueue(k,v)</code></td>
      <td>-</td>
      <td>Insert an entry with key <code class="language-plaintext highlighter-rouge">k</code> and value <code class="language-plaintext highlighter-rouge">v</code> into the queue, where <code class="language-plaintext highlighter-rouge">k</code> determines its position in the queue</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dequeue()</code></td>
      <td>The element with the highest priority</td>
      <td>Element with the highest priority is removed from the queue</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">size()</code></td>
      <td>The size of priority queue</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">isEmpty()</code></td>
      <td>Whether the priority queue is empty</td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">first()</code></td>
      <td>The element with the highest priority, but does not remove it</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<p><em>Note.</em> The names of these operations/methods can differ, it is important to understand their function and purpose to draw the link with concrete implementations.</p>

<h2 id="implementations">Implementations</h2>

<p>There are three common concrete implementations:</p>
<ul>
  <li>Unsorted list based</li>
  <li>Sorted list</li>
  <li>Heap based</li>
</ul>

<p>For both list based implementations, a positional/linked list should be used (for unsorted, doubly linked is needed), since we want to be able to grow the list, but don‚Äôt need to be able to index it</p>

<h3 id="unsorted-list-based">Unsorted list based</h3>

<p>To enqueue an item, we just add it to the end of the list, in \(O(1)\) time.</p>

<p>To dequeue an item, we have to traverse the entire list to find the smallest item, taking \(O(n)\) time</p>

<h3 id="sorted-list-based">Sorted list based</h3>

<p>To enqueue an item, we have to traverse the list to find where to put it, taking \(O(n)\) time (but we normally wouldn‚Äôt need to traverse the entire list, unlike dequeuing in the unsorted implementation, which also must)</p>

<p>To dequeue an item, we just take it from the front of the list, in \(O(1)\) time</p>

<h3 id="heap-based">Heap based</h3>

<p>This is covered in the section on heaps</p>

<h2 id="comparators">Comparators</h2>

<blockquote>
  <p><strong>Comparators</strong> are used to ‚Äúencapsulate[‚Ä¶] the action of comparing two objects from a given total order‚Äù</p>

  <p><em>Data Structures and Algorithms in Java, Goodrich, Tamassia, Goldwasser</em>s</p>
</blockquote>

<p>The comparator is an object external to the keys being compared, not a property of the keys. See the 118 notes for a more full description.</p>

<p>In this context, comparators would be used to provide the total ordering on objects inserted to the priority queue.</p>

<h2 id="sorting-with-list-based-priority-queues">Sorting with list based priority queues</h2>

<p>We can sort a set of items by enqueueing them one by one, using the priority as the total ordering to sort by, and then dequeuing them into a list will result in them being sorted.</p>

<p>When the unsorted concrete implementation is used, this encodes ‚Äú<strong>selection sort</strong>‚Äù. The steps taken in the sort are:</p>

<ol>
  <li>Enqueue all \(n\) elements, each taking \(O(1)\) time into the priority queue, taking \(O(n)\) time</li>
  <li>Dequeue all the elements into sorted order, with the total calls taking \(O(n) + O(n-1) + ... + O(1)\) which is \(O(n^2)\) time. Hence, the <strong>total time complexity</strong> is \(O(n^2)\)</li>
</ol>

<p>When the sorted concrete implementation is used, this encodes ‚Äú<strong>insertion sort</strong>‚Äù. The steps taken in the sort are:</p>

<ol>
  <li>Enqueue \(n\) elements, with the total calls taking \(O(1) + O(2) + ... + O(n)\), which is \(O(n^2)\) time</li>
  <li>Dequeue all \(n\) items, each taking \(O(1)\), taking \(O(n)\) time. Hence, the <strong>total time complexity</strong> is \(O(n^2)\)</li>
</ol>

<h2 id="heaps-adt">Heaps (ADT)</h2>
<blockquote>
  <p><strong>Heaps</strong> are essentially binary trees storing keys at their nodes and satisfying a set of ‚Äúheap properties‚Äù.</p>
</blockquote>

<p>As such, they are implemented in the same way as binary trees, discussed earlier, but with modified internal behaviour when inserting and deleting elements</p>

<h2 id="heap-properties">Heap properties</h2>

<p>The properties a binary tree must fulfil to be a heap are:</p>

<p><strong>Heap-order.</strong> For every internal node other than the root (as it has no parent), the value of the node is greater than the value of the parent node</p>

<p><strong>Complete binary tree.</strong> The height of the tree is minimal for the number of the nodes it contains, and is filled from ‚Äúleft to right‚Äù. This is formally defined as:</p>

<blockquote>
  <p>Let \(h\) be the height of the heap</p>

  <p>‚Äã	Every layer of height \(i\) other than the lowest layer (\(i = h-1\)) has \(2^i\) nodes</p>

  <p>‚Äã	In the lowest layer, the all internal nodes are to the left of external nodes</p>
</blockquote>

<p>The <strong>last node</strong> of the heap is the rightmost node of maximum depth</p>

<p><img src="./images/heapDiagram.png" alt="heapDiagram" class="center" /></p>

<h3 id="height-of-a-heap">Height of a Heap</h3>

<blockquote>
  <p>A heap storing <strong><em>n</em></strong> keys has height = log<sub>2</sub>n.</p>
</blockquote>

<p><strong>Proof.</strong> Let \(h\) be the height of a heap storing \(n\) keys</p>

<p>Since there are \(2^i\) keys at depth \(i = 0, \ldots, h - 1\) and at least 1 key at depth \(h\), we have \(n \ge 1 +2 +4+\ldots+2^{h-1} + 1\)</p>

<p>Thus, \(n \ge 2^h \Rightarrow h \le log_{2}\ n\).</p>

<h2 id="heap-methods">Heap methods</h2>

<h3 id="inserting-into-a-heap">Inserting into a heap</h3>

<p>First, the element is inserted to its temporary position of the rightmost node of maximum depth, so that it fills from left to right, with a running time of \(O(1)\) time, if a pointer to the position to insert is maintained</p>

<p>Then, the <code class="language-plaintext highlighter-rouge">upheap</code> algorithm is run to re-order the heap so that it fulfils the heap properties. This algorithm repeatedly swaps the inserted node with its parent, until either it reaches the root node, or it is larger than the parent node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let k &lt;- the element to insert
While k is smaller than its parent, and k is not the root node
	Swap the values of k and its parent node
</code></pre></div></div>

<p><img src="./images/heapInsertion.png" alt="heapInsertion" class="center" /></p>

<p>Since the heap has a height of \(O(log_2\ n)\), performing a swap takes \(O(1)\) time, and the maximum number of swaps is the height of the heap, the upheap algorithm takes \(O(log_2\ n)\), time. In total, insertion takes \(O(log_2\ n)\) time.</p>

<h3 id="removal-from-a-heap">Removal from a heap</h3>

<p>The smallest item in the heap is the root node, so this value is stored and returned. However, we need to maintain heap properties as it is overwritten.</p>

<p>First, the value of the root node is overwritten with the value of the last node, and the last node is removed from the tree:</p>

<p>Then the <code class="language-plaintext highlighter-rouge">downheap</code> algorithm is run to re-order the heap so that it fulfils the heap properties:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let p &lt;- the root node
Let c &lt;- the child of p with the minimal key (right if existent, otherwise left)
If the value of p is less than or equal to the value of c
	Stop, since the heap order property is fulfilled
Else
	Swap the values of p and c
	Run the downheap algorithm again with the root node (p) now as the child node (c)
</code></pre></div></div>

<p><img src="./images/heapDeletion.png" alt="heapDeletion" class="center" /></p>

<p>As with <code class="language-plaintext highlighter-rouge">upheap</code>, since the heap has a height of \(O(log_2\ n)\), the <code class="language-plaintext highlighter-rouge">downheap</code> algorithm takes \(O(log_2\ n)\) time.</p>

<h2 id="use-in-sorting">Use in sorting</h2>

<p>Since the heap can be used to implement priority queues, it can be used for sorting as with list based implementations, which resulted in selection and insertion sort. This is called a heap sort.</p>

<p>The steps taken in heap sort are:</p>
<ol>
  <li>Enqueue \(n\) elements, with each enqueueing taking \(O(log n)\) time, so the total time is \(O(n \cdot log n)\) time</li>
  <li>Dequeue all \(n\) items, with each Dequeuing taking \(O(log n)\) time, so the total time is \(O(n \cdot log n)\) time</li>
</ol>

<p>Hence, the <strong>overall time complexity</strong> is \(O(n \cdot log n)\)</p>

<p>This is one of the fastest classes of sorting algorithm, and is much more efficient than <strong>quadratic sorting algorithms</strong> like insertion or selection sort.</p>

<h2 id="concrete-implementations">Concrete implementations</h2>

<p>Any <strong>tree implementation</strong> can be used for a heap, as it merely modifies the way getters and setters work, not the internal data structures.</p>

<p>The main draw-back of <strong>array based implementations</strong> of space inefficiency for unbalanced trees is a <strong>non-issue for heaps</strong>, as they are <strong>implicitly balanced</strong>, so they are often used.</p>

<h3 id="array-based-heap-implementation">Array-based Heap Implementation</h3>

<p>Given \(n\) elements, an element at position \(p\) is stored at index/cell \(f(p)\) where</p>

<ul>
  <li>If \(p\) is the root, then \(f(p) = 0\) (index 0)</li>
  <li>If \(p\) is the left child of another position \(q\), \(f(p) = 2f(q) + 1\).</li>
  <li>For the right child this is, \(f(p) = 2f(q) + 2\).</li>
</ul>

<blockquote>
  <p>The <strong>last node</strong> corresponds to the last occupied index. <strong>Insertion</strong> will insert a new element into the first free cell (unoccupied index) and <strong>remove_min</strong> will remove cell 0.</p>
</blockquote>

<p>Usually we use an Array List so that the array can grow.</p>

<h2 id="building-heaps-in-linear-time">Building heaps in linear time</h2>

<p>The number of operations for <code class="language-plaintext highlighter-rouge">upheap</code> and <code class="language-plaintext highlighter-rouge">downheap</code> on a item in the heap are related to its position. If an item is closer to the top, <code class="language-plaintext highlighter-rouge">upheap</code> will be quicker, since it has ‚Äúless far to go‚Äù. Since there are more values on the bottom layer of the heap (\(2^n\)) , than the top layer of the heap (\(1\)), if we have to apply one of the algorithms to all of the items in the heap, we should prefer to use <code class="language-plaintext highlighter-rouge">downheap</code>, as it will result in fewer operations</p>

<p>Since we can represent a heap using an array-based implementation of a tree, we can take the unsorted array we want to turn into a heap, then use heap operations on the array directly to turn it into a valid heap expressed in the array-based implementation.</p>

<p>As discussed previously, we could go about this in two ways:</p>

<ol>
  <li>Iterate from the first to the last index of the unsorted array, calling <code class="language-plaintext highlighter-rouge">upheap</code> on each of the items. At each step, all the items preceding the current index in the array will form a valid heap, so after calling <code class="language-plaintext highlighter-rouge">upheap</code> on every item, the array is a valid heap</li>
  <li>Iterate from the last to the first index of the unsorted array, calling <code class="language-plaintext highlighter-rouge">downheap</code> on each of the items</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let H &lt;- the unsorted array to convert to a heap
For each item in the array in reverse order
	Call downheap on the item
</code></pre></div></div>

<p>There is a proof that this is actually \(O(n)\) (<a href="https://stackoverflow.com/a/18742428">source #1</a>, <a href="https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/">source #2</a>), but it‚Äôs a bit tricky to explain here, so is omitted</p>

<p>A final point is despite the fact we can build a heap in \(O(n)\) time, we cannot use this to sort the array in linear time, as removing from the top of the heap still takes \(O(n\ log\ n)\) time</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="skip-lists">Skip Lists</h1>
       
            <h2 id="motivations-for-skip-lists">Motivations for skip lists</h2>

<p>We want to be able to efficiently implement both searching, and insertion and deletion</p>

<p>For fast searching, we need the list to be sorted, and we have come across two concrete implementations of lists, but neither of which fulfil both of  these goals.</p>

<ul>
  <li>Sorted arrays
    <ul>
      <li>Easy to search using binary search, since they are not indexable, needs \(O(log\ n)\) time</li>
      <li>Difficult insert/delete from, as elements need to be ‚Äúshuffled up‚Äù to maintain ordering, needs \(O(n)\) time</li>
    </ul>
  </li>
  <li>Sorted lists
    <ul>
      <li>Easy to insert/delete from, assuming the position is known, needs \(O(1)\) time</li>
      <li>Difficult to search, since they are not indexable, needs \(O(n)\) time</li>
    </ul>
  </li>
</ul>

<h2 id="skip-lists-adt">Skip Lists (ADT)</h2>

<p><strong>Skip lists</strong> are composed from a number of sub-lists, which act as layers within them, which we denote by the set \(S = \{S_0, S_1, ..., S_h\}\) where \(h\) denotes the number of layers in the list, i.e. its ‚Äúheight‚Äù</p>

<ul>
  <li>
    <p>All lists have a guard values \(+ \infty\) and \(- \infty\) at either end, and all the elements are in order between those values</p>
  </li>
  <li>
    <p>The ‚Äúbottom‚Äù list, \(S_0\) contains all the values in order between the guards</p>
  </li>
  <li>
    <p>The ‚Äútop‚Äù list, \(S_h\), contains only the guard values, \(+ \infty\) and \(- \infty\)</p>
  </li>
  <li>
    <p>Each list \(S_i\) for \(0 &lt; i &lt; h\) (i.e. everything bar the top list, which contains only the guards, and the bottom list, which contains all elements) contains a random subset of the elements in the list below it, \(S_1\)</p>
  </li>
  <li>
    <p>The probability of an element in \(S_i\) being in the list above it, \(S_{i+1}\), is \(0.5\)</p>
  </li>
</ul>

<p>A diagram of the structure of a skip list is shown below</p>

<p><img src="./images/skipLists.png" alt="skipLists" class="center" /></p>

<h2 id="searching">Searching</h2>

<p>To search for an value <code class="language-plaintext highlighter-rouge">v‚Äã</code> in a skip list, we follow the algorithm</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">search</span><span class="o">(</span><span class="n">k</span><span class="o">):</span>
	<span class="c1">//Start at the minus-infinity guard of the top list</span>
	<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">skiplist</span><span class="o">.</span><span class="na">first</span><span class="o">()</span>
	<span class="nc">Repeat</span>
		<span class="n">e</span> <span class="o">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">().</span><span class="na">element</span><span class="o">()</span>
		<span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">()</span> <span class="o">==</span> <span class="n">k</span>
			<span class="k">return</span> <span class="n">e</span>
		<span class="k">else</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span>
            <span class="c1">//Drop down to the next level</span>
			<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="na">below</span><span class="o">()</span>
			<span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="kc">null</span>
            	<span class="k">return</span> <span class="kc">null</span>
		<span class="k">else</span> <span class="c1">//e.key() &lt; k</span>
            <span class="c1">//Scan Forward Step</span>
            <span class="n">p</span> <span class="o">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">()</span>     
</code></pre></div></div>

<p><img src="./images/skipListsSearch.png" alt="skipListsSearch" class="center" /></p>

<h2 id="inserting">Inserting</h2>

<p>To insert a value <code class="language-plaintext highlighter-rouge">v</code>‚Äã into a skip list, we follow the algorithm.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span> <span class="o">&lt;-</span> <span class="n">number</span> <span class="n">of</span> <span class="n">flips</span> <span class="n">of</span> <span class="n">a</span> <span class="n">fair</span> <span class="n">coin</span> <span class="n">before</span> <span class="n">a</span> <span class="n">head</span> <span class="n">comes</span> <span class="n">up</span>
<span class="nc">If</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">height</span> <span class="n">of</span> <span class="n">skip</span> <span class="n">list</span>
	<span class="nc">Add</span> <span class="k">new</span><span class="o">,</span> <span class="n">empty</span><span class="o">,</span> <span class="n">sub</span><span class="o">-</span><span class="n">lists</span> <span class="o">{</span><span class="no">S</span><span class="o">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="o">),</span> <span class="o">...,</span> <span class="no">S</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)}</span> <span class="n">to</span> <span class="no">S</span> 
<span class="nc">Using</span> <span class="n">the</span> <span class="n">search</span> <span class="n">algorithm</span><span class="o">,</span> <span class="n">we</span> <span class="n">find</span> <span class="n">v</span> <span class="c1">//even though we know it is not inserted</span>
	<span class="nc">For</span> <span class="n">every</span> <span class="n">dropdown</span> <span class="n">step</span><span class="o">,</span> <span class="n">store</span> <span class="n">the</span> <span class="n">position</span> <span class="n">of</span> <span class="n">the</span> <span class="n">element</span> <span class="n">in</span> <span class="n">an</span> <span class="n">array</span>
	<span class="c1">// This array stores the positions p(0) to p(i) of the </span>
	<span class="c1">// largest element lesser than v of each sublist S(j)</span>
<span class="nc">For</span> <span class="n">each</span> <span class="n">sublist</span> <span class="n">from</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">i</span>
	<span class="nc">Insert</span> <span class="n">v</span> <span class="n">into</span> <span class="nf">S</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="n">immediately</span> <span class="n">after</span> <span class="n">the</span> <span class="n">position</span> <span class="nf">p</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="n">in</span> <span class="n">array</span>
</code></pre></div></div>

<p><img src="./images/skipListsInsertion.png" alt="skipListsInsertion" class="center" /></p>

<h2 id="deleting">Deleting</h2>

<p>To delete a value <code class="language-plaintext highlighter-rouge">v</code>‚Äã from a skip list, we follow the algorithm</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Using</span> <span class="n">search</span> <span class="n">algorithm</span><span class="o">,</span> <span class="n">find</span> <span class="n">v</span> <span class="n">in</span> <span class="n">skiplist</span>
<span class="nc">Once</span> <span class="n">found</span> <span class="n">at</span> <span class="n">position</span> <span class="n">p</span><span class="o">,</span>
<span class="k">while</span> <span class="n">p</span><span class="o">.</span><span class="na">below</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span>
	<span class="n">hold</span> <span class="o">&lt;-</span> <span class="n">p</span>
	<span class="nf">delete</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="c1">// Delete v from sublists below</span>
	<span class="n">p</span> <span class="o">&lt;-</span> <span class="n">hold</span>
<span class="nc">Remove</span> <span class="n">all</span> <span class="n">but</span> <span class="n">one</span> <span class="n">list</span> <span class="n">containing</span> <span class="n">only</span> <span class="n">guards</span> <span class="n">from</span> <span class="n">the</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="n">skip</span> <span class="n">list</span>
</code></pre></div></div>

<p><img src="./images/skipListsDeletion.png" alt="skipListsDeletion" class="center" /></p>

<h2 id="implementation">Implementation</h2>

<p>We can use ‚Äúquad-nodes‚Äù, which are similar to those used in linked lists, but with four pointers, instead of just one to store the entry, and links to the previous, next, below and above nodes:</p>

<p><img src="./images/skipListsQuadNode.png" alt="skipListsQuadNode" class="center" /></p>

<p>Additionally, there are special guard nodes, with the values \(+ \infty\) and \(- \infty\), and fewer pointers, as they don‚Äôt have adjacencies on one side.</p>

<h2 id="performance">Performance</h2>

<h3 id="space-usage">Space usage</h3>

<p>Dependent on randomly generated numbers for how many elements are in high layers, and how high the layers are.</p>

<p>We can find the <strong>expected number of nodes</strong> for a skip list of \(n\) elements:</p>

<blockquote>
  <p>The probability of having \(i\) layers in the skip list is \(\frac{1}{2^i}\).</p>

  <p>If the probability of any one of \(n\) entries being in a set is \(p\), the <strong>expected size</strong> of the set is \(n \cdot p\)</p>

  <p>Hence, the expected size of a list \(S_i\) is \(\frac{n}{2^i}\)</p>

  <p>This gives the expected number of elements in the list as \(\sum_{i=0}^{h}(\frac{n}{2^i}),\) where \(h\) is the height.</p>

  <p>We can express this as \(n \cdot \sum_{i=0}^{h}(\frac{1}{2^i}) \lt 2n\), and with the sum <strong>converging</strong> to a <strong>constant factor</strong>, so the <strong>space complexity</strong> is \(O(n)\).</p>
</blockquote>

<h3 id="height">Height</h3>

<p>The height of a skip list of \(n\) items is <strong>likely</strong> to (since it is generated randomly) have a height of order \(O(log\ n)\).</p>

<p>We show this by taking a height logarithmically related to the number of elements, and showing that the probability of the skip list having a height greater than that is very small.</p>

<blockquote>
  <p>The probability that a layer \(S_i\) has at least one item is at most \(\frac{n}{2^i}\)</p>

  <p>Considering a layer logarithmically related to the number of elements \(i = 3 \cdot log\ n\)</p>

  <p>The probability of the layer \(S_i\) has at least one entry is at most \(\frac{n}{2^{3 \cdot log\ n}} = \frac{n}{n^3} = \frac{1}{n^2}\)</p>

  <p>Hence, the probability of a skip list of \(n\) items having a height of more than \(3 \cdot log\ n\) is at most \(\frac{1}{n^2}\), which tends to a negligibly small number very quickly.</p>
</blockquote>

<h3 id="search-time">Search time</h3>

<p>The search time is <strong>proportional</strong> to the number of steps scan forward and drop down steps.</p>

<blockquote>
  <p>In the worst case, both dimensions have to be totally traversed, if the item is both bigger than all other items, or not present.</p>

  <p>The number of <strong>drop down steps</strong> is <strong>bounded</strong> by the height so it is <strong>trivial</strong> to see that it is \(\approx O(log\ n)\) with high probability,</p>

  <p>To analyse the scan-forward step, firstly <a href="#skip-lists-adt">recall</a> that given an item in sub-list \(i\), its probability of being in sub-list \((i-1)\) as well is ¬Ω.¬†</p>

  <p>Let‚Äôs say that we scanned \(n_i\) keys at sub-list \(i\) before we dropped down a level to \((i -1)\). Each subsequent key that we <strong>scan forward to</strong> cannot exist in \((i-1)\), otherwise we would have already seen it.</p>

  <p>A probabilistic fact is that the <strong>expected</strong> number of keys we will encounter at \((i-1)\) is 2 which is an \(O(1)\) operation per sub-list. <a href="#expectation-explanation">Why?</a></p>

  <p>Hence, the expected number of scan forward steps in <strong>total</strong> is \(O(log\ n)\) because the number of sub-list is the height of the skiplist.</p>
</blockquote>

<p>Hence, the total <strong>search time</strong> is \(O(log\ n)\).</p>

<h3 id="update-time">Update time</h3>

<p>Since the insert and delete operations are both essentially wrappers around the search operation, and all of their additional functionality is of \(O(log\ n)\) or better, the time complexity is the same as the search function</p>

<h3 id="expectation-explanation">Expectation Explanation</h3>

<p><em>FYI ONLY.</em> The source of this explanation is by <a href="https://math.stackexchange.com/questions/1196452/expected-value-of-the-number-of-flips-until-the-first-head">JMoravitz on Stack Exchange</a> (Accessed 16 May 2021)</p>

<blockquote>
  <p>Let X be a <strong>discrete random variable</strong> with possible outcomes:</p>

  <p>\(x1,x2,x3,‚Ä¶,xi,‚Ä¶\) with associated probabilities \(p1,p2,p3,‚Ä¶,pi,‚Ä¶\)</p>

  <p>The <strong>expected value</strong> of \(f(X)\) is given as: \(E[f(X)] = \sum\limits_{i\in\Delta} f(x_i)p_i\)</p>
</blockquote>

<p>For our example, we are examining the number of items we expect to see in both sub-list \(i\) and \((i-1)\).</p>

<p>Hence, \(X\) could be \(1,2,3,\ldots,n\) with corresponding probabilities \(\frac{1}{2},\frac{1}{4},\frac{1}{8},\dots,\frac{1}{2^n}\)</p>

<p>So, the expected value of \(X\) is: \(E[X] = \sum\limits_{i=1}^n i(\frac{1}{2})^i\). As \(n\rightarrow \infty\), \(E[X] \rightarrow 2\).</p>

<p>This is a well known infinite sum of the form \(\sum\limits_{i=1}^\infty i p (1-p)^{i-1}=\frac1p\)</p>

<p>To prove this:</p>

\[\sum\limits_{i=1}^\infty i p (1-p)^{i-1} = p\sum\limits_{i=1}^\infty i (1-p)^{i-1}\\
= p\left(\sum\limits_{i=1}^\infty (1-p)^{i-1} + \sum\limits_{i=2}^\infty (1-p)^{i-1} + \sum\limits_{i=3}^\infty (1-p)^{i-1} + \dots\right)\\
= p\left[(1/p)+(1-p)/p+(1-p)^2/p+\dots\right]\\
= 1 + (1-p)+(1-p)^2+\dots\\
=\frac{1}{p}\]

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="binary-search--self-balancing-trees">Binary Search &amp; Self-Balancing Trees</h1>
       
            <h2 id="ordered-maps">Ordered Maps</h2>

<blockquote>
  <p><strong>Binary search trees</strong> can be used as a concrete implementation of <strong>ordered maps</strong>, with items being stored in the tree ordered by their key. (Keys are assumed to come from a total order)</p>
</blockquote>

<p><strong>Search tables</strong> are <strong>another concrete implementation</strong> of ordered maps, but instead use a sorted sequence, normally an array, which is searchable with <strong>binary search</strong> in \(O(log\ n)\), <strong>but</strong> requires \(O(n)\) for insertion and removal.</p>

<ul>
  <li>This means they are <strong>only effective</strong> for either <strong>small maps</strong>, or cases where there are <strong>few</strong> insertions and deletions</li>
</ul>

<p>Ordered maps support nearest neighbour queries, finding next highest and next lowest items.</p>

<h2 id="binary-search-trees">Binary Search Trees</h2>

<p>The properties of binary search trees are:</p>

<ul>
  <li>External nodes store no items</li>
  <li>All <strong>left children</strong> of any internal node have a <strong>smaller key</strong> than their <strong>parent node</strong></li>
  <li>All <strong>right children</strong> of any internal node have a <strong>larger key</strong> than their <strong>parent node</strong></li>
  <li><strong>In-order traversals</strong> yield a sequence of the keys in <strong>ascending order</strong></li>
</ul>

<h3 id="operations">Operations</h3>

<h4 id="searching">Searching</h4>

<p>Start at the root, and recursively proceed down the appropriate subtrees until the key or an external node is found</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">root</span> <span class="n">node</span> <span class="n">of</span> <span class="n">the</span> <span class="n">tree</span> <span class="n">to</span> <span class="n">search</span>
<span class="nc">Let</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">key</span> <span class="n">to</span> <span class="n">search</span> <span class="k">for</span>
<span class="nf">Search</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span>
  
<span class="nc">Function</span> <span class="nf">Search</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="c1">// n for node, k for key</span>
	<span class="k">if</span> <span class="n">n</span> <span class="n">is</span> <span class="n">an</span> <span class="n">external</span> <span class="n">node</span>
		<span class="k">return</span> <span class="kc">null</span> <span class="c1">// key is not in the tree</span>
	<span class="k">else</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="na">key</span><span class="o">()</span>
		<span class="k">return</span> <span class="nf">Search</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">leftChild</span><span class="o">(),</span> <span class="n">k</span><span class="o">)</span>
	<span class="k">else</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">.</span><span class="na">key</span><span class="o">()</span>
		<span class="k">return</span> <span class="nf">Search</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">rightChild</span><span class="o">(),</span> <span class="n">k</span><span class="o">)</span>
	<span class="k">else</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="o">.</span><span class="na">key</span><span class="o">()</span>
		<span class="k">return</span> <span class="n">n</span> <span class="c1">// key is at the current node, n</span>
</code></pre></div></div>

<h4 id="insertion">Insertion</h4>

<p>Perform the searching operation, but when an external node is found, instead of returning that the key is not present, set that internal node as the key to insert, and give it two external child nodes</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span> <span class="nf">Insert</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="c1">// node to insert is n</span>
	<span class="nc">Start</span> <span class="n">at</span> <span class="n">root</span> <span class="n">and</span> <span class="n">search</span> <span class="n">until</span> <span class="n">external</span> <span class="n">node</span> <span class="n">is</span> <span class="n">found</span>
		<span class="n">e</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">external</span> <span class="n">node</span> <span class="n">terminating</span> <span class="n">the</span> <span class="n">search</span> <span class="n">algorithm</span>
		<span class="n">e</span> <span class="o">&lt;-</span> <span class="n">n</span>
	<span class="n">e</span><span class="o">.</span><span class="na">leftChild</span> <span class="o">&lt;-</span> <span class="kc">null</span>  <span class="c1">// Add two external child nodes </span>
	<span class="n">e</span><span class="o">.</span><span class="na">rightChild</span> <span class="o">&lt;-</span> <span class="kc">null</span> <span class="c1">// to e so that it is now internal</span>
</code></pre></div></div>

<h4 id="deletion">Deletion</h4>

<p>Dependent on the number of children of the node to delete, different operations are needed to delete the node</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span> <span class="nf">Delete</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="c1">// delete node with key k</span>
	<span class="nc">Use</span> <span class="nf">Search</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="n">to</span> <span class="n">find</span> <span class="n">node</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">with</span> <span class="n">key</span> <span class="n">k</span>
	<span class="k">if</span> <span class="n">the</span> <span class="n">node</span> <span class="n">has</span> <span class="n">no</span> <span class="n">internal</span> <span class="n">children</span>
		<span class="c1">// Overwrite the node to become an empty external node</span>
		<span class="n">n</span> <span class="o">&lt;-</span> <span class="kc">null</span>
	<span class="k">else</span> <span class="k">if</span> <span class="n">the</span> <span class="n">node</span> <span class="n">has</span> <span class="n">only</span> <span class="mi">1</span> <span class="n">internal</span> <span class="n">child</span>
		<span class="c1">// Overwrite it with the internal child node</span>
		<span class="n">n</span> <span class="o">&lt;-</span> <span class="n">either</span> <span class="n">leftChild</span> <span class="n">or</span> <span class="n">rightChild</span>
	<span class="k">else</span> <span class="c1">// the node has two internal children</span>
		<span class="n">i</span> <span class="o">&lt;-</span> <span class="n">node</span> <span class="n">that</span> <span class="n">immediately</span> <span class="n">follows</span> <span class="n">it</span> <span class="n">in</span> <span class="n">an</span> <span class="n">in</span><span class="o">-</span><span class="n">order</span> <span class="n">traversal</span>
		<span class="c1">// i is the left-most descendent of n.rightChild()</span>
		<span class="n">n</span> <span class="o">&lt;-</span> <span class="n">i</span>
		<span class="n">i</span> <span class="o">&lt;-</span> <span class="kc">null</span> <span class="c1">// Set i to be empty external node</span>
</code></pre></div></div>

<h3 id="algorithm">Algorithm</h3>

<p>In all cases, the <strong>space complexity</strong> is \(O(n)\)</p>

<p>The time complexity for searching, inserting and deleting is dependent on the height of the tree:</p>
<ul>
  <li>If the tree is <strong>balanced</strong>, then the height is \(log\ n\), so the time for these operations is \(O(log\ n)\)</li>
  <li>In the worst case, the tree can be <strong>totally unbalanced</strong>, just a straight line of internal nodes, in which case the height is \(n\), so the time for these operations is \(O(n)\)</li>
</ul>

<h2 id="avl-trees">AVL trees</h2>

<blockquote>
  <p><strong>AVL trees</strong> are a concrete implementation of <strong>self-balancing</strong> binary search tree, with insertion and deletion operations designed to re-arrange the tree to ensure it remains balanced. It is named after its creators, Adelson-Velsky and Landis</p>
</blockquote>

<p>Other self-balancing binary search trees exist, such as red-black trees, but this is a common approach to implementing such an ADT.</p>

<h3 id="properties-of-avl-trees">Properties of AVL Trees</h3>

<p><em>These are also properties of balanced binary trees in general.</em></p>

<blockquote>
  <p>For every internal node in the tree, the <strong>heights of the child subtrees</strong> can differ by <strong>at most 1</strong>.</p>

  <p>This ensure that the height of the balanced tree storing \(n\) keys is \(O(log\ n)\).</p>
</blockquote>

<p><strong>Proof of Height. Induction.</strong> Le use bound \(n(h)\): the minimum number of internal nodes of an AVL tree of height \(h\).</p>

<ul>
  <li>We can see that \(n(1) = 1\) and \(n(2) =2\)</li>
  <li>For \(n &gt; 2\), an AVL Tree of height \(h\) contains the root node, one AVL subtree of height \(n-1\) and another of height \(n-2\) at most.</li>
  <li>That is, \(n(h) = 1 + n(h-1) + n(h-2)\)</li>
  <li>Knowing that \(n(h-1) &gt; n(h-2) \Rightarrow n(h) &gt; 2n(h-2) \Rightarrow n(h) &gt; 2^{\frac{h}{2}-1}\)</li>
  <li>Therefore, \(h &lt; 2log_2(n(h)) + 2\)</li>
</ul>

<p>Thus height of AVL Tree is \(O(log\ n)\).</p>

<h3 id="operations-1">Operations</h3>

<p><strong>Searching</strong>, <strong>insertion</strong> and <strong>deletion</strong> is approached as it is in a normal binary search tree. However, after every <strong>insertion</strong> and <strong>deletion</strong> the AVL Tree is <strong>restructured</strong> to make sure it is <strong>balanced</strong>. This is because insertions and deletions change the number of nodes in the tree and this <strong>may</strong> make it unbalanced.</p>

<h3 id="trinode-restructuring">Trinode Restructuring</h3>

<p>We will refer to the height of a node \(n\), as the height of the <strong>subtree</strong> that \(n\) is the <strong>root</strong> of. Whenever a particular node \(p\), we know that it‚Äôs children nodes \(l\) and \(r\) have heights that differ by <strong>at least 2</strong>.</p>

<div align="center" style="display:flex;justify-content:space-evenly;">
  <img src="./part10.assets/trinode1.svg" />
  <img src="./part10.assets/trinode2.svg" />
</div>

<p>To rebalance \(p\), we have to make the <strong>‚Äùtaller‚Äù</strong> child the new <strong>parent</strong>. To do this</p>

<ul>
  <li>If \(p\) is smaller than the ‚Äútaller‚Äù child (means \(r\) is taller), then we set \(p\) <strong>new</strong> right child to \(r\)‚Äòs <strong>current</strong> left child and set \(p\) as \(r\)‚Äôs <strong>new</strong> left child. Otherwise, we set \(p\) <strong>new</strong> left child to \(l\)‚Äòs <strong>current</strong> right child, and set \(p\) as \(l\)‚Äôs <strong>new</strong> right child.</li>
</ul>

<figure>
  <div align="center" style="display:flex;justify-content:space-evenly;">
  <img src="./part10.assets/trinode2.svg" />
  <img src="./part10.assets/rightarrow.svg" />
  <img src="./part10.assets/trinode2.1.svg" />
  <img src="./part10.assets/rightarrow.svg" />
  <img src="./part10.assets/trinode2.2.svg" />
</div>
    <figcaption>Left Child is Taller</figcaption>
</figure>

<p>This is known as a <strong>single rotation</strong>. There is another case where, a <strong>double rotation</strong> is required to properly rebalance \(p\).</p>

<figure>
  <div align="center" style="display:flex;justify-content:space-evenly;">
  <img src="./part10.assets/trinode4.svg" />
  <img src="./part10.assets/trinode5.svg" />
</div>
  <figcaption>Double Rotation Cases</figcaption>
</figure>

<h4 id="double-rotation">Double Rotation</h4>

<p>The idea behind it is the same, the only thing is that we have to rotate the ‚Äútaller‚Äù child left or right for \(l\) and \(r\) respectively, to arrive at the <strong>single rotation case</strong>.</p>

<figure>
  <div align="center" style="display:flex;justify-content:space-evenly;">
  <img src="./part10.assets/trinode5.svg" />
  <img src="./part10.assets/rightarrow.svg" />
    <img src="./part10.assets/trinode5.1.svg" />
    <img src="./part10.assets/rightarrow.svg" />
    <img src="./part10.assets/trinode5.2.svg" />
</div>
    <figcaption>Double Rotation when Right Child is Taller</figcaption>
</figure>

<h4 id="rebalancing">Rebalancing</h4>

<blockquote>
  <p>The reason I have used the <code class="language-plaintext highlighter-rouge">..</code> and <code class="language-plaintext highlighter-rouge">...</code> symbols in the diagram above is to emphasise that the sub-trees may <strong>extend</strong> by an <strong>arbitrary amount</strong>, but as long as they were previously <strong>rebalanced</strong> we only need to consider the few nodes shown in the diagram to <strong>rebalance</strong> node \(p\).</p>
</blockquote>

<p>Consequently, after the <strong>insertion</strong> or <strong>deletion</strong> of a node, the tree may be unbalanced somewhere higher up in the tree. If \(p\) is not the <strong>overall</strong> root node, we will have to continue scanning upwards to check if any nodes are unbalanced.</p>

<h2 id="performance">Performance</h2>

<p>In all cases, the <strong>space complexity</strong> is \(O(n)\), and <strong>searching</strong> takes \(O(log\ n)\) time -  as with any balanced binary tree.</p>

<p><strong>Insertion</strong> and <strong>deletion</strong> are also \(O(log\ n)\). This is because searching for the element is \(O(log\ n)\), and then restructuring the tree to maintain the balance property is \(O(log\ n)\) because scanning upwards from an external node to the root is proportional to the height of the tree</p>

<p>So the total time complexity for these 2 operations is also \(O(log\ n)\).</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="graphs">Graphs</h1>
       
            <h2 id="graphs-as-a-mathematical-concept">Graphs as a mathematical concept</h2>

<p><strong>Graphs</strong> are defined as a pair \(G = (V, E)\) were \(V\) is a set of vertices, and \(E\) is an unordered collection of pairs of vertices, called edges, for example: \(G = (\{a, b, c\}, [(a,b), (b,c), (c,a)])\)</p>

<p>Directed and undirected graphs</p>
<ul>
  <li>
    <p>In undirected graphs, the edge pair indicates that both vertices are connected to each other</p>
  </li>
  <li>
    <p>In directed graphs, the edge pair indicates that the first vertex is connected to the second, but not vice versa</p>
  </li>
</ul>

<table class="centeredtable">
  <thead>
    <tr>
      <th>Term</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Adjacent Vertices</strong></td>
      <td>Vertices with an edge between them</td>
    </tr>
    <tr>
      <td><strong>Edges incident on a vertex</strong></td>
      <td>Edges which both connect to the same vertex</td>
    </tr>
    <tr>
      <td><strong>End vertices/endpoints</strong></td>
      <td>The two vertices in the pair that an edge connects to</td>
    </tr>
    <tr>
      <td><strong>Degree of a vertex</strong></td>
      <td>The number of edges that connect to a pair</td>
    </tr>
    <tr>
      <td><strong>Parallel edges</strong></td>
      <td>Two edges both connecting the same nodes (This is the reason why edges are an unordered collection, not a <strong>set</strong>)</td>
    </tr>
    <tr>
      <td><strong>Self-loop</strong></td>
      <td>An edge whose vertices are both the same</td>
    </tr>
    <tr>
      <td><strong>Path</strong></td>
      <td>A sequence of alternating vertices and edges, starting and ending in a vertex</td>
    </tr>
    <tr>
      <td><strong>Simple paths</strong></td>
      <td>Paths containing no repeating vertices (hence are acyclic)</td>
    </tr>
    <tr>
      <td><strong>Cycle</strong></td>
      <td>A path starting and ending at the same vertex</td>
    </tr>
    <tr>
      <td><strong>Acyclic</strong></td>
      <td>A graph containing no cycles</td>
    </tr>
    <tr>
      <td><strong>Simple cycle</strong></td>
      <td>A path where the only repeated vertex is the starting/ending one</td>
    </tr>
    <tr>
      <td><strong>Length (of a path of cycle)</strong></td>
      <td>The number of edges in the path/cycle</td>
    </tr>
    <tr>
      <td><strong>Tree</strong></td>
      <td>A connected acyclic graph</td>
    </tr>
    <tr>
      <td><strong>Weight</strong></td>
      <td>A weight is a numerical value attached to each edge. In weighted graphs relationships between vertices have a magnitude.</td>
    </tr>
    <tr>
      <td><strong>Dense</strong></td>
      <td>A dense graph is one where the number of edges is close to the maximal number of edges.</td>
    </tr>
    <tr>
      <td><strong>Sparse</strong></td>
      <td>A sparse graph is one with only a few edges.</td>
    </tr>
  </tbody>
</table>

<h3 id="graph-properties">Graph properties</h3>

<blockquote>
  <p><strong>Property 1.</strong> The <strong>sum of the degrees</strong> of the vertices in an undirected graph is an even number.</p>

  <p><strong>Proof. Handshaking Theorem.</strong> Every edge must connect two vertices, so sum of degrees is twice the number of edges, which must be even.</p>
</blockquote>

<blockquote>
  <p><strong>Property 2.</strong> An undirected graph with no self loops nor parallel edges, with number of edges \(m\) and number of vertices \(n\) fulfils the property \(m \leq \frac{n \cdot (n-1)}{2}\)</p>

  <p><strong>Proof.</strong> The first vertex can connect to \(n-1\) vertices (all vertices bar itself), then the second can connect to \(n-2\) (all the vertices bar itself and the first vertex, which it is already connected to), and so on, giving the sum \(1+2+...+n\) , which is known to be \(\frac{n \cdot (n-1)}{2}\)</p>

  <p>Fully connected graphs fulfil the property \(m = \frac{n \cdot (n-1)}{2}\)</p>
</blockquote>

<h2 id="graphs-as-an-adt">Graphs as an ADT</h2>

<blockquote>
  <p><strong>Graphs</strong> are a ‚Äúcollection of vertex and edge objects‚Äù</p>
</blockquote>

<p>They have a large number of fundamental operations, to the extent it is unnecessary to enumerate them here, but they are essentially just accessor, mutator, and count methods on the vertices and edges</p>

<h3 id="concrete-implementations">Concrete Implementations</h3>

<h4 id="edge-list-structure">Edge List Structure</h4>

<p><img src="images\edgeListGraph.png" alt="edgeListGraph" class="center" style="zoom:50%;" /></p>

<p>Consists of</p>

<ul>
  <li>A list of vertices ‚Äì contains references to <strong>vertex objects</strong></li>
  <li>A list of edges ‚Äì contains references to <strong>edge objects</strong></li>
  <li><strong>Vertex Object</strong>
    <ul>
      <li>Contains the element that it stores</li>
      <li>Also has a reference to its <strong>position</strong> in the vertex list.</li>
    </ul>
  </li>
  <li><strong>Edge Object</strong>
    <ul>
      <li>Contains the element it stores</li>
      <li>Reference to origin vertex</li>
      <li>Reference to destination vertex</li>
      <li>Reference to <strong>position</strong> in edge list</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Advantage of Reference to Position.</strong> Allows faster removal of vertices from the vertex list because vertex objects already have a reference to their position.</p>

  <p><strong>Limitations.</strong> As you can see, the vertex objects has no information about the incident edges. Therefore, if we wanted to remove a vertex object, call it <strong><em>w</em></strong>, from the list we will have to scan the entire <strong>edge list</strong> to check which edges point to <strong><em>w</em></strong>.</p>
</blockquote>

<h4 id="adjacency-list">Adjacency list</h4>

<p><img src="./images/adjacencyListGraph.png" alt="adjacencyListGraph" class="center" style="zoom:50%;" /></p>

<p>Consists of</p>

<ul>
  <li>1 list containing all of the vertices. Each of which have a pointer to a list edge objects of incident edges.</li>
</ul>

<h4 id="adjacency-matrix">Adjacency matrix</h4>

<p>This is an extension of the <strong>edge list structure</strong> ‚Äì we extend/add-on to the <strong>vertex object</strong>.</p>

<p><img src="./images/adjacencyMatrixGraph.png" alt="adjacencyMatrixGraph" class="center" style="zoom:50%;" /></p>

<p>Consists of</p>

<ul>
  <li>Extended/augmented <strong>Vertex Object</strong>
    <ul>
      <li>Integer key (index) associated with each vertex. A graph with \(n\) vertices then their keys go from 0 to \((n-1)\).</li>
    </ul>
  </li>
  <li><strong>Adjacency Matrix</strong> ‚Äì 2D Array
    <ul>
      <li>Square matrix, with each dimension being the number of vertices \(n\)</li>
      <li>Let \(C_{ij}\) represent a particular cell in the matrix. \(C_{ij}\) either has a reference to an <strong>edge object</strong> for adjacent vertices or <strong>null</strong> for <strong>non</strong>-adjacent vertices.
        <ul>
          <li>If a reference to an edge object, \(k\), is stored at cell \(C_{ij}\) it means that \(k\) is an edge <strong>from</strong> the vertex with index \(i\) <strong>to</strong> the vertex with index \(j\).</li>
          <li>If our graph is <strong>undirected</strong> then the matrix will be <strong>symmetrical</strong> across the <strong>main diagonal</strong>, meaning \(C_{ij} = C_{ji}\) (as shown in the diagram above).</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Advantage of 2D Adjacency Array.</strong> We are able to lookup edges between vertices in \(O(1)\) time.</p>

  <p><strong>Limitations.</strong></p>

  <ul>
    <li>Not easy to change the size of the array</li>
    <li>Space Complexity is \(O(n^2)\) and in many practical applications the graphs we are considering do not have many edges, so using an adjacency matrix might not be so space efficient.</li>
  </ul>
</blockquote>

<h4 id="performance">Performance</h4>

<p>Given a graph with <strong>n</strong> vertices and <strong>m</strong> edges (no parallel edges and no self-loops).</p>

<table class="centeredtable">
  <thead>
    <tr>
      <th style="text-align: left">¬†</th>
      <th style="text-align: center">Edge List</th>
      <th style="text-align: center">Adjacency List</th>
      <th style="text-align: center">Adjacency Matrix</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Space</strong></td>
      <td style="text-align: center">O(n+m)</td>
      <td style="text-align: center">O(n+m)</td>
      <td style="text-align: center">O(n<sup>2</sup>) ‚ùå</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">incidentEdges(v)</code></td>
      <td style="text-align: center">O(m)</td>
      <td style="text-align: center">O(deg(v)) ‚≠ê</td>
      <td style="text-align: center">O(n)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">areAdjacent(v,w)</code></td>
      <td style="text-align: center">O(m)</td>
      <td style="text-align: center">O(min(<strong>deg(v)</strong>, <strong>deg(w)</strong>))</td>
      <td style="text-align: center">O(1) ‚≠ê</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">insertVertex(o)</code></td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: center">O(n<sup>2</sup>) ‚ùå</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">insertEdge(v,w,o)</code></td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: center">O(1)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">removeVertex(v)</code></td>
      <td style="text-align: center">O(m)</td>
      <td style="text-align: center">O(deg(v)) ‚≠ê</td>
      <td style="text-align: center">O(n<sup>2</sup>)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">removeEdge(e)</code></td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: center">O(1)</td>
    </tr>
  </tbody>
</table>

<h4 id="space-complexity-choosing-between-an-adjacency-matrix-and-an-adjacency-list">Space complexity (choosing between an adjacency matrix and an adjacency list)</h4>

<p>We can determine more specific space complexities for both graph structures based on the type of graph we are using:</p>

<table>
  <thead>
    <tr>
      <th>Type of graph</th>
      <th>Adjacency matrix</th>
      <th>Adjacency list</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>General case</td>
      <td>\(O(n^2)\)</td>
      <td>\(O(n+m)\) ‚≠ê</td>
    </tr>
    <tr>
      <td>Sparse</td>
      <td>Inefficient use of \(O(n^2)\) space ‚ùå</td>
      <td>Few edges to search through list for ‚≠ê</td>
    </tr>
    <tr>
      <td>Dense</td>
      <td>Efficient use of \(O(n^2)\) space ‚≠ê</td>
      <td>Many edges to search through list for ‚ùå</td>
    </tr>
    <tr>
      <td>Complete directed, with self-loops</td>
      <td>\(O(n^2)\) ‚≠ê</td>
      <td>\(O(n^2)\), and inefficient lookup ‚ùå</td>
    </tr>
  </tbody>
</table>

<h2 class="centeredtable" id="subgraphs">Subgraphs</h2>

<blockquote>
  <p>A <strong>subgraph</strong> of the graph \(G\) fulfils the two properties:</p>

  <ul>
    <li>
      <p>Its vertices are a subset of the vertices of \(G\)</p>
    </li>
    <li>
      <p>Its edges are a subset of the edges of \(G\)</p>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>A <strong>spanning subgraph</strong> contains all of the vertices in \(G\). This then gives rise to <strong>spanning trees</strong>, which are spanning subgraphs which are connected and acyclic.</p>

  <ul>
    <li>A spanning tree is not unique unless the graph is a tree.</li>
  </ul>
</blockquote>

<h2 id="depth-first-search">Depth-first search</h2>

<blockquote>
  <p>Depth-first search is a general technique for traverse graphs. It takes \(O(n + m)\) time to search a graph of \(n\) vertices and \(m\) edges.</p>
</blockquote>

<p>Informally, it can be described as always proceeding to its first adjacency, then backtracking when it reaches a vertex with no adjacencies which it has not explored already</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">):</span>
    <span class="nl">Input:</span> <span class="no">A</span> <span class="n">graph</span> <span class="no">G</span> <span class="n">and</span> <span class="n">a</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">of</span> <span class="no">G</span>
    <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">edges</span> <span class="n">of</span> <span class="no">G</span> <span class="n">in</span> <span class="n">the</span> <span class="n">connected</span> <span class="n">component</span> <span class="n">of</span> <span class="n">v</span> <span class="n">as</span> <span class="n">discovery</span> <span class="n">edges</span> <span class="n">and</span> <span class="n">back</span> <span class="n">edges</span>
        <span class="nf">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
        <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
            <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
                <span class="c1">// Get vertex w, that's opposite vertex v across edge e</span>
                <span class="n">w</span> <span class="o">&lt;-</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
                <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
                    <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"discovery"</span><span class="o">)</span>
                    <span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span> <span class="c1">// Recursive call to DFS on this "unexplored" vertex w</span>
                <span class="k">else</span>
                    <span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"back"</span><span class="o">)</span>
</code></pre></div></div>

<blockquote>
  <p>It has the following properties</p>

  <ul>
    <li>It visits all vertices and edges in any connected component of a graph</li>
    <li>The discovery edges form a spanning tree of any graph it traverses</li>
    <li>The depth-first search tree of a fully connected graph is a straight line of nodes</li>
  </ul>
</blockquote>

<h3 id="uses-cases">Uses Cases</h3>

<p>It can be used for <strong>path-finding</strong> by performing the traversal until the target node is found, then <strong>backtracking</strong> along the <strong>discovery edges</strong> to find the reverse of the path.</p>

<ul>
  <li>This is done by altering the DFS algorithm to push <strong>visited</strong> vertices and <strong>discovery</strong> edges as the algorithm goes through them.</li>
  <li>Once the target vertex is found, we return the path as the contents of the stack</li>
</ul>

<p>It can be used to <strong>identify cycles</strong>, as if it <strong>ever finds</strong> an <strong>adjacency</strong> to a vertex which it has <strong>already explored</strong>, (a <strong>back edge</strong>), the graph must contain a cycle.</p>

<ul>
  <li>A stack is again used for the same purpose.</li>
  <li>When a <strong>back edge</strong> is encountered between a node <strong><em>v</em></strong> and another node <strong><em>w</em></strong>, the cycle is returned as the <strong>portion of the stack</strong> from the top to until node <strong><em>v</em></strong>.is</li>
</ul>

<h2 id="breadth-first-search">Breadth-first search</h2>

<blockquote>
  <p>Breadth-first search is a technique to traverse graphs. It takes \(O(n + m)\) time to search a graph of \(n\) vertices and \(m\) edges.</p>
</blockquote>

<p>Informally, it can be described as exploring every one of its adjacencies, then proceeding to the first adjacency, then backtracking when it reaches a vertex with no adjacencies which it has not explored already</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">BFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
    <span class="nl">Input:</span> <span class="n">graph</span> <span class="no">G</span>
    <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">edges</span> <span class="n">and</span> <span class="n">partition</span> <span class="n">of</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="no">G</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">u</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
        <span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">edges</span><span class="o">()</span>
        <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
        <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span>
            <span class="no">BFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span>
            
<span class="nc">Algorithm</span> <span class="nf">BGS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">s</span><span class="o">)</span>
    <span class="no">L0</span> <span class="o">&lt;-</span> <span class="k">new</span> <span class="n">empty</span> <span class="n">sequence</span>
    <span class="no">L0</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="n">setLabel</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
    <span class="k">while</span> <span class="o">!</span><span class="no">L0</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
        <span class="nc">Lnext</span> <span class="o">&lt;-</span> <span class="k">new</span> <span class="n">empty</span> <span class="n">sequence</span>
        <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">L0</span><span class="o">.</span><span class="na">elements</span><span class="o">()</span>
            <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
                <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
                    <span class="n">w</span> <span class="o">&lt;-</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
                    <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
                        <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"discovery"</span><span class="o">)</span>
                        <span class="n">setLabel</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
                        <span class="nc">Lnext</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
                    <span class="k">else</span>
                        <span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"cross"</span><span class="o">)</span>
        <span class="no">L0</span> <span class="o">&lt;-</span> <span class="nc">Lnext</span> <span class="c1">// Set L0 to Lnext so while loop won't stop</span>
</code></pre></div></div>

<blockquote>
  <p>It has the following properties</p>

  <ul>
    <li>It <strong>visits all</strong> vertices and edges in \(G_s\), the connected component of a graph \(s\)</li>
    <li>The <strong>discovery edges</strong> form a <strong>spanning tree</strong> of any graph it traverses</li>
    <li>The <strong>path</strong> between any two vertices in the spanning tree of <strong>discovery edges</strong> it creates is the <strong>shortest path</strong> between them in the graph</li>
    <li>The bread-first search tree of a fully connected graph is like a star with the centre node being the starting node, and all other nodes being rays, with the only vertices being from the starting node to all other nodes</li>
  </ul>
</blockquote>

<p>It can be used for path-finding by performing the traversal until the target node is found, then backtracking along the discovery edges to find the reverse of the path.</p>

<p>It can be used to identify cycles, as if it ever finds an adjacency to a vertex which it has already explored, (a back edge), the graph must contain a cycle.</p>

<h3 id="applications">Applications</h3>

<p>We can specialise the BFS algorithm to solve the following problems in \(O(n+m)\) time.</p>

<ul>
  <li>Compute the connected components of G</li>
  <li>Compute a spanning forest of G</li>
  <li>Find a simple cycle in G, or report that G is a forest</li>
  <li>Given two vertices of G, find a path in G between them with the minimum number of edges, or report that no such path exists.</li>
</ul>

<h3 id="dfs-and-bfs-visualization">DFS and BFS visualization</h3>

<p>The site linked <a href="https://www.cs.usfca.edu/~galles/visualization/DFS.html">here</a> traces the steps of DFS either or BFS, and one can specify whether each node is connected, as well as whether the graphs are directed or undirected</p>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="directed-graphs">Directed Graphs</h1>
       
            <h2 id="directed-graphs">Directed graphs</h2>

<blockquote>
  <p>Directed graphs (digraphs) are graphs where <strong>every edge</strong> is directed. Edge \((a,b)\) goes from \(a\) to \(b\), but not the other way around.</p>

  <p>It can be applied to dependency and scheduling problems. When representing it in concrete implementations, we tend to keep in and out edges separately</p>
</blockquote>

<h3 id="properties">Properties</h3>

<p>If a <strong>simple</strong> directed graph has \(m\) edges and \(n\) vertices, then \(m \leq n \cdot (n-1)\), since every vertex can connect to every other vertex bar itself</p>

<p>There is more terminology specifically about digraphs:</p>

<ul>
  <li>One vertex is said to be <strong>reachable</strong> from the other if there <strong>exists a directed path</strong> from the other to it</li>
  <li>A digraph is said to be <strong>strongly connected</strong> if <strong>each vertex is reachable</strong> from every other vertex</li>
</ul>

<h3 id="strong-connectivity-algorithm">Strong Connectivity Algorithm</h3>

<p>We can identify strong connectivity by running DFS on a chosen vertex \(v\) in \(G\) and \(G‚Äô\), where \(G‚Äô\) is \(G\) but with the directed edges <strong>reversed</strong>.</p>

<ul>
  <li>Firstly, we perform DFS from \(v\) in \(G\). If there is a vertex \(u\) <strong>not visited</strong>, then \(G\) is <strong>not</strong> strongly connected. Otherwise, it shows that there exists a path from \(v\) to every other vertex.</li>
  <li>Next we perform DFS from \(v\) in \(G‚Äô\). Again, if there is a vertex \(u\) not visited it is not strongly connected. Otherwise, it shows that there exists a path from every other vertex to \(v\).</li>
  <li>If both DFS show that there is no such vertex \(u\), then \(G\) is strongly connected.</li>
</ul>

<p>This has a running time of \(O(n+m)\).</p>

<p>It is also possible to create maximal subgraphs with every vertex being reachable in \(O(n+m)\) time, but this is more involved.</p>

<h2 id="transitive-closure">Transitive closure</h2>

<blockquote>
  <p>Given a digraph \(G\), the transitive closure of \(G\) is the digraph \(G^*\) such that</p>

  <ul>
    <li>
      <p>\(G^*\) has the same vertices as \(G\)</p>
    </li>
    <li>
      <p>If \(G\) has a directed path from \(u\) to \(v\), and \(u \neq v\), then \(G^*\) has a directed edge from \(u\) to \(v\)</p>
    </li>
  </ul>

  <p>The transitive closure provides reachability information about a digraph, allowing us to answer reachability questions <strong>fast</strong>.</p>
</blockquote>

<p>Informally, this means that every pair of vertices with a path between them is adjacent in a transitive closure.</p>

<p><img src=".\images\transitiveClosure.png" alt="transitiveClosure" class="center" style="zoom:50%;" /></p>

<h3 id="computing-with-dfs">Computing with DFS</h3>

<p>One way of computing the transitive closure of a graph is to perform DFS on each vertex in graph to identify every reachable edge from it, then setting edges between them.</p>

<p>Every run of DFS will take \(O(n+m)\) time and because we are running it on every edge so this will take \(O(n \cdot (n+m))\) time.</p>

<blockquote>
  <p>For sparse graphs, adjacency list/adjacency map representations, or very large graphs (many nodes), DFS is a good solution.</p>
</blockquote>

<h3 id="floyd-warshall-algorithm">Floyd-Warshall Algorithm</h3>

<blockquote>
  <p>Another way to compute the transitive closure is to use the <strong>Floyd-Warshall algorithm</strong>, a dynamic programming solution.</p>
</blockquote>

<p>The \(G^*\) graph starts off identical to \(G\) with only the initial edges. We then add a direct edge between nodes which have a path of length 2 between them (only one other node separating the two nodes).</p>

<p><img src=".\images\floydWarshall.png" alt="floydWarshall" class="center" /></p>

<p>With each iteration, we pick a ‚Äúpivot‚Äù (this is my own way of saying it) node \(k\) and we loop through all \(i\) and \(j\) to check if there is an edge \(i\rightarrow k\) and \(k\rightarrow j\) ‚Äì if this is true, then we insert an edge \(i \rightarrow j\).</p>

<p>After every edge is inserted, this forms a new path of length 2 between two nodes, which is then considered in a later iteration.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">FloydWarshall</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
    <span class="nl">Input:</span> <span class="n">digraph</span> <span class="no">G</span>
    <span class="nl">Output:</span> <span class="n">transitive</span> <span class="n">closure</span> <span class="no">G</span><span class="o">*</span> <span class="n">of</span> <span class="no">G</span>
    <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
        <span class="n">label</span> <span class="n">v</span> <span class="n">with</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">G_new</span> <span class="o">&lt;-</span> <span class="no">G</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nf">n</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="k">do</span>
        	<span class="k">for</span> <span class="n">j</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nf">n</span><span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="k">do</span>
            	<span class="k">if</span> <span class="n">G_new</span><span class="o">.</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">G_new</span><span class="o">.</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">)</span> <span class="o">&amp;</span> <span class="o">!</span><span class="n">G_new</span><span class="o">.</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span>
                    <span class="n">G_new</span><span class="o">.</span><span class="na">insertDirectedEdge</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">edge_k</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">G_new</span>
</code></pre></div></div>

<blockquote>
  <p>We say this is a dynamic programming algorithm because we only have to consider paths of length 2 and update the graph immediately. By resolving the transitive closure for every \(k\) with every other \(i\) and every other \(j\), the end result is one that considers all possible closures and the final graph is transitively closed.</p>
</blockquote>

<h4 id="fw-in-python">FW in Python</h4>

<p>I found a good explanation of this algorithm on <a href="https://www.youtube.com/watch?v=OO8Jfs9uZnc">Youtube</a> which also includes a github gist of the Python implementation of this algorithm. This takes an adjacency matrix <code class="language-plaintext highlighter-rouge">M</code> which encodes the graph</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">warshall</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">nrows</span><span class="p">()</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">M</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="ow">and</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">W</span>
</code></pre></div></div>

<h4 id="speed-analysis-of-fw">Speed Analysis of FW</h4>

<p>The running time is dominated by the 3 for-loops. If we assume that the <code class="language-plaintext highlighter-rouge">areAdjacent</code> method takes \(O(1)\) time (which is true for <strong>adjacency matrices</strong>) then this algorithm is of \(O(n^3)\) time.</p>

<blockquote>
  <p>For dense graphs, and adjacency matrix representations, the Floyd-Warshall algorithm is better than using DFS. Additionally, it is also algorithmically simpler.</p>
</blockquote>

<h2 id="topological-ordering">Topological ordering</h2>

<p>A topological ordering of a digraph is a numbering \(v_1,\ldots,v_n\) of the vertices such that for every directed edge \(v_i,v_j\), we have that \(i&lt;j\).</p>

<blockquote>
  <p><strong>Theorem.</strong> A digraph has a <strong>topological ordering</strong> if it is a <strong>directed acyclic graph</strong> (DAG ‚Äì has no directed cycles). Having cycles would informally be self-dependencies</p>
</blockquote>

<p>To prove the theorem above, we need to prove both ways. Showing that a digraph with a topological ordering contains no directed cycles is <strong>trivial</strong> (left to right). We will employ DFS to prove the other way (right to left).</p>

<h3 id="topological-sorting-with-dfs">Topological Sorting with DFS</h3>

<blockquote>
  <p>This DFS implementation of <strong>topological sorting</strong> consists of two functions that are overloaded.</p>

  <ul>
    <li>The first function takes a graph <code class="language-plaintext highlighter-rouge">G</code> and starts labelling all vertices as <code class="language-plaintext highlighter-rouge">unexplored</code>.</li>
    <li>Then for every vertex, if the label is <code class="language-plaintext highlighter-rouge">unexplored</code> we call the <strong>second</strong> function.</li>
  </ul>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span> <span class="c1">// First function</span>
    <span class="nl">Input:</span> <span class="no">DAG</span> <span class="no">G</span>
    <span class="nl">Output:</span> <span class="nc">Topological</span> <span class="n">ordering</span> <span class="n">of</span> <span class="no">G</span>
    <span class="n">n</span> <span class="o">&lt;-</span> <span class="no">G</span><span class="o">.</span><span class="na">numVertices</span><span class="o">()</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">u</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
        <span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
        <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span>
            <span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span>     <span class="c1">// 2nd Function</span>
</code></pre></div></div>

<p>Here we set the starting vertex <code class="language-plaintext highlighter-rouge">v</code> to <code class="language-plaintext highlighter-rouge">visited</code>, and then for all edges that originate from <code class="language-plaintext highlighter-rouge">v</code> we check if the destination vertex <code class="language-plaintext highlighter-rouge">w</code> is <code class="language-plaintext highlighter-rouge">unexplored</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span> <span class="c1">// 2nd Function</span>
    <span class="nl">Input:</span> <span class="n">graph</span> <span class="no">G</span> <span class="n">and</span> <span class="n">a</span> <span class="n">start</span> <span class="n">vertex</span> <span class="n">v</span> <span class="n">of</span> <span class="no">G</span>
    <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="no">G</span> <span class="n">in</span> <span class="n">the</span> <span class="n">connected</span> <span class="n">component</span> <span class="n">of</span> <span class="n">v</span>
    <span class="nf">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">outEdges</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
        <span class="n">w</span> <span class="o">&lt;-</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
        <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span> <span class="c1">// e is a discovery edge</span>
            <span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
            <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"cross"</span><span class="o">)</span>
        <span class="c1">// else we do nothing</span>
    <span class="nc">Label</span> <span class="n">v</span> <span class="n">with</span> <span class="n">topological</span> <span class="n">number</span> <span class="n">n</span>
    <span class="n">n</span> <span class="o">&lt;-</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Taking the following graph as an example, let‚Äôs start at vertex <code class="language-plaintext highlighter-rouge">A</code>. We first begin by labelling vertex <code class="language-plaintext highlighter-rouge">A</code> as <code class="language-plaintext highlighter-rouge">visited</code> and we loop through all the vertices that <code class="language-plaintext highlighter-rouge">A</code> has an edge to.</p>

<p><img src="./images/toposort1.svg" class="center" /></p>

<p>If any are unexplored, then the edge has <strong>not been traversed</strong> before and we call the 2nd function on the destination vertex recursively, in this case lets say the loop starts with <code class="language-plaintext highlighter-rouge">G</code>. Then the same thing happens to <code class="language-plaintext highlighter-rouge">G</code> (as it is a recursive call).</p>

<p>This will continue until we arrive at a vertex <code class="language-plaintext highlighter-rouge">D</code> with <strong>no outgoing unexplored edge</strong>.</p>

<ul>
  <li>When this happens, we label <code class="language-plaintext highlighter-rouge">D</code> with the current number for the topological ordering (this number starts at \(n = \text{number of vertices in G}\)). After which, we decrement <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li>Then as <strong>an effect</strong> of the recursive calls, the algorithm <strong>backtracks</strong> to the previous vertex \(d_x\) (i.e <code class="language-plaintext highlighter-rouge">J</code>).
    <ul>
      <li>All remaining outgoing edges of \(d_x\) are checked and there will be <strong>further recursive calls</strong> to the 2nd function if any edges have <strong>not</strong> been traversed.</li>
      <li>The next vertex with no outgoing edge \(d_{n-1}\) will be labelled with <code class="language-plaintext highlighter-rouge">n-1</code>. In our example this is <code class="language-plaintext highlighter-rouge">J</code>.</li>
    </ul>
  </li>
  <li>This goes on, and we will notice that after every exit from a recursive call, there will always be a vertex with no outgoing unexplored edge.</li>
</ul>

<p>Hence, we will be able to arrive at a topological ordering of \(G\).</p>

<p><img src="./images/toposort2.svg" class="center" /></p>

<blockquote>
  <p><strong>Note.</strong> You may observer that if we start at a different root vertex (for example if we started from <code class="language-plaintext highlighter-rouge">B</code> instead of <code class="language-plaintext highlighter-rouge">A</code>), the topological ordering will be different. Hence, it is possible for one DAG to have multiple topological orderings.</p>
</blockquote>


            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="general-algorithms">General Algorithms</h1>
       
            <h2 id="searching-data-structures">Searching data structures</h2>

<h3 id="linear-search">Linear search</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">search</span>
<span class="nc">Let</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">item</span> <span class="n">to</span> <span class="n">search</span> <span class="k">for</span>
<span class="nc">Let</span> <span class="n">n</span> <span class="o">&lt;-</span> <span class="mi">0</span>

<span class="nc">While</span> <span class="n">n</span> <span class="n">is</span> <span class="n">smaller</span> <span class="n">than</span> <span class="n">the</span> <span class="n">length</span> <span class="n">of</span> <span class="n">arr</span>
	<span class="nc">If</span> <span class="n">k</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
		<span class="nc">Stop</span><span class="o">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">item</span> <span class="n">is</span> <span class="n">found</span>
	<span class="nc">Increment</span> <span class="n">n</span>
<span class="nc">Stop</span><span class="o">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">item</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">the</span> <span class="n">array</span>
</code></pre></div></div>

<h3 id="binary-search">Binary search</h3>

<p>This binary search algorithm is used for searching an array, and will return the index of the item in the array else -1.</p>

<pre><code class="language-{java}">Let arr &lt;- the array to search
Let k &lt;- the item to search for
if !(arr.isSorted())
	arr.mergeSort()
binarySearch(arr, k, int lowerBound, upperBound)
	middle &lt;- (lowerBound + upperBound) / 2
	if upperBound &lt; lowerBound
		return - 1
	if k == arr[middle]
    		return middle
	else if k &lt; arr[middle]
    		return binarySearch(arr, k, lowerBound, middle -1)
    	else 
        	return binarySearch(arr, k, middle + 1, upperBound)
      
</code></pre>

<h4 id="iterative-algorithm">Iterative algorithm</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">search</span>
<span class="nc">Let</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">item</span> <span class="n">to</span> <span class="n">search</span> <span class="k">for</span>
<span class="nc">Let</span> <span class="n">l</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="nc">Let</span> <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arr</span> <span class="o">-</span> <span class="mi">1</span>
<span class="nc">Let</span> <span class="n">m</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="nc">While</span> <span class="n">l</span> <span class="o">!=</span> <span class="n">r</span>
	<span class="nc">If</span> <span class="n">k</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
		<span class="nc">Stop</span><span class="o">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">item</span> <span class="n">is</span> <span class="n">found</span>
	<span class="nc">Else</span> <span class="k">if</span> <span class="n">k</span> <span class="n">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
		<span class="n">r</span> <span class="o">&lt;-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="n">m</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="nc">Else</span> <span class="o">(</span><span class="k">if</span> <span class="n">k</span> <span class="n">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
		<span class="n">l</span> <span class="o">&lt;-</span> <span class="n">m</span>
		<span class="n">m</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="nc">Stop</span><span class="o">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">item</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">the</span> <span class="n">array</span>
</code></pre></div></div>

<h4 id="recursive-algorithm">Recursive algorithm</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">search</span>
<span class="nc">Let</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">item</span> <span class="n">to</span> <span class="n">search</span> <span class="k">for</span>

<span class="nc">Function</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span>
	<span class="nc">Let</span> <span class="n">l</span> <span class="o">&lt;-</span> <span class="mi">0</span>
    <span class="nc">Let</span> <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">arr</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nc">Let</span> <span class="n">m</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nc">If</span> <span class="n">l</span> <span class="o">==</span> <span class="n">m</span>
    	<span class="nc">Stop</span><span class="o">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">item</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">the</span> <span class="n">array</span>
    <span class="nc">Else</span> <span class="k">if</span> <span class="n">k</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
		<span class="nc">Stop</span><span class="o">,</span> <span class="n">since</span> <span class="n">the</span> <span class="n">item</span> <span class="n">is</span> <span class="n">found</span>
	<span class="nc">Else</span> <span class="k">if</span> <span class="n">k</span> <span class="n">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
		<span class="nf">binarySearch</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="nl">l:</span><span class="n">m</span><span class="o">],</span> <span class="n">k</span><span class="o">)</span>
	<span class="nc">Else</span> <span class="o">(</span><span class="k">if</span> <span class="n">k</span> <span class="n">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">arr</span><span class="o">[</span><span class="n">n</span><span class="o">])</span>
		<span class="n">binarySearch</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="nl">m:</span><span class="n">r</span><span class="o">],</span> <span class="n">k</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="sorting-data-structures">Sorting data structures</h2>

<h3 id="insertion-sort">Insertion sort</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">P</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="n">priority</span> <span class="n">queue</span> <span class="n">using</span> <span class="n">an</span> <span class="n">sorted</span> <span class="n">array</span> <span class="n">implementation</span>
<span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">sort</span>
<span class="nc">Let</span> <span class="n">arr</span><span class="err">'</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">sorted</span> <span class="n">array</span>
<span class="nc">For</span> <span class="n">each</span> <span class="n">i</span> <span class="n">in</span> <span class="n">arr</span>
	<span class="nc">Enqueue</span> <span class="n">i</span> <span class="n">to</span> <span class="no">P</span>
<span class="nc">While</span> <span class="no">P</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
	<span class="nc">Let</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="nc">Dequeue</span> <span class="n">from</span> <span class="no">P</span>
	<span class="nc">Append</span> <span class="n">i</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
</code></pre></div></div>

<h3 id="selection-sort">Selection sort</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">P</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="n">priority</span> <span class="n">queue</span> <span class="n">using</span> <span class="n">an</span> <span class="n">unsorted</span> <span class="n">array</span> <span class="n">implementation</span>
<span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">sort</span>
<span class="nc">Let</span> <span class="n">arr</span><span class="err">'</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">sorted</span> <span class="n">array</span>
<span class="nc">For</span> <span class="n">each</span> <span class="n">i</span> <span class="n">in</span> <span class="n">arr</span>
	<span class="nc">Enqueue</span> <span class="n">i</span> <span class="n">to</span> <span class="no">P</span>
<span class="nc">While</span> <span class="no">P</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
	<span class="nc">Let</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="nc">Dequeue</span> <span class="n">from</span> <span class="no">P</span>
	<span class="nc">Append</span> <span class="n">i</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
</code></pre></div></div>

<h3 id="heap-sort">Heap sort</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">P</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="n">priority</span> <span class="n">queue</span> <span class="n">using</span> <span class="n">a</span> <span class="n">heap</span> <span class="n">based</span> <span class="n">implementation</span>
<span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">sort</span>
<span class="nc">Let</span> <span class="n">arr</span><span class="err">'</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">sorted</span> <span class="n">array</span>
<span class="nc">For</span> <span class="n">each</span> <span class="n">i</span> <span class="n">in</span> <span class="n">arr</span>
	<span class="nc">Enqueue</span> <span class="n">i</span> <span class="n">to</span> <span class="no">P</span>
<span class="nc">While</span> <span class="no">P</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
	<span class="nc">Let</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="nc">Dequeue</span> <span class="n">from</span> <span class="no">P</span>
	<span class="nc">Append</span> <span class="n">i</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
</code></pre></div></div>

<h3 id="merge-sort">Merge sort</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="n">arr</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">sort</span>

<span class="nc">Function</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
	<span class="nc">If</span> <span class="n">arr</span> <span class="n">contains</span> <span class="n">only</span> <span class="n">one</span> <span class="n">element</span>
		<span class="nc">Return</span> <span class="n">arr</span>
    <span class="nc">Let</span> <span class="n">lArr</span><span class="o">,</span> <span class="n">rArr</span> <span class="o">&lt;-</span> <span class="n">arr</span> <span class="n">split</span> <span class="n">into</span> <span class="n">two</span> <span class="n">even</span> <span class="n">halves</span>
    <span class="nc">Return</span> <span class="nf">merge</span><span class="o">(</span>
    	<span class="n">mergeSort</span><span class="o">(</span><span class="n">lArr</span><span class="o">),</span>
    	<span class="n">mergeSort</span><span class="o">(</span><span class="n">rArr</span><span class="o">)</span>
    <span class="o">)</span>
    
<span class="nc">Function</span> <span class="nf">merge</span><span class="o">(</span><span class="n">arr1</span><span class="o">,</span> <span class="n">arr2</span><span class="o">)</span>
	<span class="nc">Let</span> <span class="n">arr</span><span class="err">'</span> <span class="o">&lt;-</span> <span class="n">an</span> <span class="n">empty</span> <span class="n">array</span> <span class="n">large</span> <span class="n">enough</span> <span class="n">to</span> <span class="n">fit</span> <span class="n">both</span> <span class="n">arr1</span> <span class="n">and</span> <span class="n">arr2</span> <span class="n">in</span>
	<span class="nc">Let</span> <span class="n">n1</span><span class="o">,</span> <span class="n">n2</span> <span class="o">&lt;-</span> <span class="mi">0</span>
	<span class="nc">While</span> <span class="n">neither</span> <span class="n">arr1</span> <span class="n">nor</span> <span class="n">arr2</span> <span class="n">are</span> <span class="n">empty</span>
		<span class="nc">If</span> <span class="n">arr1</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr2</span><span class="o">[</span><span class="n">n2</span><span class="o">]</span>
			<span class="nc">Append</span> <span class="n">arr1</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span> <span class="n">and</span> <span class="n">arr2</span><span class="o">[</span><span class="n">n2</span><span class="o">]</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
			<span class="nc">Increment</span> <span class="n">n1</span> <span class="n">and</span> <span class="n">n2</span>
		<span class="nc">Else</span> <span class="k">if</span> <span class="n">arr1</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">n2</span><span class="o">]</span>
			<span class="nc">Append</span> <span class="n">arr1</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
			<span class="nc">Increment</span> <span class="n">n1</span>
		<span class="nf">Else</span> <span class="o">(</span><span class="k">if</span> <span class="n">arr1</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">arr2</span><span class="o">[</span><span class="n">n2</span><span class="o">])</span>
			<span class="nc">Append</span> <span class="n">arr2</span><span class="o">[</span><span class="n">n2</span><span class="o">]</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
			<span class="nc">Increment</span> <span class="n">n2</span>
	<span class="nc">For</span> <span class="n">each</span> <span class="n">element</span> <span class="n">in</span> <span class="n">arr1</span> <span class="n">from</span> <span class="n">n1</span> <span class="n">to</span> <span class="n">its</span> <span class="n">last</span> <span class="n">element</span>
		<span class="nc">Append</span> <span class="n">arr1</span><span class="o">[</span><span class="n">n1</span><span class="o">]</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
	<span class="nc">For</span> <span class="n">each</span> <span class="n">element</span> <span class="n">in</span> <span class="n">arr2</span> <span class="n">from</span> <span class="n">n2</span> <span class="n">to</span> <span class="n">its</span> <span class="n">last</span> <span class="n">element</span>
		<span class="nc">Append</span> <span class="n">arr2</span><span class="o">[</span><span class="n">n2</span><span class="o">]</span> <span class="n">to</span> <span class="n">arr</span><span class="err">'</span>
	<span class="nc">Return</span> <span class="n">arr</span><span class="err">'</span>
</code></pre></div></div>

<h2 id="reversing-data-structures">Reversing data structures</h2>
<h3 id="reversing-a-stack">Reversing a stack</h3>

<p>Push all the items in array to the stack, then pop all the items off the stack into the new reversed array</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">S</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">to</span> <span class="n">reverse</span>
<span class="nc">Let</span> <span class="no">S</span><span class="err">'</span> <span class="o">&lt;-</span> <span class="n">an</span> <span class="n">empty</span> <span class="nf">stack</span> <span class="o">(</span><span class="n">the</span> <span class="n">output</span><span class="o">)</span>
<span class="nc">For</span> <span class="n">each</span> <span class="n">item</span> <span class="n">in</span> <span class="no">S</span>
	<span class="nc">Pop</span> <span class="n">the</span> <span class="n">head</span> <span class="n">off</span> <span class="no">S</span> <span class="n">into</span> <span class="n">s</span>
	<span class="nc">Push</span> <span class="n">s</span> <span class="n">to</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="no">S</span><span class="err">'</span>
</code></pre></div></div>

<h3 id="reversing-a-linked-list">Reversing a linked list</h3>

<p>Iterate over the linked list from the head, and for each element in the list to reverse, set the item as the predecessor of the head in the new reversed list</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">L</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">to</span> <span class="n">reverse</span>
<span class="nc">Let</span> <span class="no">L</span><span class="err">'</span> <span class="o">&lt;-</span> <span class="n">an</span> <span class="n">empty</span> <span class="n">linked</span> <span class="nf">list</span> <span class="o">(</span><span class="n">the</span> <span class="n">output</span><span class="o">)</span>
<span class="nc">For</span> <span class="n">each</span> <span class="n">item</span> <span class="n">in</span> <span class="no">S</span>
	<span class="nc">Let</span> <span class="n">l</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">first</span> <span class="n">item</span> <span class="n">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="n">list</span>
	<span class="nc">Delete</span> <span class="n">the</span> <span class="n">first</span> <span class="n">item</span> <span class="n">in</span> <span class="n">the</span> <span class="n">linked</span> <span class="n">list</span>
	<span class="nc">Add</span> <span class="n">l</span> <span class="n">as</span> <span class="n">the</span> <span class="n">head</span> <span class="n">of</span> <span class="no">L</span><span class="err">'</span>
</code></pre></div></div>

<h2 id="set-operations">Set operations</h2>

<h3 id="generic-merging">Generic merging</h3>

<p>Taking the union of two sets, in linear time:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">A</span><span class="o">,</span> <span class="no">B</span> <span class="o">&lt;-</span> <span class="nc">The</span> <span class="n">lists</span> <span class="n">to</span> <span class="n">merge</span>
<span class="nc">Let</span> <span class="no">S</span> <span class="o">&lt;-</span> <span class="n">an</span> <span class="n">empty</span> <span class="nf">list</span> <span class="o">(</span><span class="n">the</span> <span class="n">output</span><span class="o">)</span>
<span class="nc">While</span> <span class="n">neither</span> <span class="no">A</span> <span class="n">nor</span> <span class="no">B</span> <span class="n">are</span> <span class="n">empty</span>
	<span class="nc">Let</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="nc">The</span> <span class="n">first</span> <span class="n">elements</span> <span class="n">of</span> <span class="no">A</span> <span class="n">and</span> <span class="no">B</span> <span class="n">respectively</span>
	<span class="nc">If</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>
		<span class="nc">Add</span> <span class="n">a</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="no">S</span>
		<span class="nc">Remove</span> <span class="n">a</span> <span class="n">from</span> <span class="no">A</span>
	<span class="nc">Else</span> <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span>
		<span class="nc">Add</span> <span class="n">b</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="no">S</span>
		<span class="nc">Remove</span> <span class="n">b</span> <span class="n">from</span> <span class="no">B</span>
	<span class="nf">Else</span> <span class="o">(</span><span class="n">hence</span> <span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="o">)</span>
		<span class="nc">Add</span> <span class="n">a</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="nf">S</span> <span class="o">(</span><span class="n">both</span> <span class="n">are</span> <span class="n">equal</span><span class="o">,</span> <span class="n">so</span> <span class="n">it</span> <span class="n">doesn</span><span class="err">'</span><span class="n">t</span> <span class="n">matter</span> <span class="n">which</span><span class="o">)</span>
		<span class="nc">Remove</span> <span class="n">a</span> <span class="n">and</span> <span class="n">b</span> <span class="n">from</span> <span class="no">A</span> <span class="n">and</span> <span class="no">B</span> <span class="nf">respectively</span>
<span class="o">(</span><span class="nc">Cleaning</span> <span class="n">up</span> <span class="n">the</span> <span class="n">other</span> <span class="n">list</span> <span class="n">when</span> <span class="n">one</span> <span class="n">is</span> <span class="n">empty</span><span class="o">)</span>
<span class="nc">While</span> <span class="no">A</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
	<span class="nc">Add</span> <span class="n">all</span> <span class="n">the</span> <span class="n">items</span> <span class="n">left</span> <span class="n">in</span> <span class="no">A</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="no">S</span>
<span class="nc">While</span> <span class="no">B</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span>
	<span class="nc">Add</span> <span class="n">all</span> <span class="n">the</span> <span class="n">items</span> <span class="n">left</span> <span class="n">in</span> <span class="no">B</span> <span class="n">to</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="no">S</span>
</code></pre></div></div>

<h2 id="graph-algorithms">Graph algorithms</h2>

<h3 id="depth-first-search">Depth-first search</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>  	
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
            		<span class="k">else</span> 
               			<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">BACK</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="dfs-for-an-entire-graph">DFS for an entire graph:</h4>

<p>The following algorithm is pseudocode for Depth First Search - as displayed by the CS126 lectures, which is used to perform depth first search on the entire graph.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// For the entire graph</span>
<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">u</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">())</span>
        	<span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span>
        	<span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">u</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">())</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
            		<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
            
<span class="c1">// For each vertex individually      </span>
<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>  	
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="no">DFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">)</span>
            		<span class="k">else</span> 
               			<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">BACK</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="path-finding-with-dfs">Path Finding with DFS</h4>

<p>By using an alteration of the depth first search algorithm, we can use it to find a path between two given vertices, using the <strong>template method pattern</strong>
where <strong>S</strong> is an initially empty stack</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pathDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
    	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
   	<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    	<span class="k">if</span> <span class="n">v</span> <span class="o">=</span> <span class="n">z</span>
        	<span class="k">return</span> <span class="no">S</span><span class="o">.</span><span class="na">elements</span><span class="o">()</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLbel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
            		<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
                		<span class="n">pathDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">w</span><span class="o">,</span><span class="n">z</span><span class="o">)</span>
                		<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
           		<span class="k">else</span> 
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">BACK</span><span class="o">)</span>
		<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="cycle-finding-with-dfs">Cycle Finding with DFS</h4>

<p>The algorithm for DFS can be adapted slightly in order to find a simply cycle back to the start node.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cycleDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
   	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
    	<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
            		<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
            		<span class="no">S</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
            		<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
                		<span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">DISCOVERY</span><span class="o">)</span>
                		<span class="n">cycleDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
               			<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
           		 <span class="k">else</span> 
               			<span class="no">T</span> <span class="o">=</span> <span class="k">new</span> <span class="n">empty</span> <span class="nc">Stack</span>
                		<span class="n">repeat</span>
                			<span class="n">o</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">pop</span>
                			<span class="no">T</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
                		<span class="n">until</span> <span class="n">o</span> <span class="o">=</span> <span class="n">w</span>
                		<span class="k">return</span> <span class="no">T</span><span class="o">.</span><span class="na">elements</span><span class="o">()</span>
	<span class="no">S</span><span class="o">.</span><span class="na">pop</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="topological-ordering-using-dfs">Topological ordering using DFS</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
    	<span class="n">z</span> <span class="o">=</span> <span class="no">G</span><span class="o">.</span><span class="na">getVertices</span><span class="o">()</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">u</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">)</span>
        	<span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="no">UNEXPLORED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Vertex</span> <span class="n">v</span> <span class="o">:</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">)</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>
            		<span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>


<span class="n">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
	<span class="n">setLabel</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="no">VISITED</span><span class="o">)</span>
    	<span class="k">for</span> <span class="nf">each</span> <span class="o">(</span><span class="nc">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">outgoingEdges</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
        	<span class="n">w</span> <span class="o">=</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
        	<span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="no">UNEXPLORED</span>	
            		<span class="nf">topologicalDFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
        	<span class="k">else</span>
            		<span class="nc">Label</span> <span class="n">v</span> <span class="n">with</span> <span class="n">topological</span> <span class="n">number</span> <span class="n">n</span>
        	<span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="breadth-first-search">Breadth-first search</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">BFS</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
  <span class="nl">Input:</span> <span class="n">graph</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="nc">Labelling</span> <span class="n">of</span> <span class="n">edges</span> <span class="n">and</span> <span class="n">partition</span> <span class="n">of</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="no">G</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">u</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="n">setLabel</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">edges</span><span class="o">()</span>
    <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"unexplored"</span><span class="o">)</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="s">"unexplored"</span>
      <span class="no">BFS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">v</span><span class="o">)</span>
      
<span class="nc">Algorithm</span> <span class="nf">BGS</span><span class="o">(</span><span class="no">G</span><span class="o">,</span><span class="n">s</span><span class="o">)</span>
  <span class="no">L0</span> <span class="o">&lt;-</span> <span class="k">new</span> <span class="n">empty</span> <span class="n">sequence</span>
  <span class="no">L0</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
  <span class="n">setLabel</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
  <span class="k">while</span> <span class="o">!</span><span class="no">L0</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span>
    <span class="nc">Lnext</span> <span class="o">&lt;-</span> <span class="k">new</span> <span class="n">empty</span> <span class="n">sequence</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">L0</span><span class="o">.</span><span class="na">elements</span><span class="o">()</span>
      <span class="k">for</span> <span class="n">all</span> <span class="n">e</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">incidentEdges</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
        <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
          <span class="n">w</span> <span class="o">&lt;-</span> <span class="n">opposite</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="o">)</span>
          <span class="k">if</span> <span class="nf">getLabel</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">=</span> <span class="s">"unexplored"</span>
            <span class="n">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"discovery"</span><span class="o">)</span>
            <span class="n">setLabel</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="s">"visited"</span><span class="o">)</span>
            <span class="nc">Lnext</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>
          <span class="k">else</span>
            <span class="nf">setLabel</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="s">"cross"</span><span class="o">)</span>
    <span class="no">L0</span> <span class="o">&lt;-</span> <span class="nc">Lnext</span> <span class="c1">// Set L0 to Lnext so while loop won't stop</span>
</code></pre></div></div>

<h3 id="directed-graphs">Directed graphs</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">FloydWarshall</span><span class="o">(</span><span class="no">G</span><span class="o">)</span>
  <span class="nl">Input:</span> <span class="n">digraph</span> <span class="no">G</span>
  <span class="nl">Output:</span> <span class="n">transitive</span> <span class="n">closure</span> <span class="no">G</span><span class="o">*</span> <span class="n">of</span> <span class="no">G</span>
  <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="no">G</span><span class="o">.</span><span class="na">vertices</span><span class="o">()</span>
    <span class="n">denote</span> <span class="n">v</span> <span class="n">as</span> <span class="n">vi</span>
    <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="no">G_0</span> <span class="o">&lt;-</span> <span class="no">G</span>
  <span class="k">for</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="n">G_k</span> <span class="o">&lt;-</span> <span class="no">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nf">n</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="k">do</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="nf">n</span><span class="o">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">k</span><span class="o">)</span> <span class="k">do</span>
        <span class="k">if</span> <span class="nf">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">vi</span><span class="o">,</span><span class="n">vk</span><span class="o">)</span> <span class="o">&amp;</span> <span class="no">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">vk</span><span class="o">,</span><span class="n">vj</span><span class="o">)</span>
          <span class="k">if</span> <span class="o">!</span><span class="no">G_</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="na">areAdjacent</span><span class="o">(</span><span class="n">vi</span><span class="o">,</span><span class="n">vj</span><span class="o">)</span>
            <span class="n">G_k</span><span class="o">.</span><span class="na">insertDirectedEdge</span><span class="o">(</span><span class="n">vi</span><span class="o">,</span><span class="n">vj</span><span class="o">,</span><span class="n">k</span><span class="o">)</span>
  <span class="k">return</span> <span class="n">G_n</span>
</code></pre></div></div>

<h2 id="miscellaneous">Miscellaneous</h2>

<h3 id="computing-spans">Computing spans</h3>

<p>The span of an array is the maximum number of consecutive elements less than a value at an index which precede it
This can be calculated in linear time by</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Let</span> <span class="no">X</span> <span class="o">&lt;-</span> <span class="n">the</span> <span class="n">array</span> <span class="n">to</span> <span class="n">find</span> <span class="n">spans</span> <span class="n">of</span>
<span class="nc">Let</span> <span class="no">S</span> <span class="o">&lt;-</span> <span class="n">a</span> <span class="n">stack</span> <span class="n">of</span> <span class="n">all</span> <span class="n">the</span> <span class="n">indices</span> <span class="n">in</span> <span class="no">X</span>
<span class="nc">Let</span> <span class="n">i</span> <span class="n">be</span> <span class="n">the</span> <span class="n">current</span> <span class="n">index</span>
<span class="nc">Pop</span> <span class="n">indices</span> <span class="n">from</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">until</span> <span class="n">we</span> <span class="n">find</span> <span class="n">index</span> <span class="n">j</span> <span class="n">such</span> <span class="n">that</span> <span class="no">X</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="no">X</span><span class="o">[</span><span class="n">j</span><span class="o">]</span>
<span class="nc">Set</span> <span class="no">S</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;-</span> <span class="n">i</span><span class="o">-</span><span class="n">j</span>
<span class="nc">Push</span> <span class="n">i</span> <span class="n">to</span> <span class="n">the</span> <span class="n">stack</span>
</code></pre></div></div>

<h3 id="fibonacci">Fibonacci</h3>
<p>The Fibonacci numbers can be calculated in various ways, each of which have varying efficiency, from very inefficient in exponential time, to efficient in linear time</p>

<h3 id="exponential-time">Exponential time</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>
	<span class="nc">If</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="nc">Return</span> <span class="mi">0</span>
	<span class="nc">Else</span> <span class="k">if</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="nc">Return</span> <span class="n">k</span>
	<span class="nc">Else</span>
		<span class="nc">Return</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>

<p>This is very inefficient, running in \(O(2^n)\) time, since it re-calculates calls to <code class="language-plaintext highlighter-rouge">fibonacci(k)</code> for some <code class="language-plaintext highlighter-rouge">k</code> many times, instead of using the same result every time it is needed</p>

<h4 id="linear-time">Linear time</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Returns the tuple (f_k, f_k-1)</span>
<span class="nc">Function</span> <span class="nf">fibonacci</span><span class="o">(</span><span class="n">k</span><span class="o">)</span>
	<span class="nc">If</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="nc">Return</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
	<span class="nc">Else</span>
		<span class="nc">Let</span> <span class="n">i</span><span class="o">,</span><span class="n">j</span> <span class="o">&lt;-</span> <span class="n">fibonacci</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
		<span class="nc">Return</span> <span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>
</code></pre></div></div>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/>


                <footer class="site-footer">

                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>
</html>