<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>
    
    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link id="mainCS" rel="stylesheet" href="/assets/css/style.css">
    <title>notes CS118 Crib Sheet</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            
            
            <h1 class="project-name">CS118 Crib Sheet</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#number-systems">Number systems</a><ul><li><a href="#twos-complement">Two‚Äôs complement</a></li><li><a href="#ieee-754-floating-point">IEEE-754 floating point</a></li></ul></li><li><a href="#data-types">Data types</a><ul><li><a href="#primitive-data-types">Primitive data types</a></li><li><a href="#passing-by-reference-and-by-value">Passing by reference and by value</a></li><li><a href="#casting">Casting</a></li></ul></li><li><a href="#operator-evaluation-and-precedence">Operator evaluation and precedence</a></li><li><a href="#conditionals">Conditionals</a><ul><li><a href="#the-switch-statement">The switch statement</a></li></ul></li><li><a href="#object-oriented-programming">Object oriented programming</a><ul><li><a href="#pillars-of-object-oriented-programming">Pillars of object oriented programming</a></li><li><a href="#access-modifiers">Access modifiers</a></li><li><a href="#the-static-and-final-keywords">The static and final keywords</a></li></ul></li><li><a href="#abstract-classes-interfaces">Abstract classes, interfaces</a><ul><li><a href="#abstract-classes">Abstract classes</a></li><li><a href="#interfaces">Interfaces</a></li></ul></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#generics">Generics</a></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="../">üè°Module Home</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <h1 id="number-systems">Number systems</h1>

<h2 id="twos-complement">Two‚Äôs complement</h2>

<ul>
  <li>In order to store negative integer numbers, we don‚Äôt just add a ‚Äúsign bit‚Äù as we would normally, as then we define both positive and negative values for zero, which wastes space, and can be confusing. Instead, we use ‚Äútwo‚Äôs complement‚Äù
    <ul>
      <li>Binary representation, but the left-most bit is negative
<img src=".\media\twosComplement.png" alt="twosComplement" /></li>
      <li>With eight bits, the smallest value is \(10000000_2 = -128_{10}\), and the largest value is \(01111111_2 = 127_{10}\) (this is \(-2^n\) to \(2^n - 1\))</li>
    </ul>
  </li>
</ul>

<h2 id="ieee-754-floating-point">IEEE-754 floating point</h2>

<ul>
  <li>In order to store decimal numbers, we use ‚Äúfloating point notation‚Äù, which automatically handles the trade-off between precision and range for storing numbers in a fixed number of bits. This is defined in the IEEE-754 specification (<a href="https://webstore.iec.ch/preview/info_isoiecfdis60559%7Bed2.0%7Den.pdf">source</a>), and explained further <a href="https://steve.hollasch.net/cgindex/coding/ieeefloat.html">here</a></li>
  <li>A tool for checking this is <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">available</a></li>
  <li>For single precision <code class="language-plaintext highlighter-rouge">floats</code> (<code class="language-plaintext highlighter-rouge">double</code>s use different sized exponents and mantissas, but operate in the same way) the schema for the number is:
<img src=".\media\IEEE754main.png" alt="IEEE754main" />
    <ul>
      <li>The ‚Äúsign bit‚Äù denotes whether the number is positive or negative</li>
      <li>The ‚Äúexponent‚Äù needs to represent both positive and negative numbers, but it <strong>does not</strong> use two‚Äôs complement, it instead uses a bias of \(127\), meaning you subtract \(-127\) from the decimal value to get the exponent. Additionally, \(-127_{10} = 00000000_2\) and \(128+{10} = 11111111_2\) are reserved special cases. Double precision uses an 11-bit field instead of an 8-bit one, and hence has an offset of \(1023\)</li>
      <li>The ‚Äúfraction/mantissa‚Äù represents the precision bits of the number, with the most significant bit being \(\frac{1}{2^1}\), then \(\frac{1}{2^2}\), and so on. This is taken as the value after the binary point, and in almost all cases, the value before the binary point is one, however, if the exponent is all \(0\)s, it is \(0\) and said to be denormalised. Double precision uses a 52-bit field instead of a 23-bit one.
As a rule of thumb, calculate the value of the fraction from binary with the reciprocal values, the add one to it</li>
      <li>The fraction represents the value of the number, and is of fixed precision, for example, 23 bits of information. The exponent then specifies the range of the number.</li>
      <li>Special values
        <ul>
          <li>Denormalised, when the exponent is all \(0\)s, so the number is assumed to have a leading \(0\) not a leading \(1\) before the binary point, i.e. \(0.[fraction]\) not \(1.[fraction]\)</li>
          <li>Zero, when both the exponent and fraction are all \(0\)s, so it resolves to \(0.0\) . Due to the sign bit, there are both positive and negative zeroes, but they compare as equal</li>
          <li>Infinity, positive and negative infinities are when the exponent is all \(1\)s, but the fraction is all \(0\)s, and the sign bit indicates sign. Since they are actual values in the scheme, we can do operations on them</li>
          <li>NaN (not a number), when the exponent is all \(1\)s, and there is a non-zero fraction. These can be used for signalling errors etc.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>An example of this in practice is:
<img src=".\media\IEEE754example.png" alt="IEEE754example" />
Note that the ‚Äú1.(fraction)‚Äù denotes a decimal point, not a multiplication operation</li>
</ul>

<h1 id="data-types">Data types</h1>

<h2 id="primitive-data-types">Primitive data types</h2>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Range</th>
      <th>Size</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">boolean</code></td>
      <td><code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code></td>
      <td>1 bit</td>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">byte</code></td>
      <td>\(-128\) to \(127\)</td>
      <td>1 byte</td>
      <td><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">short</code></td>
      <td>\(-32768\) to \(+32767\)</td>
      <td>2 bytes</td>
      <td><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">char</code></td>
      <td>\(0\) to \(65,535\)</td>
      <td>2 bytes</td>
      <td><code class="language-plaintext highlighter-rouge">\u0000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">int</code></td>
      <td>\(-2,147,483,648\) to \(+2,147,483,647\)</td>
      <td>4 bytes</td>
      <td><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>\(-2^{63}\) to \(2^{63}-1\)</td>
      <td>8 bytes</td>
      <td><code class="language-plaintext highlighter-rouge">0L</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">float</code></td>
      <td>\(-3.4 \times 10^{38}\) and \(3.4 \times 10^{38}\) with 6 to 7 significant digits of accuracy</td>
      <td>4 bytes</td>
      <td><code class="language-plaintext highlighter-rouge">0.0f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">double</code></td>
      <td>\(-1.7 \times 10^{308}\) and \(1.7 \times 10^{308}\) with 14 to 15 significant digits of accuracy</td>
      <td>8 bytes</td>
      <td><code class="language-plaintext highlighter-rouge">0.0d</code></td>
    </tr>
  </tbody>
</table>

<p>The <code class="language-plaintext highlighter-rouge">char</code> primitive is essentially an unsigned <code class="language-plaintext highlighter-rouge">short</code> primitive, which is used to store UTF-16 encoded single characters instead of a number</p>

<h2 id="passing-by-reference-and-by-value">Passing by reference and by value</h2>

<ul>
  <li>Primitive data types are stored as a value in a place in memory, for example, and <code class="language-plaintext highlighter-rouge">int</code> would be four consecutive bytes, whose value can be looked up by a variable name</li>
  <li>However, since objects are not necessarily of a fixed size, we cannot just allocate an amount of memory for them. Instead, we store a ‚Äúreference‚Äù to them on the heap, and the variable name refers to this reference, not the actual data
    <ul>
      <li>Because of this, we cannot use the <code class="language-plaintext highlighter-rouge">==</code> operator to compare object contents, as it merely compares their memory references, only telling you if it is the exact same instance, not if it has the same stuff in</li>
    </ul>
  </li>
  <li>All parameters passed to and returned by methods are ‚Äúpassed-by-value‚Äù, i.e. the data in the physical memory space is duplicated in the scope of the method, and won‚Äôt affect the contents of the variable which it was passed from. However, we know that objects are only stored as references to the data on the heap, so the value passed is only the reference to the data, so it any operations will act on the same object, so it becomes ‚Äúpass-by-reference‚Äù, as it is passing the value of the reference to the object
    <ul>
      <li>In practice, in Java primitives are ‚Äúpass-by-value‚Äù (so changing them in the method won‚Äôt change them outside it), and objects are ‚Äúpass-by-reference‚Äù (so any changes to them in a new method will affect their state outside of it)</li>
    </ul>
  </li>
  <li>Autoboxing is an action performed automatically by the compiler, which ‚Äúboxes‚Äù a primitive into its corresponding object (e.g. <code class="language-plaintext highlighter-rouge">int</code> to <code class="language-plaintext highlighter-rouge">Integer</code>) if a method requires an object, not just a primitive value.</li>
</ul>

<h2 id="casting">Casting</h2>

<ul>
  <li>
    <p>Casting is the process of changing the data type used to express a piece of information, for example to change the range or the precision used to store a numeric value</p>
  </li>
  <li>
    <p>There are three different sets of keywords used to describe casting, which are:</p>

    <ul>
      <li>
        <p>Explicit and implicit</p>

        <ul>
          <li>Explicit casting is when the casting is indicated directly in the source code. In Java, this is denoted by wrapping the new type in brackets, for example <code class="language-plaintext highlighter-rouge">castValue = (newType) value</code></li>
          <li>Implicit casting is when the casting can be inferred by the compiler, and so does not need to be indicated directly in the source code (however, it can be indicated with explicit casting as well for easier readability)</li>
        </ul>
      </li>
      <li>
        <p>Safe/widening and unsafe/narrowing casting</p>

        <ul>
          <li>
            <p>Safe (also called widening) casting is when the value is moved to a data type which supports more precision or a greater range of values. <strong>No data is lost in this operation</strong>. This can be done simply by setting a more precisely/larger typed variable equal to the value of a less precisely/smaller typed one, using implicit casting</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">narrowValue</span> <span class="o">=</span> <span class="mf">3.141f</span><span class="o">;</span>
<span class="kt">double</span> <span class="n">widenedValue</span> <span class="o">=</span> <span class="n">narrrowValue</span><span class="o">;</span>
</code></pre></div>            </div>

            <p>Explicit casting can also be used, although it is not necessary, for additional readability</p>
          </li>
          <li>
            <p>Unsafe (also called narrowing) casting is when the value is moved to a data type which supports less precision or a smaller range of values. <strong>Data can (possibly but not necessarily) be lost in this operation</strong>. This must be indicated with an explicit cast, with brackets indicating the new type, as the compiler cannot infer that the type should change</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">float</span> <span class="n">wideValue</span> <span class="o">=</span> <span class="mf">3.141f</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">narrowedValue</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">wideValue</span><span class="o">;</span>
</code></pre></div>            </div>

            <p>Explicit casting is required for unsafe casting, but unsafe casting is not required for explicit casting</p>
          </li>
        </ul>
      </li>
      <li>
        <p>Checked and unchecked casting</p>

        <ul>
          <li>
            <p>Checked casting is when the cast operation is ‚Äúwell-defined‚Äù, i.e. the output type is able to represent the information stored in the input type. For example, numeric types can be safely cast between each other, since they all encode numbers</p>
          </li>
          <li>
            <p>Unchecked casting is when the cast operation is may not be ‚Äúwell-defined‚Äù, i.e. the output type may not be able to represent all the information stored in the input type, or the input type may not provide enough information to ‚Äúfill‚Äù the output type. For example, casting from an <code class="language-plaintext highlighter-rouge">ArithmeticException</code> to an <code class="language-plaintext highlighter-rouge">Integer</code> would be an unsafe cast, as one cannot fully represent the other.</p>

            <p>Unsafe/unchecked casting will result in an error being thrown by the compiler, unless the <code class="language-plaintext highlighter-rouge">@SuppressWarnings("unchecked")</code> method annotation is used, which allows the code to be compiled, but this may still fail at runtime</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="operator-evaluation-and-precedence">Operator evaluation and precedence</h1>

<ul>
  <li>Lazy and strict operators
    <ul>
      <li>Lazy operators aren‚Äôt executed if an earlier operations fully defines the statement, e.g. in an ‚Äúor‚Äù operation, if the first statement is true, the second statement needn‚Äôt be tested</li>
      <li>Strict operators execute everything, even if it isn‚Äôt ‚Äúneeded‚Äù to ascertain the logical value of the statement, as state might be mutated in later parts, e.g. <code class="language-plaintext highlighter-rouge">y &amp; (x++ == 4)</code> would change the value of <code class="language-plaintext highlighter-rouge">x</code></li>
    </ul>
  </li>
  <li>
    <p>Pre-increment and post-increment</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">++i</code> increments the variable before it is used in an expression (incremented then returned), whereas <code class="language-plaintext highlighter-rouge">i++</code> increments it after it has been used (returned then incremented). This can affect the output of some expressions</li>
    </ul>
  </li>
  <li>
    <p>Operator precedence (<a href="http://pages.cs.wisc.edu/~willb/cs302/java-operator-precedence.pdf">additional source</a>)</p>

    <table>
      <thead>
        <tr>
          <th>Letter</th>
          <th>Name</th>
          <th>Operations</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>P</td>
          <td>Postfix</td>
          <td><code class="language-plaintext highlighter-rouge">expr++</code>, <code class="language-plaintext highlighter-rouge">expr--</code></td>
        </tr>
        <tr>
          <td>U</td>
          <td>Unary/Prefix</td>
          <td><code class="language-plaintext highlighter-rouge">++expr</code>, <code class="language-plaintext highlighter-rouge">--expr</code></td>
        </tr>
        <tr>
          <td>M</td>
          <td>Multiplicative</td>
          <td><code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">&amp;</code></td>
        </tr>
        <tr>
          <td>A</td>
          <td>Additive</td>
          <td><code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code></td>
        </tr>
        <tr>
          <td>S</td>
          <td>Shift</td>
          <td><code class="language-plaintext highlighter-rouge">&gt;&gt;</code>,<code class="language-plaintext highlighter-rouge">&lt;&lt;</code></td>
        </tr>
        <tr>
          <td>R</td>
          <td>Relational</td>
          <td><code class="language-plaintext highlighter-rouge">&gt;</code>,<code class="language-plaintext highlighter-rouge">&lt;</code>,<code class="language-plaintext highlighter-rouge">&lt;=</code>,<code class="language-plaintext highlighter-rouge">&gt;=</code></td>
        </tr>
        <tr>
          <td>E</td>
          <td>Equality</td>
          <td><code class="language-plaintext highlighter-rouge">==</code>,<code class="language-plaintext highlighter-rouge">!=</code></td>
        </tr>
        <tr>
          <td>S</td>
          <td>Strict operators</td>
          <td><code class="language-plaintext highlighter-rouge">&amp;</code>,<code class="language-plaintext highlighter-rouge">|</code>,<code class="language-plaintext highlighter-rouge">^</code></td>
        </tr>
        <tr>
          <td>L</td>
          <td>Lazy operators</td>
          <td><code class="language-plaintext highlighter-rouge">&amp;&amp;</code>,<code class="language-plaintext highlighter-rouge">||</code></td>
        </tr>
        <tr>
          <td>A</td>
          <td>Assignment</td>
          <td><code class="language-plaintext highlighter-rouge">=</code>,<code class="language-plaintext highlighter-rouge">+=</code>,<code class="language-plaintext highlighter-rouge">-=</code>,<code class="language-plaintext highlighter-rouge">*=</code>,‚Ä¶</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h1 id="conditionals">Conditionals</h1>

<h2 id="the-switch-statement">The switch statement</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Switch</code> statements offer a way to select control flow based off the value of a variable as opposed to a boolean condition. In some cases, this can be more simple, and hence preferred over <code class="language-plaintext highlighter-rouge">if</code> statements</p>
  </li>
  <li>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="o">(</span><span class="n">variable</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">value_1:</span>
            <span class="c1">//If the variable is equal to value_1, execute the code, then exit the statement due to the break statement</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">value_2:</span>
            <span class="c1">//If the variable is not equal to value_1, and is equal to value_2 then execute the code, and continue executing each block until the next break statement occurs, or the statement ends</span>
        <span class="k">case</span> <span class="nl">value_3:</span>
            <span class="c1">//If the variable is not equal to value_1, and is equal to either value_2 (since it is running through with no break statement) or value_3, then execute the code, then exit the statement due to the break statement</span>
        	<span class="k">break</span><span class="o">;</span>
        <span class="k">default</span><span class="o">:</span>
        	<span class="c1">//If no cases have been satisfied, or the code runs through due to no break statements, execute the code</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Both the <code class="language-plaintext highlighter-rouge">break</code> and <code class="language-plaintext highlighter-rouge">default</code> sections are optional</p>
  </li>
  <li>
    <p>Objects should not be switched on, only primitives, as the equality will compare their memory reference with the <code class="language-plaintext highlighter-rouge">==</code> operator, rather than calling the <code class="language-plaintext highlighter-rouge">.equals()</code> function.</p>
  </li>
  <li>
    <p>We can reason carefully about what happens in conditionals by writing out the preconditions (similar idea to the explanation above, but easier to do it in boolean expressions to be terse)</p>
  </li>
  <li>Switch statements are faster than <code class="language-plaintext highlighter-rouge">if..else if.. else</code> statements when there are a large number of cases, as lookup tables can be used, which are fast</li>
</ul>

<h1 id="object-oriented-programming">Object oriented programming</h1>

<h2 id="pillars-of-object-oriented-programming">Pillars of object oriented programming</h2>

<p>There is some argument over the number of ‚Äúpillars‚Äù, but the four commonly accepted ones are:</p>

<ul>
  <li>Abstraction
    <ul>
      <li>
        <p>‚ÄúExposing essential features, whilst hiding irrelevant detail‚Äù</p>
      </li>
      <li>
        <p>Used so that the purpose/interface of a function can be separated from its implementation, making code re-usable, more understandable, and easier to modify (won‚Äôt break things, changes need to be made in fewer places)</p>
      </li>
    </ul>
  </li>
  <li>Encapsulation
    <ul>
      <li>‚ÄúBundling data and operations that can be performed on that data together - leads to data hiding‚Äù
        <ul>
          <li>Encapsulation is not data hiding, but it does lead to it</li>
          <li>Making state variables <code class="language-plaintext highlighter-rouge">private</code> and the methods that act on them <code class="language-plaintext highlighter-rouge">public</code> is called data hiding</li>
        </ul>
      </li>
      <li>
        <p>‚ÄúWrapping data and the code acting on it together as a single unit‚Äù, so users must use the external interface, rather than just changing things internally.</p>
      </li>
      <li>
        <p>‚ÄúThe action of enclosing something in or as if in a capsule‚Äù, so that an object controls its own internal state, and should only be able to be changed through its interface. This is often implemented through/results in data hiding, which is removing access to variables within a class by making the <code class="language-plaintext highlighter-rouge">private</code>, and then providing getters and setters, rather than direct access to the data. This means that some internal variables can not be externally changed if no method is provided, and operations such as validation can be performed, instead of just directly changing the data</p>
      </li>
      <li>This has the beneficial property of the internal implementation being hidden, so it can be changed and improved without changing the external interface, so other code doesn‚Äôt break. Additionally, it hides the unnecessary detail of the implementation, and clarifies responsibility for the code</li>
    </ul>
  </li>
  <li>Inheritance
    <ul>
      <li>‚ÄúCreating new classes from existing ones, reducing programmer effort‚Äù</li>
      <li>‚ÄúAllowing an object to acquire the properties and methods of another object‚Äù, so that code can be re-used, along with helping abstractions and hierarchy.
        <ul>
          <li>A subclass inherits all the properties from its superclass, and may have some additional ones of its own, and/or override some of the parents, however, it must not remove methods from the parent class (known as Liskov substitution principle)</li>
        </ul>
      </li>
      <li>The <code class="language-plaintext highlighter-rouge">super</code> keyword is used to refer to methods and properties of the superclass</li>
      <li>Method overriding is when a subclass changes the definition of a function defined by its superclass. It is somewhat like overloading with different numbers of parameters for methods. If a method defined in the superclass is re-defined for the subclass, it will override it. This means that instances of the superclass will run the superclass definition, but those of the subclass will run the subclass definition, without the parent class being modified, and the subclass still retaining all other parent properties without having to redefine them
        <ul>
          <li>Class constructors are not inherited from their superclasses. To keep the functionality of their parent class, they can call the parent class constructor using <code class="language-plaintext highlighter-rouge">super()</code>, and then add any additional functionality later in the constructor. This method call must always be the first thing in the subclass constructor if it is used.</li>
        </ul>
      </li>
      <li>A subclass can only inherit from one superclass, to avoid name-collisions if two superclasses implemented the same method signature differently</li>
    </ul>
  </li>
  <li>
    <p>Polymorphism (English definition ‚Äúthe condition of occurring in several different forms‚Äù)</p>

    <ul>
      <li>Using objects that can take many forms - allows us to invoke operations from derived classes while using a base class reference at run-time</li>
      <li>‚ÄúPolymorphism describes its ability to process objects of different types through a single uniform interface‚Äù</li>
      <li>Static polymorphism (<a href="https://pediaa.com/what-is-the-difference-between-static-and-dynamic-polymorphism-in-java/">source</a>)
        <ul>
          <li>Occurs at compile time</li>
          <li>An example is method overloading
            <ul>
              <li>Different behaviour is exhibited by the same method (in a given class) dependent on its interface, e.g. having different input types</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Dynamic polymorphism (<a href="https://pediaa.com/what-is-the-difference-between-static-and-dynamic-polymorphism-in-java/">source</a>)
        <ul>
          <li>Occurs at runtime</li>
          <li>An example is method overriding
            <ul>
              <li>Methods in subclasses having different behaviour to the equivalent method in their superclass</li>
              <li>Allows us to cast objects which are stored in their superclass to their subclass, so we can use their subclass interfaces</li>
              <li>‚ÄúRelating to the class hierarchy within a program‚Äù</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="access-modifiers">Access modifiers</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">public</code> - can be accessed everywhere in the program</li>
  <li><code class="language-plaintext highlighter-rouge">private</code> - can only be accessed from within its own class (including different instances of the same class)</li>
  <li><code class="language-plaintext highlighter-rouge">protected</code> - can only be accessed from within its own class, or any subclasses (like <code class="language-plaintext highlighter-rouge">private</code>, but including subclasses)</li>
  <li>Default, <code class="language-plaintext highlighter-rouge">package-private</code> - can only be accessed from within the same package</li>
</ul>

<h2 id="the-static-and-final-keywords">The static and final keywords</h2>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">static</code> keyword denotes something that ‚Äúbelongs to the class not the object‚Äù, i.e. something which is not dependent on an individual object instances state
    <ul>
      <li>Static properties are shared across all instances of the class</li>
      <li>Static methods are called from the class name, not the object name</li>
      <li>Static blocks are only executed once, the first time the class is loaded in memory</li>
    </ul>
  </li>
  <li>The <code class="language-plaintext highlighter-rouge">final</code> keyword denotes a variable which defines a constant whose value cannot be changed after it has been set</li>
</ul>

<h1 id="abstract-classes-interfaces">Abstract classes, interfaces</h1>

<h2 id="abstract-classes">Abstract classes</h2>

<ul>
  <li>
    <p>When superclasses become so generic they contain methods which are only well-defined for their subclasses, they are called ‚Äúabstract‚Äù.</p>
  </li>
  <li>
    <p>Abstract classes cannot be instantiated, but it can be inherited from, acting as a pattern for subclasses</p>
  </li>
  <li>
    <p>Abstract classes can still have a constructor and this can be referred to using <code class="language-plaintext highlighter-rouge">super()</code>. This is particularly useful for when all subclasses share a name or ID</p>
  </li>
  <li>
    <p>They can contain a mix of abstract and concrete methods</p>

    <ul>
      <li>Abstract methods provide the method signature, but not the implementation. All abstract methods must be implemented by any subclasses.</li>
      <li>Concrete/non-abstract methods are ones which will be the same for all subclasses, so they are fully defined, and will just be inherited as usual into the subclasses</li>
    </ul>
  </li>
  <li>
    <p>Typically, abstract classes are used to ‚Äúprovide partial implementation‚Äù</p>
  </li>
  <li>
    <p>Example:</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GraphicObject</span> <span class="o">{</span>
    <span class="c1">//Member variables</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>
      
    <span class="c1">//Optional constructor, default no arg constructor is inferred otherwise.</span>
      
    <span class="c1">//A concrete method</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">newX</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newY</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">newX</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">newY</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="c1">//Abstract method</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">();</span>
<span class="o">}</span>
  
<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="nc">GraphicObject</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">radius</span><span class="o">;</span>
      
    <span class="c1">//Constructor</span>
    <span class="kd">public</span> <span class="nf">Circle</span><span class="o">(</span><span class="kt">int</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="c1">//moveTo already implemented through inheritance</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Implementation must be provided</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Circle"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Additional links:</p>
    <ul>
      <li>https://www.tutorialspoint.com/java/java_abstraction.htm</li>
      <li>https://www.journaldev.com/1582/abstract-class-in-java</li>
      <li>https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</li>
    </ul>
  </li>
</ul>

<h2 id="interfaces">Interfaces</h2>

<ul>
  <li>
    <p>If an abstract class contains <em>only</em> abstract methods, and no concrete implementations of methods, it is called an ‚Äúinterface‚Äù</p>

    <ul>
      <li>Hence, interfaces have similar properties to abstract classes, including not being able to be instantiated, so having no constructor</li>
    </ul>
  </li>
  <li>
    <p>Whilst only one class can be inherited, multiple interfaces can be ‚Äúimplemented‚Äù. This is to avoid the issue of two superclasses providing different implementations for the same method. The <code class="language-plaintext highlighter-rouge">implements</code> keyword is used instead of the <code class="language-plaintext highlighter-rouge">extends</code> one to indicate inheritance/implementation</p>
  </li>
  <li>
    <p>Concrete classes implement interfaces, but interfaces can still extend other interfaces to inherit from them</p>
  </li>
  <li>
    <p>Typically, interfaces are used to ‚Äúencapsulate a small subset of functionality‚Äù</p>
  </li>
  <li>
    <p>Example</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="c1">//No constructor</span>
      
    <span class="c1">//Only providing method signatures without implementations</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFoo</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">undoFoo</span><span class="o">();</span>
<span class="o">}</span>
  
<span class="kd">class</span> <span class="nc">Bar</span> <span class="kd">implements</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
      
    <span class="c1">//Provide implementations for all of the interface methods</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFoo</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span><span class="o">++;</span>
    <span class="o">}</span>
      
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">undoFoo</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">x</span><span class="o">--;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Additional links:</p>
    <ul>
      <li>https://www.w3schools.com/java/java_interface.asp</li>
      <li>https://docs.oracle.com/javase/tutorial/java/concepts/interface.html</li>
    </ul>
  </li>
</ul>

<h1 id="exceptions">Exceptions</h1>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">try..catch..finally</code> statement
    <ul>
      <li>The code in the <code class="language-plaintext highlighter-rouge">try</code> block is executed. If an exception is generated, the appropriate <code class="language-plaintext highlighter-rouge">catch</code> block is executed</li>
      <li>Multiple <code class="language-plaintext highlighter-rouge">catch</code> blocks can be used, but they act like a <code class="language-plaintext highlighter-rouge">switch</code> statement, moving downwards, selecting the first to match, so if a subclass lies below a superclass, it will never be executed</li>
      <li>The <code class="language-plaintext highlighter-rouge">finally</code> block is run irrespective of whether the <code class="language-plaintext highlighter-rouge">catch</code> was executed, even if there is a <code class="language-plaintext highlighter-rouge">return</code> within one of the blocks</li>
    </ul>
  </li>
  <li>The <code class="language-plaintext highlighter-rouge">throws</code> keyword can be added to a method declaration to indicate that it might ‚Äúthrow‚Äù a checked exception of a given type</li>
  <li>The <code class="language-plaintext highlighter-rouge">throw</code> keyword is used to throw a new exception from a method, and must be followed by an object that is an instance of the Throwable class (e.g. <code class="language-plaintext highlighter-rouge">throw new ArithmeticError</code>)</li>
  <li>The ‚ÄúExceptions hierarchy‚Äù (image credit <a href="https://www.geeksforgeeks.org/exceptions-in-java/">GeeksForGeeks</a>)
<img src=".\media\exceptionsDiagram.png" alt="exceptionsDiagram" />
    <ul>
      <li>In Java all errors and exceptions are subclasses of the <code class="language-plaintext highlighter-rouge">Throwable</code> class
        <ul>
          <li>Errors are ‚Äúserious problem that a reasonable application should not try to catch‚Äù. These are rare, so we will largely ignore them</li>
          <li>Exceptions are ‚Äúconditions that a reasonable application might want to catch‚Äù</li>
        </ul>
      </li>
      <li>There are two types of exceptions
        <ul>
          <li>Checked exceptions, which must be caught or re-thrown for the code to compile</li>
          <li>Unchecked exceptions are subclasses of either <code class="language-plaintext highlighter-rouge">Error</code> or <code class="language-plaintext highlighter-rouge">RuntimeException</code>. They do not need to be specifically thrown, and while they can be caught, they don‚Äôt need to be for compilation</li>
        </ul>
      </li>
      <li>Custom exceptions can be written
        <ul>
          <li>The exception should inherit from the most specific exception class that encapsulates it
            <ul>
              <li>Must be a subclass of <code class="language-plaintext highlighter-rouge">Throwable</code></li>
              <li>Any subclass of <code class="language-plaintext highlighter-rouge">Exception</code> will be checked, and any subclass of <code class="language-plaintext highlighter-rouge">RunTimeException</code> will be unchecked</li>
            </ul>
          </li>
          <li>Normally, they are just defined as inheriting from the superclass exception, then overriding the polymorphic constructors to provide appropriate error messages etc. All methods such as <code class="language-plaintext highlighter-rouge">printStackTrace</code> are then inherited from the superclass.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="generics">Generics</h1>

<ul>
  <li>Generics allow code to enforce strong type checking at compile time, which helps avoid errors such as invalid casting at runtime. Additionally, they minimise the number of type casts needed, as they automatically return data of the specified type, and they allow writing generic algorithms to be tailored to different types</li>
  <li>Primitives cannot be provided as generics, as they are not objects. Instead, we need to use their object wrapper (e.g. <code class="language-plaintext highlighter-rouge">int</code> becomes <code class="language-plaintext highlighter-rouge">Integer</code>). Then, if an integer is passed in as a parameter, it will be ‚Äúautoboxed‚Äù into its object wrapper to be handled internally.</li>
  <li>During the process of converting Java code to bytecode, the type information about objects is checked for errors, but ultimately discarded in the bytecode. For generics, the type checking before discarding the types is performed by substituting all of the instances of type variables with the type they are specified with in the instance in the code, so it can be type-checked, raising errors at compile time, not runtime.</li>
</ul>



                <footer class="site-footer">

                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>
</html>