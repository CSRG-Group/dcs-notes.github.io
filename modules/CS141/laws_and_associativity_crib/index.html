<!DOCTYPE html>
<html lang="en-US">
  <head>

    
    <meta charset="UTF-8"><!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style" type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link id="mainCS" rel="stylesheet" href="/assets/css/style.css">
    <title>Computer Science Revision Guides</title>
  </head>
  <body>
    <header class="page-header" role="banner">
      
      
      <h1 class="project-name">Crib Sheet</h1>
      <h2 class="project-tagline">A collection of revision notes summarising modules taught on the Computer Science course at the University of Warwick</h2>
      
      <a href="https://github.com/CSRG-Group/dcs-notes.github.io" class="btn">View on GitHub</a>
      
      
    </header>

    <main id="content" class="main-content" role="main">
      <!-- Layout for Module Homepages -->

<a href="../">üìöHome</a>

<h2 id="functor-laws">Functor Laws</h2>

<p>A type <code class="language-plaintext highlighter-rouge">f</code> is a functor if there is a function</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the following laws hold for it:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">fmap</span> <span class="n">id</span> <span class="o">=</span> <span class="n">id</span>
 <span class="n">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span><span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span>
</code></pre></div></div>

<blockquote>
  <p>These laws imply that a data structure‚Äôs ‚Äúshape‚Äù does not change when we use <code class="language-plaintext highlighter-rouge">fmap</code> - we are just operating/changing the elements inside the data structure.</p>
</blockquote>

<h2 id="applicative-laws">Applicative Laws</h2>

<p>In Haskell, a type <code class="language-plaintext highlighter-rouge">f</code> is an applicative functor if there are functions <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
	<span class="n">pure</span>  <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
	<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the following laws apply for them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             <span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
         <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
              <span class="n">m</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">m</span>
<span class="n">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="monad-laws">Monad Laws</h2>

<p>In Haskell, a type <code class="language-plaintext highlighter-rouge">m</code> is a monad if there are functions <code class="language-plaintext highlighter-rouge">return</code> and <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  <span class="n">return</span> <span class="o">::</span>   <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></div></div>

<p>and the following laws apply for them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Left Identity</span>
<span class="n">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
<span class="c1">-- Right Identity</span>
<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">=</span> <span class="n">m</span>
<span class="c1">-- Associativity</span>
<span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="associativity">Associativity</h2>

<blockquote>
  <p><strong>Function</strong> associativity binds the strongest.</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Haskell</th>
      <th style="text-align: center">Maths</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">f x * g y</code></td>
      <td style="text-align: center"><em>f(x) √ó¬†g(y)</em></td>
    </tr>
  </tbody>
</table>

<blockquote class="centeredtable">
  <p>Function <strong>expressions</strong> associates to the right.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xor</span> <span class="o">=</span> <span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">||</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">not</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- is the same as </span>
<span class="n">xor</span> <span class="o">=</span> <span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">||</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">not</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">))</span>
</code></pre></div></div>

<blockquote>
  <p>Function <strong>application</strong> associates to the left.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xor</span> <span class="kt">True</span> <span class="kt">True</span>
<span class="c1">-- is the same as</span>
<span class="p">(</span><span class="n">xor</span> <span class="kt">True</span><span class="p">)</span> <span class="kt">True</span>
</code></pre></div></div>

<blockquote>
  <p>Function <strong>types</strong> associates to the right.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xor</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="c1">-- is the same as </span>
<span class="n">xor</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="making-instances-of-functors-and-foldables">Making instances of functors and foldables</h2>

<h3 id="functors">Functors</h3>

<p>To define an instance of a functor, we only need to define the <code class="language-plaintext highlighter-rouge">fmap</code> function</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">DataType</span> <span class="kr">where</span>
	<span class="c1">-- fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span>
</code></pre></div></div>

<p>The standard implementation of this for lists is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span>
	<span class="o">|</span> <span class="kt">Nil</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">List</span> <span class="kr">where</span>
	<span class="c1">-- fmap f []     = []</span>
	<span class="c1">-- fmap f (x:xs) = f x : map f xs</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nil</span>         <span class="o">=</span> <span class="kt">Nil</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>

<p>The standard implementation of this for various trees is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">BinTree</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span>
	<span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">RoseTree</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span>
	<span class="o">|</span> <span class="kt">Node</span> <span class="p">[</span><span class="kt">RoseTree</span> <span class="n">a</span><span class="p">]</span>
	
<span class="kr">data</span> <span class="kt">InlineRoseTree</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">[</span><span class="kt">InlineRoseTree</span> <span class="n">a</span><span class="p">]</span>
	
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">BinTree</span> <span class="kr">where</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span>   <span class="o">=</span> <span class="kt">Leaf</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">x</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">r</span><span class="p">)</span> 
	
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">RoseTree</span> <span class="kr">where</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span>  <span class="o">=</span> <span class="kt">Leaf</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span><span class="p">)</span> <span class="n">ts</span><span class="p">)</span>
	
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">InlineRoseTree</span> <span class="kr">where</span>
	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span><span class="p">)</span> <span class="n">ts</span><span class="p">)</span>
	
</code></pre></div></div>

<h3 id="foldables">Foldables</h3>

<p>To define an instance of a foldable, we only need to define one of the many types of folds (as all the others can be inferred from one implementation). It is common to pick <code class="language-plaintext highlighter-rouge">foldr</code> for simplicity and consistency.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">DataType</span> <span class="kr">where</span>
	<span class="c1">-- foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span>
</code></pre></div></div>

<p>The standard implementation of this for lists is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span>
	<span class="o">|</span> <span class="kt">Nil</span>

<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">List</span> <span class="kr">where</span>
	<span class="c1">-- foldr _ v []     = v</span>
	<span class="c1">-- foldr f v (x:xs) = f x (foldr f v xs)</span>
	<span class="n">foldr</span> <span class="kr">_</span> <span class="n">v</span> <span class="kt">Nil</span>         <span class="o">=</span> <span class="kt">Nil</span>
	<span class="n">foldr</span> <span class="n">f</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">f</span> <span class="n">v</span> <span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>

<p>The standard implementation of this for various trees is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">BinTree</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span>
	<span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">RoseTree</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span>
	<span class="o">|</span> <span class="kt">Node</span> <span class="p">[</span><span class="kt">RoseTree</span> <span class="n">a</span><span class="p">]</span>
	
<span class="kr">data</span> <span class="kt">InlineRoseTree</span> <span class="n">a</span>
	<span class="o">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">[</span><span class="kt">InlineRoseTree</span> <span class="n">a</span><span class="p">]</span>
	
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">BinTree</span> <span class="kr">where</span>
	<span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">z</span>
	<span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">x</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">foldr</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="n">r</span><span class="p">))</span> <span class="n">l</span>
	<span class="c1">-- Or, considering it as a specialised case of a rose tree</span>
	<span class="c1">-- foldr f z (Node l r) = foldr (\x z‚Äô -&gt; foldr f z‚Äô x) z [l, x, r]</span>
	
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">RoseTree</span> <span class="kr">where</span>
	<span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span>  <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">z</span>
	<span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">ns</span><span class="p">)</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">z</span><span class="err">‚Äô</span> <span class="o">-&gt;</span> <span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span><span class="err">‚Äô</span> <span class="n">x</span><span class="p">)</span> <span class="n">z</span> <span class="n">ns</span>
	
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">InlineRoseTree</span> <span class="kr">where</span>
	<span class="n">foldr</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">foldr</span> <span class="n">f</span> <span class="n">r</span> <span class="n">t</span><span class="p">)</span> <span class="n">z</span> <span class="n">ts</span><span class="p">)</span>
</code></pre></div></div>




      <footer class="site-footer">
        
        <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
      
      </footer>
    </main>
  </body>
</html>