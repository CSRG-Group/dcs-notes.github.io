<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>
    
    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link id="mainCS" rel="stylesheet" href="/assets/css/style.css">
    <title>notes Functors, Applicatives, Monads</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            
            
            <h1 class="project-name">Functors, Applicatives, Monads</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#functor-factory">Functor Factory</a><ul><li><a href="#functor-laws">Functor Laws</a></li></ul></li><li><a href="#applicative-academy">Applicative Academy</a><ul><li><a href="#applicative-laws">Applicative Laws</a></li><li><a href="#left-and-right-apply">Left and Right Apply</a></li><li><a href="#limitations-of-applicatives">Limitations of Applicatives</a></li></ul></li><li><a href="#writer-type">Writer Type</a></li><li><a href="#state-type">State Type</a></li><li><a href="#monad-merry-go-round">Monad Merry-Go-Round</a><ul><li><a href="#monad-laws">Monad Laws</a></li><li><a href="#additional-resources">Additional resources</a></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav">












    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <a href="equationalReasoning.html" title="equationalReasoning.html">üëàPrev</a><a href="./" title="Primary Notes Home">üè°Primary Notes</a><a href="type-level-programming.html" title="type-level-programming.html">Nextüëâ</a>



</div>
                <!-- Main Content of markdown or sub-layouts-->
                <h2 id="functor-factory">Functor Factory</h2>

<blockquote>
  <p>A type is a <strong>functor</strong> if it can represent a ‚Äúcontext‚Äù for values of some arbitrary type that we <strong>can apply functions</strong> to.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</code></pre></div></div>

<p><strong>Pro Tip.</strong> When writing down the instance of a type class like <code class="language-plaintext highlighter-rouge">functor</code> here, always write down the <strong>specialised type signatures</strong> of the function we‚Äôre defining first</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span>
<span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>  <span class="o">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span> 
  <span class="c1">-- fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span>   <span class="o">=</span> <span class="kt">Leaf</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="functor-laws">Functor Laws</h3>

<p>A type <code class="language-plaintext highlighter-rouge">f</code> is a functor if there is a function</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the following laws apply for it:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="n">id</span> <span class="o">=</span> <span class="n">id</span>
<span class="n">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span><span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span>
</code></pre></div></div>

<blockquote>
  <p>These laws imply that a data structure‚Äôs ‚Äúshape‚Äù does not change when we use <code class="language-plaintext highlighter-rouge">fmap</code> - we are just operating/changing the elements inside the data structure.</p>
</blockquote>

<h2 id="applicative-academy">Applicative Academy</h2>

<blockquote>
  <p>A type is an <strong>applicative</strong> functor if its values represent some form of context that we <strong>can lift function application</strong> into.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
  
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
  <span class="c1">-- pure :: a -&gt; Maybe a</span>
  <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">x</span>
  <span class="c1">-- (&lt;*&gt;) :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span>
  <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="kr">_</span>        <span class="o">&lt;*&gt;</span> <span class="kr">_</span>        <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>Suppose that f is a function with two parameters e.g.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
<span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
<span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<h3 id="applicative-laws">Applicative Laws</h3>

<p>In Haskell, a type <code class="language-plaintext highlighter-rouge">f</code> is an applicative functor if there are functions <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
	<span class="n">pure</span>  <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
	<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the following laws apply for them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             <span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
         <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
              <span class="n">m</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">m</span>
<span class="n">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="left-and-right-apply">Left and Right Apply</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">x</span> <span class="o">&lt;*</span> <span class="n">y</span> <span class="o">=</span> <span class="n">const</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">x</span> <span class="o">*&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">flip</span> <span class="n">const</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<h3 id="limitations-of-applicatives">Limitations of Applicatives</h3>

<p>Applicative effects cannot depend on the result of the previous computation, which is why we have <strong>monads</strong>.</p>

<p>Consider the example of looking up the grandmother of a person from a dictionary which maps people to their mothers. This dictionary can be represented as a value of type <code class="language-plaintext highlighter-rouge">[(String, String)]</code> and we can then use the <code class="language-plaintext highlighter-rouge">lookup :: Eq a =&gt; a -&gt; [(a,b)] -&gt; Maybe b</code> function from the standard library to retrieve the name of the mother of a given person:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">grandmother</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="n">grandmother</span> <span class="n">x</span> <span class="n">dict</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">mother</span> <span class="o">&lt;-</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">dict</span>
  <span class="n">lookup</span> <span class="n">mother</span> <span class="n">dict</span>
</code></pre></div></div>

<p>If there is no mapping for a person‚Äôs name to their mother, then <code class="language-plaintext highlighter-rouge">Nothing</code> is returned. Therefore, to look up a person‚Äôs grandmother, we first need to look up their mother‚Äôs name and then the name of their mother‚Äôs mother.</p>

<h2 id="writer-type">Writer Type</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MkWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<p>The writer type is a good example of a <strong>functor</strong> that is <strong>not</strong> an <strong>applicative functor</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">w</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">MkWriter</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">o</span><span class="p">))</span> <span class="o">=</span> <span class="kt">MkWriter</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</code></pre></div></div>

<p>It cannot be an applicative functor because we need to be able to write an instance for <code class="language-plaintext highlighter-rouge">pure</code>. Looking at the typing for <code class="language-plaintext highlighter-rouge">pure</code>, we can see that we need to use the <code class="language-plaintext highlighter-rouge">MkWriter</code> constructor, which expects a pair of type <code class="language-plaintext highlighter-rouge">(a,w)</code> as argument. While we have a value of type <code class="language-plaintext highlighter-rouge">a</code> that can be given to <code class="language-plaintext highlighter-rouge">pure</code> as argument, we do not have a value for <code class="language-plaintext highlighter-rouge">w</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span>
</code></pre></div></div>

<p>Hence, since it is not possible to write a suitable definition, the <code class="language-plaintext highlighter-rouge">Writer</code> type is not an <strong>applicative functor</strong>. Even if we find some way to write a definition, it will not obey the relevant applicative laws.</p>

<h2 id="state-type">State Type</h2>

<p><code class="language-plaintext highlighter-rouge">State</code> has two parameters and therefore is a of kind <code class="language-plaintext highlighter-rouge">* -&gt; * -&gt; *</code>. From type signature of <code class="language-plaintext highlighter-rouge">St</code>, we can see that we are storing functions that produces pairs.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">St</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
<span class="kt">St</span> <span class="o">::</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span>

<span class="n">runState</span> <span class="o">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="n">runState</span> <span class="p">(</span><span class="kt">St</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">m</span>
</code></pre></div></div>

<p>A value of type <code class="language-plaintext highlighter-rouge">State s a</code> represents a <strong>computation</strong> that accepts and initial state of type <code class="language-plaintext highlighter-rouge">s</code> and uses it to produce a result of type <code class="language-plaintext highlighter-rouge">a</code> and a resulting state of type <code class="language-plaintext highlighter-rouge">s</code>.</p>

<blockquote>
  <p>The main idea behind this is that by combining values of type <code class="language-plaintext highlighter-rouge">State</code> in some way, we could automatically propagate state throughout a program in a way that appears <strong>as if</strong> the state was mutable.</p>
</blockquote>

<h2 id="monad-merry-go-round">Monad Merry-Go-Round</h2>

<blockquote>
  <p>A type is a <strong>monad</strong> if its value represent some form of context that permits us to apply a function to all the elements in one context, producing one new context each which <strong>can then</strong> all <strong>be joined</strong> together into one final context.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span> 
  <span class="c1">-- (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; m b) -&gt; m b</span>
  <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
  <span class="kt">Nothing</span>  <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>You can also characterise a monad with the <code class="language-plaintext highlighter-rouge">join</code> function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">join</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span> <span class="o">&gt;&gt;=</span> <span class="n">id</span>

<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">join</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<p>In theory, either function characterises a monad and can be used to define the other function. Haskell‚Äôs <code class="language-plaintext highlighter-rouge">Monad</code> type class requires us to define <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>, while <code class="language-plaintext highlighter-rouge">join</code> is defined in terms of <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code></p>

<h3 id="monad-laws">Monad Laws</h3>

<p>In Haskell, a type <code class="language-plaintext highlighter-rouge">m</code> is a monad if there are functions <code class="language-plaintext highlighter-rouge">return</code> and <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  <span class="n">return</span> <span class="o">::</span>   <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></div></div>

<p>and the following laws apply for them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Left Identity</span>
<span class="n">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
<span class="c1">-- Right Identity</span>
<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">=</span> <span class="n">m</span>
<span class="c1">-- Associativity</span>
<span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="additional-resources">Additional resources</h3>

<p>The following chapters in <em>Learn You a Haskell for Great Good! A Beginner‚Äôs Guide, Lipovaca, Miran</em> cover functors, applicative functors and monads in gratuitous detail:</p>

<ul>
  <li><a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass">The functor typeclass</a></li>
  <li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">Functors, applicative functors, and monoids</a></li>
  <li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A fistful of monads</a></li>
  <li><a href="http://learnyouahaskell.com/for-a-few-monads-more">For a few monads more</a></li>
</ul>

<p>However, a simpler more intuitive description of them (which does skim over some points), is available here:</p>

<ul>
  <li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, applicatives and monads in pictures</a></li>
</ul>



                <footer class="site-footer">

                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>
</html>