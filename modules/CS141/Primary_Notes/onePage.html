<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>
    
    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link id="mainCS" rel="stylesheet" href="/assets/css/style.css">
    <title>onePage 141 One Page Notes</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            
            
            <h1 class="project-name">141 One Page Notes</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#general-functional-programming">General Functional Programming</a><ul><li><a href="#imperative-vs-functional">Imperative vs Functional</a></li><li><a href="#the-compiler">The Compiler</a></li><li><a href="#expressions-and-definitions">Expressions and definitions</a></li><li><a href="#anonymous-functions">Anonymous functions</a></li><li><a href="#syntactic-sugar-for-functions">Syntactic sugar for functions</a></li><li><a href="#currying">Currying</a><ul><li><a href="#uncurry">Uncurry</a></li></ul></li><li><a href="#conditionals">Conditionals</a></li><li><a href="#lists">Lists</a></li><li><a href="#ranges">Ranges</a></li><li><a href="#list-comprehensions">List comprehensions</a></li><li><a href="#type-classes">Type Classes</a><ul><li><a href="#type-class-definitions">Type Class Definitions</a></li><li><a href="#type-instance">Type Instance</a><ul><li><a href="#constraints-on-instances">Constraints on instances</a></li></ul></li><li><a href="#superclass-constraints">Superclass Constraints</a></li></ul></li><li><a href="#polymorphism">Polymorphism</a><ul><li><a href="#parametric-polymorphism">Parametric polymorphism</a></li><li><a href="#ad-hoc-polymorphism">Ad-hoc polymorphism</a></li><li><a href="#subtype-polymorphism">Subtype polymorphism</a></li></ul></li><li><a href="#associativity">Associativity</a></li></ul></li><li><a href="#lazy-evaluation--recursion">Lazy Evaluation &amp; Recursion</a><ul><li><a href="#evaluation-strategies">Evaluation Strategies</a><ul><li><a href="#strictness">Strictness</a></li><li><a href="#call-by-value">Call-by-value</a></li><li><a href="#call-by-name">Call-by-name</a></li><li><a href="#cbn-vs-cbv">CBN vs CBV</a></li><li><a href="#lazy-evaluation">Lazy evaluation</a><ul><li><a href="#sharing">Sharing</a></li><li><a href="#lazy-evaluation-walk-through">Lazy evaluation Walk-through</a></li></ul></li></ul></li><li><a href="#closures">Closures</a><ul><li><a href="#dynamic-closures">Dynamic Closures</a></li></ul></li><li><a href="#recursive-functions">Recursive Functions</a><ul><li><a href="#optimised-recursive-functions-in-haskell">Optimised Recursive Functions in Haskell</a></li><li><a href="#useful-recursive-functions">Useful recursive functions</a><ul><li><a href="#quick-sort">Quick sort</a></li></ul></li></ul></li></ul></li><li><a href="#higher-order-functions">Higher order functions</a><ul><li><a href="#sections">Sections</a></li><li><a href="#examples-of-higher-order-functions">Examples of higher order functions</a><ul><li><a href="#map">Map</a></li><li><a href="#filter">Filter</a><ul><li><a href="#quicksort-using-filter">Quicksort using filter</a></li></ul></li><li><a href="#folds">Folds</a><ul><li><a href="#foldr">Foldr</a></li><li><a href="#foldl">Foldl</a></li><li><a href="#foldl-1">Foldl‚Äô</a></li></ul></li><li><a href="#function-composition">Function composition</a></li></ul></li></ul></li><li><a href="#data-types">Data Types</a><ul><li><a href="#data-type-definition">Data Type Definition</a><ul><li><a href="#parametrised-data-constructors">Parametrised Data Constructors</a></li></ul></li><li><a href="#recursive-data-types">Recursive Data Types</a></li><li><a href="#type-aliases">Type Aliases</a></li><li><a href="#derivable-type-classes">Derivable Type Classes</a></li></ul></li><li><a href="#equational-reasoning-in-haskell">Equational Reasoning in Haskell</a><ul><li><a href="#intro">Intro</a></li><li><a href="#techniques">Techniques</a><ul><li><a href="#direct-proof">Direct proof</a><ul><li><a href="#function-application-and-unapplication">Function application and unapplication</a><ul><li><a href="#non-overlapping-pattern-matching">Non-overlapping pattern matching</a></li><li><a href="#case-analysis">Case analysis</a></li></ul></li><li><a href="#applying-an-assumption">Applying an assumption</a></li><li><a href="#eta-conversion">Eta-conversion</a></li></ul></li><li><a href="#induction">Induction</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#direct-proof-1">Direct proof</a><ul><li><a href="#reversing-a-singleton-list">Reversing a singleton list</a></li></ul></li><li><a href="#proof-by-induction">Proof by induction</a><ul><li><a href="#addition-on-recursively-defined-numbers">Addition on recursively defined numbers</a><ul><li><a href="#adding-zero-results-in-no-change">Adding zero results in no change</a></li><li><a href="#associativity-of-natural-numbers">Associativity of natural numbers</a></li></ul></li><li><a href="#induction-on-lists">Induction on lists</a><ul><li><a href="#proving-map-fusion">Proving map fusion</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#functors-applicatives-monads">Functors, Applicatives, Monads</a><ul><li><a href="#functor-factory">Functor Factory</a><ul><li><a href="#functor-laws">Functor Laws</a></li></ul></li><li><a href="#applicative-academy">Applicative Academy</a><ul><li><a href="#applicative-laws">Applicative Laws</a></li><li><a href="#left-and-right-apply">Left and Right Apply</a></li><li><a href="#limitations-of-applicatives">Limitations of Applicatives</a></li></ul></li><li><a href="#writer-type">Writer Type</a></li><li><a href="#state-type">State Type</a></li><li><a href="#monad-merry-go-round">Monad Merry-Go-Round</a><ul><li><a href="#monad-laws">Monad Laws</a></li><li><a href="#additional-resources">Additional resources</a></li></ul></li></ul></li><li><a href="#type-level-programming">Type Level Programming</a><ul><li><a href="#kinds">Kinds</a><ul><li><a href="#kinds--better-code">Kinds = Better Code</a></li><li><a href="#finding-the-kind">Finding the kind</a></li></ul></li><li><a href="#type-promotion">Type promotion</a></li><li><a href="#gadts">GADTs</a><ul><li><a href="#singleton-types">Singleton Types</a></li></ul></li><li><a href="#reification">Reification</a><ul><li><a href="#proxy-types">Proxy Types</a></li><li><a href="#additional-example-type-application">Additional Example (Type Application)</a></li><li><a href="#concluding-reification">Concluding Reification</a></li></ul></li><li><a href="#type-families">Type Families</a><ul><li><a href="#closed-type-families">Closed Type Families</a><ul><li><a href="#how-to-test-in-repl">How to test in REPL</a></li></ul></li><li><a href="#associated-open-type-families">Associated (Open) Type Families</a><ul><li><a href="#associated-type-families-to-the-rescue">Associated type families to the rescue</a></li></ul></li><li><a href="#overloaded-lists">Overloaded Lists</a></li></ul></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="../">üè°Module Home</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Layout for One Page Notes -->
<!-- 
    Works for all modules as long as they 
    - Are defined in the relevant module data file
-->





<!-- not the best and a little O-horrible  but the easiest way to do it --><h1 id="general-functional-programming">General Functional Programming</h1>
       
            <h2 id="imperative-vs-functional">Imperative vs Functional</h2>

<table>
  <thead>
    <tr>
      <th>Imperative</th>
      <th>Functional</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Mutation of state</td>
      <td>Reduction of expressions</td>
    </tr>
    <tr>
      <td>Tell the computer how you want to do something</td>
      <td>Tell the computer what you want to compute and let it work out how to do it</td>
    </tr>
    <tr>
      <td>Statements executed in order specified</td>
      <td>Sub-expressions can often be evaluated in an arbitrary order</td>
    </tr>
    <tr>
      <td>Loops</td>
      <td>Recursion</td>
    </tr>
  </tbody>
</table>

<h2 id="the-compiler">The Compiler</h2>

<blockquote>
  <p>Haskell is a statically typed functional programming language. This means that types are known at compile-time instead of run-time.</p>
</blockquote>

<p>This allows the GHC compiler to help us write better programs. When our code is compiling</p>

<ul>
  <li>It first goes through a parser that converts ASCII source code into data in memory.</li>
  <li>Then the GHC checks types and infers missing ones.</li>
  <li>Types are then <strong>erased</strong> after the type checking phase, and the compiler will generate binaries for the CPU to be able to run the program. (Types are not available at runtime ‚Äì this is <strong>type erasure</strong>)</li>
</ul>

<h2 id="expressions-and-definitions">Expressions and definitions</h2>

<p>Haskell evaluates programs by ‚Äúreducing‚Äù expressions to a ‚Äúnormal‚Äù (simplest) form in a lazy manner. This is when a complicated statement has the rules defined by the language and the rest of the program applied to it to reduce its complexity, as it is a declarative language, for example <code class="language-plaintext highlighter-rouge">2+2</code> would be reduced to <code class="language-plaintext highlighter-rouge">4</code> by applying the definition of the <code class="language-plaintext highlighter-rouge">+</code> function.</p>

<p>Definitions are when expressions are assigned to named variables, so they can be referenced elsewhere without having to be defined again inline</p>

<h2 id="anonymous-functions">Anonymous functions</h2>

<p>The <code class="language-plaintext highlighter-rouge">\</code> is used to resemble the Lambda character from Lambda calculus, and it denotes a function without a name, which is just a transformation on an argument. For example, a function to multiply a parameter by two can be written as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre></div></div>

<p>All functions in Haskell are actually just anonymous functions, which are assigned to variables, as functions are treated as first class objects, but for simplicity and neatness, we needn‚Äôt define them this way in code, we can instead use syntactic sugar</p>

<h2 id="syntactic-sugar-for-functions">Syntactic sugar for functions</h2>

<p>Haskell syntax can be verbose if they are written using only anonymous nomenclature, so there is ‚Äúsyntactic sugar‚Äù, which can be used to simplify how things are written, for example, the following statements are equivalent</p>

<p>Function definitions can be expressed in various ways. Internally, they are allocating anonymous functions names, but syntactic sugar can be used to make this prettier. For example, the following two functions are equivalent:</p>

<pre><code class="language-{haskell}">x = \a -&gt; a + 1
x a = a + 1
</code></pre>

<h2 id="currying">Currying</h2>

<blockquote>
  <p>The process of converting a function which takes multiple arguments into a sequence of functions, each of which take one argument</p>
</blockquote>

<p>In Haskell, we fundamentally only create functions which apply an operation to a single input value, and generate a single output value.</p>

<p>We can make functions which look like they take multiple arguments by having a function which takes a parameter, and returns another function, which is specialised based on that parameter. Then, the second (or nth) parameter can be applied to this returned function, yielding the final value.</p>

<p>For example, to write a function to add two numbers, we can say:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">add</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>When this is evaluated, the first parameter would ‚Äúspecialise‚Äù the function, giving:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">add</span> <span class="mi">5</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">add</span> <span class="mi">5</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
</code></pre></div></div>

<p>So we can see when the first parameter is evaluated, another function is returned, which can then be evaluated with the next parameter. Then, with the second parameter, it just resolves to a single value:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">add</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="n">add</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">5</span>
</code></pre></div></div>

<p>This process is called ‚Äúpartial application‚Äù, as each parameter is ‚Äúpartially applied‚Äù to the function</p>

<h3 id="uncurry">Uncurry</h3>

<p>Contrastingly, there is a function <code class="language-plaintext highlighter-rouge">uncurry</code> that converts a curried function and converts it into a function on pairs.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uncurry</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">c</span>
</code></pre></div></div>

<p>What this does it to make it more like function in mathematics, where arguments are taken together.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> 
	<span class="c1">-- vs -- </span>
<span class="n">f</span> <span class="o">=</span> <span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<h2 id="conditionals">Conditionals</h2>

<p>In function definitions, we often want to be able to write conditional statements. For example, if we want to implement the ‚Äúnot‚Äù boolean operator, we might say ‚Äúif the argument is True, then False, otherwise, True‚Äù. This can be written in Haskell in a number of ways:</p>

<ul>
  <li>
    <p>If..then..else statements</p>

    <pre><code class="language-{haskell}">not' = \x -&gt; if True
                then False
                else True
</code></pre>

    <p>This can then be re-written using syntactic sugar to an in-line expression</p>

    <pre><code class="language-{haskell}">not' x = if True then False else True
</code></pre>

    <p>It is worth noting that if an if..then..else statement returns a boolean value, we should always try to replace it with just a simple expression, for example, <code class="language-plaintext highlighter-rouge">if x==5 then True else False</code> should be written as <code class="language-plaintext highlighter-rouge">x==5</code>.</p>
  </li>
  <li>
    <p>Guards, which similarly act like syntactic sugar for conditional expressions</p>

    <pre><code class="language-{haskell}">min x y | x &lt; y		= x
        | otherwise	= y
</code></pre>
  </li>
  <li>
    <p>Case statements</p>

    <pre><code class="language-{haskell}">not' = \x -&gt; case x of
                True -&gt; False
                False -&gt; True
</code></pre>
  </li>
</ul>

<h2 id="lists">Lists</h2>

<p>In Haskell, the list data type is implemented as a linked list. This effects how they should be used efficiently, for example, indexing inefficient, but looking at the first item is very efficient</p>

<p>Lists are homogenous, meaning all elements must have the same data type. As a result of this, the type of a list is the polymorphic type signature <code class="language-plaintext highlighter-rouge">[] :: [a]</code>, since they can store any type, but each element must have the same type</p>

<p>Lists are almost always written with their syntactic sugar, but they are in fact constructed by prepending elements to an empty list</p>

<pre><code class="language-{haskell}">x = [1,2,3]
x = 3 : (2 : (1 : []))
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">:</code> or ‚Äúcons‚Äù is used as an infix operator to prepend elements to the list, building it up from an empty list</p>

<ul>
  <li>This relates to how list data type is implemented as a linked list, as it encodes the fact that items are added as the head of the linked list sequentially</li>
  <li>The type of the ‚Äúcons‚Äù operator is <code class="language-plaintext highlighter-rouge">(:) :: a -&gt; [a] -&gt; [a]</code>, as it takes an element to prepend, and a list containing the same type, and returns a list of that type</li>
</ul>

<h2 id="ranges">Ranges</h2>

<p>Ranges are a way of generating lists, rather than having to explicitly enumerate them. Haskell can handle ranges for many data types, and will infer patterns from them. For example</p>

<pre><code class="language-{haskell}">&gt; [1..4]
[1,2,3,4]
&gt; ['a'..'c']
['a','b','c']
&gt; [1,3..10]
[1,3,5,7,9]
</code></pre>

<p>The last example shows the way the compiler can infer patterns - it is effective, but can only handle fairly simple patterns.</p>

<p>Since Haskell is lazily evaluated, it can store ranges of infinite length, and the data will only be used as it is needed</p>

<pre><code class="language-{haskell}">&gt; [0..]
[0,1,2,3,4,5,...]		-- takes infinite time to print all numbers out
&gt; take 3 [0..]
[0,1,2]					-- takes finite time to pull numbers off the front of an infinite array
</code></pre>

<h2 id="list-comprehensions">List comprehensions</h2>

<p>List comprehensions are a further way to generate lists, and offer a greater ability to select and filter the data. They have the general form:</p>

<pre><code class="language-{text}">[expression | generator(s) (predicate)]
</code></pre>

<p>They have a large number of variations, including:</p>

<ul>
  <li>
    <p>Expressions can be applied to the values being iterated over</p>

    <pre><code class="language-{haskell}">[even n | n &lt;- [0..5]]
=&gt; [True,False,True,False,True,False]
</code></pre>
  </li>
  <li>
    <p>Multiple generators can be used</p>

    <pre><code class="language-{haskell}">[n * m | n &lt;- [0..2], m &lt;- [0..2]]
=&gt; [0,0,0, 0,1,2, 0,2,3]
</code></pre>

    <p>where every <code class="language-plaintext highlighter-rouge">m</code> is iterated over for each <code class="language-plaintext highlighter-rouge">n</code></p>
  </li>
  <li>
    <p>Variables to the left are in scope of those to the right, so the following is also valid</p>

    <pre><code class="language-{haskell}">[n * m | n &lt;- [0..2], m &lt;- [0..n]]
=&gt; [0,0,1,0,2,4]
</code></pre>
  </li>
  <li>
    <p>The left hand side of a generator can be pattern matched on</p>

    <pre><code class="language-{haskell}">[x | (x:xs) &lt;- [[1,2,3], [4,5,6,7]]]
=&gt; [1,4]
</code></pre>
  </li>
  <li>
    <p>Finally, predicates can be used along with generators to select whether a value being iterated over should be included in the list</p>

    <pre><code class="language-{haskell}">[x | x &lt;- [0..5], even x]=&gt; [0,2,4]
</code></pre>
  </li>
</ul>

<h2 id="type-classes">Type Classes</h2>

<blockquote>
  <p><strong>Type class constraints</strong> are used to restrict type variables to only types which support the functions or operators specified by the type class.</p>

  <p><code class="language-plaintext highlighter-rouge">Num</code> is a type class in the Standard Library</p>
</blockquote>

<p>Like names of types, type class names must start with an upper-case character.</p>

<h3 id="type-class-definitions">Type Class Definitions</h3>

<blockquote>
  <p>In a <strong>type class definition</strong>, we define the <strong>method typings</strong> that an arbitrary type <code class="language-plaintext highlighter-rouge">a</code> <strong>must implement</strong> to be an <strong>instance</strong> of that type class.</p>
</blockquote>

<p><strong>Example.</strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">abs</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="o">...</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Num</code> is the name of the type class we are defining.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">a</code> is a type variable.</li>
  <li>The definitions are the <strong>typing</strong> of the <strong>methods</strong> that a <code class="language-plaintext highlighter-rouge">Num</code> must adhere to.</li>
</ul>

<h3 id="type-instance">Type Instance</h3>

<blockquote>
  <p>When we <strong>define an instance</strong> of a type class, we have to <strong>adhere</strong> to the typing of the method(s) in the type class definition.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Show</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span>
  
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="kt">True</span>  <span class="o">=</span> <span class="s">"True"</span>
  <span class="n">show</span> <span class="kt">False</span> <span class="o">=</span> <span class="s">"False"</span>
</code></pre></div></div>

<p>In a Haskell module, there are a bunch of definitions of expressions. If we have a definition for something ‚Äì we can refer to it by its name in the program. The Haskell compiler works out the <strong>typing</strong> for each definition is ‚Äì when we use it it checks if the type is compatible with the expression.</p>

<blockquote>
  <p>Hence, we say that a <strong>type class</strong> brings <strong>function typings</strong> into scope.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">abs</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Num a =&gt;</code> is a type class constraint.</li>
</ul>

<h4 id="constraints-on-instances">Constraints on instances</h4>

<p>You can also place constraints on instances.</p>

<p><strong>Example.</strong> Let‚Äôs say we want to define an instance of <code class="language-plaintext highlighter-rouge">Show</code> for pairs.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Show</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Because we are using polymorphic types <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, we obviously can‚Äôt pattern match on all possible values. Hence, the best way to do this is to place constraints that say both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> must be instances of <code class="language-plaintext highlighter-rouge">Show</code> themselves.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="s">"("</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span> <span class="o">++</span> <span class="s">")"</span>
</code></pre></div></div>

<h3 id="superclass-constraints">Superclass Constraints</h3>

<blockquote>
  <p>Sometimes, certain type classes have a <strong>superclass constraint</strong> stating that a type must also be an instance of a <strong>superclass</strong> to be an instance of the <strong>current class.</strong></p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>  <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
  <span class="p">(</span><span class="o">&lt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
  <span class="o">...</span>
</code></pre></div></div>

<ul>
  <li>In order for <code class="language-plaintext highlighter-rouge">a</code> to be an instance of <code class="language-plaintext highlighter-rouge">Ord</code>, it must also be an instance of <code class="language-plaintext highlighter-rouge">Eq</code>.</li>
</ul>

<p>As a result, an <code class="language-plaintext highlighter-rouge">Ord</code> constraint on a function implies an <code class="language-plaintext highlighter-rouge">Eq</code> constraint</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">greaterOrEqual</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">greaterOrEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
</code></pre></div></div>

<h2 id="polymorphism">Polymorphism</h2>

<h3 id="parametric-polymorphism">Parametric polymorphism</h3>

<blockquote>
  <p>Allows us to reuse the same data structure for different types of elements. (Generics in Java)</p>
</blockquote>

<p><strong>Example of Parametric Polymorphism in Haskell</strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- The identity function works on elements of any type</span>
<span class="n">id</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">id</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
<span class="c1">-- Same as head function, works on lists that contain any type</span>
<span class="n">head</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">head</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<h3 id="ad-hoc-polymorphism">Ad-hoc polymorphism</h3>

<blockquote>
  <p>A kind of polymorphism that is <strong>open</strong> to future extension.</p>
</blockquote>

<p>In Haskell, <strong>type class constraints</strong> is called ad-hoc polymorphism as you can define a function that works with a <strong>certain type class</strong> <code class="language-plaintext highlighter-rouge">K</code>, but does not necessarily work with any type just yet. In the future, as long as you define an instance of <code class="language-plaintext highlighter-rouge">K</code> for an arbitrary type, this function will accept/work with this arbitrary type.</p>

<h3 id="subtype-polymorphism">Subtype polymorphism</h3>

<p>A synonym of this is <a href="https://csrg-group.github.io/dcs-notes.github.io/CS118/part5.html#dynamic-polymorphism">dynamic polymorphism</a> in Java.</p>

<h2 id="associativity">Associativity</h2>

<blockquote>
  <p><strong>Function</strong> associativity binds the strongest.</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Haskell</th>
      <th style="text-align: center">Maths</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">f x * g y</code></td>
      <td style="text-align: center">\(f(x) \times¬†g(y)\)</td>
    </tr>
  </tbody>
</table>

<blockquote class="centeredtable">
  <p>Function <strong>expressions</strong> associates to the right.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xor</span> <span class="o">=</span> <span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">||</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">not</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- is the same as </span>
<span class="n">xor</span> <span class="o">=</span> <span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">||</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">not</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">))</span>
</code></pre></div></div>

<blockquote>
  <p>Function <strong>application</strong> associates to the left.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xor</span> <span class="kt">True</span> <span class="kt">True</span>
<span class="c1">-- is the same as</span>
<span class="p">(</span><span class="n">xor</span> <span class="kt">True</span><span class="p">)</span> <span class="kt">True</span>
</code></pre></div></div>

<blockquote>
  <p>Function <strong>types</strong> associates to the right.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xor</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="c1">-- is the same as </span>
<span class="n">xor</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
</code></pre></div></div>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="lazy-evaluation--recursion">Lazy Evaluation &amp; Recursion</h1>
       
            <h2 id="evaluation-strategies">Evaluation Strategies</h2>

<blockquote>
  <p><strong>Evaluation strategies</strong> determine the order in which we reduce expressions. An expression that can be reduced is called a <strong>redex.</strong></p>
</blockquote>

<h3 id="strictness">Strictness</h3>

<blockquote>
  <p>A programming language is <strong>strict</strong> if only strict functions (functions whose parameters must be evaluated completely before they may be called) may be defined by the user.</p>
</blockquote>

<h3 id="call-by-value">Call-by-value</h3>

<blockquote>
  <p>A <strong>strict evaluation strategy</strong> where all function arguments are <strong>reduced to normal forms</strong> (values) before being passed as such to the function.</p>
</blockquote>

<p><strong>Example.</strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fac'</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fac'</span> <span class="mi">0</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
<span class="n">fac'</span> <span class="n">n</span> <span class="n">m</span> <span class="o">=</span> <span class="n">fac'</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">fac</span> <span class="mi">2</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="mi">2</span> <span class="mi">1</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
   <span class="o">...</span>
</code></pre></div></div>

<h3 id="call-by-name">Call-by-name</h3>

<blockquote>
  <p>A <strong>non-strict evaluation strategy</strong> where expressions are given to functions as arguments are <strong>not reduced</strong> before the function call is made.</p>

  <p>Expressions are only reduced when their value is <strong>needed</strong>.</p>
</blockquote>

<p><strong>When is a value needed?</strong></p>

<p>A case expression is the only thing that enforces the evaluation of a particular expression (we‚Äôre only evaluating something if its in a case expression). We <strong>need the value</strong> of an expression when we <strong>cannot proceed</strong> with the case expression <strong>until we reduce</strong> the expression.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fac'</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fac'</span> <span class="mi">0</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
<span class="n">fac'</span> <span class="n">n</span> <span class="n">m</span> <span class="o">=</span> <span class="n">fac'</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">fac</span> <span class="mi">2</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="mi">2</span> <span class="mi">1</span>
<span class="o">=&gt;</span> <span class="kr">case</span> <span class="mi">2</span> <span class="kr">of</span>
     <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
     <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kr">case</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span> <span class="kr">of</span>
     <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>
     <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">fac'</span> <span class="p">((</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">((</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">))</span>
<span class="o">=&gt;</span> <span class="kr">case</span> <span class="mi">1</span> <span class="kr">of</span>
     <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>
     <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">fac'</span> <span class="p">((</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">((</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">2-1</code> (from the 2nd last step) is <strong>reduced</strong> to <code class="language-plaintext highlighter-rouge">1</code>, it is the first time in the example that an expression is <strong>reduced</strong>. This only happens because the value of the redex <code class="language-plaintext highlighter-rouge">2-1</code> is needed for the case expression to continue.</p>

<h3 id="cbn-vs-cbv">CBN vs CBV</h3>

<p><em>call by name vs call by value</em></p>

<blockquote>
  <p>In a language which uses call-by-name evaluation, such as Haskell, expressions are only evaluated when it becomes clear that their value is needed. In call-by-value, function arguments are always evaluated before the function is called.</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Call-by-value</th>
      <th>Call-by-name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Reduce function arguments to normal forms before calling the function</td>
      <td>Only reduce expressions when their value is needed</td>
    </tr>
    <tr>
      <td>We may evaluate arguments even if they are <strong>never needed</strong>.</td>
      <td>We may end up reducing the same expression <strong>over and over</strong>.</td>
    </tr>
  </tbody>
</table>

<h3 id="lazy-evaluation">Lazy evaluation</h3>

<p>From above, we see that call-by-name and call-by-value each have its flaws.</p>

<blockquote>
  <p>This is essentially <strong>call-by-name + sharing</strong>, where we avoid duplicate evaluation but also only ever evaluate expressions that are needed.</p>
</blockquote>

<p>Lazy evaluation is the default evaluation strategy in Haskell. Since Haskell is a <strong>non-strict programming language</strong>, it can be strict if the <strong>compiler</strong> (the compiler does everything for us ü•≥) thinks its better or if we force it to be strict with the <code class="language-plaintext highlighter-rouge">$!</code> operator.</p>

<h4 id="sharing">Sharing</h4>

<p>This is the technique that helps us avoid duplicate evaluation.</p>

<blockquote>
  <p>Sharing turns arguments to function into local definitions.</p>

  <p><strong>TLDR.</strong> Normally for call-by-name, expressions are represented by <strong>closures</strong> (memory locations on the heap) and pointers to them are then passed to functions as arguments. If an argument is used more than once within a function, then it will be <strong>evaluated multiple times</strong>. Sharing is an optimisation which allows these <strong>closures</strong> to be <strong>updated</strong> with their result once they have been evaluated, meaning they only have to evaluated once.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                              <span class="n">fac'</span> <span class="n">n</span> <span class="n">m</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">n</span> <span class="kr">of</span>
<span class="n">fac'</span> <span class="n">n</span> <span class="n">m</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">n</span> <span class="kr">of</span>            <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">m</span>
  <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">m</span>                 <span class="o">==&gt;</span>    <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>                  <span class="n">y</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span>
                                     <span class="kr">in</span> <span class="n">fac'</span> <span class="n">x</span> <span class="n">y</span>
</code></pre></div></div>

<p>This ensures that functions are always applied to either <strong>values</strong> or a <strong>variable</strong> defined in a <code class="language-plaintext highlighter-rouge">let</code> (or <code class="language-plaintext highlighter-rouge">where</code>) bound. This means that if a variable (e.g. <code class="language-plaintext highlighter-rouge">x0 = 2-1</code>) has to be evaluated, its RHS is evaluated (so <code class="language-plaintext highlighter-rouge">2-1=1</code>) and <code class="language-plaintext highlighter-rouge">x0</code> is updated with the value of the expression, so <code class="language-plaintext highlighter-rouge">x0 = 1</code>. Also see <a href="#dynamic-closures">dynamic closures</a>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">fac</span> <span class="mi">2</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="mi">2</span> <span class="mi">1</span>
<span class="o">=&gt;</span> <span class="kr">case</span> <span class="mi">2</span> <span class="kr">of</span>
     <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span>
     <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
              <span class="n">y0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>
          <span class="kr">in</span> <span class="n">fac'</span> <span class="n">x0</span> <span class="n">y0</span>
<span class="o">=&gt;</span> <span class="kr">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
       <span class="n">y0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>
   <span class="kr">in</span> <span class="n">fac'</span> <span class="n">x0</span> <span class="n">y0</span>
<span class="o">=&gt;</span> <span class="kr">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">-</span><span class="mi">1</span>
       <span class="n">y0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>
   <span class="kr">in</span> <span class="kr">case</span> <span class="n">x0</span> <span class="kr">of</span>             <span class="c1">-- x0 has to be evaluated as its value is</span>
        <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">y0</span>              <span class="c1">-- needed for the case expression to continue</span>
        <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">-</span><span class="mi">1</span>
                 <span class="n">y1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">*</span><span class="n">y0</span>
             <span class="kr">in</span> <span class="n">fac'</span> <span class="n">x1</span> <span class="n">y1</span>
<span class="o">=&gt;</span> <span class="kr">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>                <span class="c1">-- x0 has been updated with the result of </span>
       <span class="n">y0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>              <span class="c1">-- evaluating RHS</span>
   <span class="kr">in</span> <span class="kr">case</span> <span class="n">x0</span> <span class="kr">of</span>
        <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">y0</span>
        <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">-</span><span class="mi">1</span>
                 <span class="n">y1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">*</span><span class="n">y0</span>
             <span class="kr">in</span> <span class="n">fac'</span> <span class="n">x1</span> <span class="n">y1</span>
<span class="o">=&gt;</span> <span class="kr">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>                
       <span class="n">y0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span>               
   <span class="kr">in</span> <span class="kr">case</span> <span class="mi">1</span> <span class="kr">of</span>             <span class="c1">-- x0 can now be replaced by 1</span>
        <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">y0</span>
        <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kr">let</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">-</span><span class="mi">1</span>
                 <span class="n">y1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">*</span><span class="n">y0</span>
             <span class="kr">in</span> <span class="n">fac'</span> <span class="n">x1</span> <span class="n">y1</span>
</code></pre></div></div>

<p>When we refer to <code class="language-plaintext highlighter-rouge">x0</code> again, we have access to its evaluated value (because we evaluated it before) and there will be <strong>no need</strong> to evaluate it again and again, all while using <strong>call-by-name.</strong></p>

<h4 id="lazy-evaluation-walk-through">Lazy evaluation Walk-through</h4>

<blockquote>
  <p>Given the following expression, show how it is evaluated with lazy evaluation (do not skip steps).</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">2</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
</code></pre></div></div>

<p>When tackling this kind of question it is helpful to refer to the definitions of the functions that are used. These are usually specified/given to you/made by you in an earlier question, otherwise its difficult to evaluate it properly without knowing the exact definition.</p>

<p>Here the definitions we use are.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">length</span> <span class="kt">[]</span>     <span class="o">=</span> <span class="mi">0</span>
<span class="n">length</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="n">xs</span>

<span class="n">take</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">take</span> <span class="mi">0</span> <span class="kr">_</span>     <span class="o">=</span> <span class="kt">[]</span>
<span class="n">take</span> <span class="n">n</span> <span class="kt">[]</span>    <span class="o">=</span> <span class="kt">[]</span>
<span class="n">take</span> <span class="n">n</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">take</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>

<span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map</span> <span class="n">f</span> <span class="kt">[]</span>     <span class="o">=</span> <span class="kt">[]</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></div></div>

<p><strong>Answer.</strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">2</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">2</span> <span class="p">(</span><span class="n">even</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="n">length</span> <span class="p">(</span><span class="n">even</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">take</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">1</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">1</span> <span class="p">(</span><span class="n">even</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="p">(</span><span class="n">even</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">take</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])))</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">0</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])))</span> 
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">length</span> <span class="kt">[]</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">=&gt;</span> <span class="mi">2</span>
</code></pre></div></div>

<p>Questions may ask about call-by-value and call-by-name too, so know this topic well.</p>

<h2 id="closures">Closures</h2>

<blockquote>
  <p>A structure in memory at runtime that represents a function and its environments (i.e scope).</p>
</blockquote>

<p>We can think of it as an array of pointers</p>

<ul>
  <li>1st pointer points to some code</li>
  <li>other pointers point to other closures.</li>
</ul>

<p><strong>Example.</strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">not</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">not</span> <span class="kt">True</span> <span class="o">=</span> <span class="kt">False</span>
<span class="n">not</span> <span class="kt">False</span> <span class="o">=</span> <span class="kt">True</span>
</code></pre></div></div>

<p>In memory, you have a particular memory location/address that stores a pointer to the code (we don‚Äôt have to worry about where the code is.)</p>

<ul>
  <li>Every usage of <code class="language-plaintext highlighter-rouge">not</code> in the code is a pointer to this memory location.</li>
</ul>

<blockquote>
  <p>Functions in Haskell (and other functional programming languages) are first class values, which means they can be returned by other functions or given to functions as arguments (higher-order-functions).</p>
</blockquote>

<p><strong>Example.</strong></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">g</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
      <span class="kr">in</span> <span class="n">g</span>
</code></pre></div></div>

<p>In memory, we have a static closure of <code class="language-plaintext highlighter-rouge">f</code> as mentioned above for <code class="language-plaintext highlighter-rouge">not</code></p>

<ul>
  <li>Initially when the program is started, there is no closure for <code class="language-plaintext highlighter-rouge">g</code>. Only have closures for top-level definitions like <code class="language-plaintext highlighter-rouge">f</code> here when program starts.</li>
  <li>When we start evaluating <code class="language-plaintext highlighter-rouge">f</code>, every call to <code class="language-plaintext highlighter-rouge">f</code> will dynamically allocate a closure to <code class="language-plaintext highlighter-rouge">g</code> on the heap (this is only for that particular invocation of <code class="language-plaintext highlighter-rouge">f</code>)
    <ul>
      <li>This closure is comprised of a pointer to code for <code class="language-plaintext highlighter-rouge">g</code> and a pointer to <code class="language-plaintext highlighter-rouge">x</code></li>
      <li>The reason for this is because the body of <code class="language-plaintext highlighter-rouge">g</code> refers to <code class="language-plaintext highlighter-rouge">x</code>, which is a parameter of <code class="language-plaintext highlighter-rouge">f</code>.</li>
      <li>Because <code class="language-plaintext highlighter-rouge">g</code> is defined within the scope of <code class="language-plaintext highlighter-rouge">f</code>, it has access to whatever is in scope of <code class="language-plaintext highlighter-rouge">f</code>, which <code class="language-plaintext highlighter-rouge">x</code> is.</li>
    </ul>
  </li>
  <li>It doesn‚Äôt matter if the stack frame for <code class="language-plaintext highlighter-rouge">f</code> is removed because <code class="language-plaintext highlighter-rouge">g</code> still has a reference to what <code class="language-plaintext highlighter-rouge">x</code> <strong>was</strong>.</li>
</ul>

<h3 id="dynamic-closures">Dynamic Closures</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="p">(</span><span class="n">take</span> <span class="mi">2</span> <span class="p">(</span><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span> 
<span class="c1">-- is translated into</span>
<span class="kr">let</span> <span class="n">zs4</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">:</span> <span class="kt">[]</span>
    <span class="n">zs3</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">zs4</span>
    <span class="n">zs2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">zs3</span>
    <span class="n">zs</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">zs2</span>
    <span class="n">ys</span>  <span class="o">=</span> <span class="n">map</span> <span class="n">even</span> <span class="n">zs</span>
    <span class="n">xs</span>  <span class="o">=</span> <span class="n">take</span> <span class="mi">2</span> <span class="n">ys</span>
<span class="kr">in</span> <span class="n">length</span> <span class="n">xs</span>
<span class="c1">-- by the compiler</span>
</code></pre></div></div>

<p>When this expression gets evaluated at runtime, a closure is <strong>dynamically allocated</strong> for each of these ‚Äúvariables‚Äù (so <code class="language-plaintext highlighter-rouge">zs4</code>, <code class="language-plaintext highlighter-rouge">zs3</code>, ‚Ä¶ , <code class="language-plaintext highlighter-rouge">xs</code>).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">length</code> is just a pointer to the static closure for the <code class="language-plaintext highlighter-rouge">length</code> function.</li>
  <li><code class="language-plaintext highlighter-rouge">xs</code> is a pointer to the closure that is dynamically allocated for <code class="language-plaintext highlighter-rouge">xs</code> shown above.</li>
</ul>

<h2 id="recursive-functions">Recursive Functions</h2>

<p>In C, Java, and most imperative languages, function calls push frames onto the stack which is where local variables are stored. Each recursive function call is evaluated before the final value is calculated. To illustrate take the <code class="language-plaintext highlighter-rouge">factorial</code> function as an example:</p>

<pre><code class="language-C">int fac (int n) {
  if (n == 0) return 1;
  int r = fac(n - 1);
  return n * r;
}
</code></pre>

<p>In C, each value of <code class="language-plaintext highlighter-rouge">n-1</code> for each call to <code class="language-plaintext highlighter-rouge">fac</code> is evaluated before the multiplication of <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">r</code>, so we get something like this in the stack:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- The Stack</span>
<span class="n">fac</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="o">:</span> <span class="n">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="n">fac</span><span class="p">(</span><span class="mi">497</span><span class="p">)</span><span class="o">:</span> <span class="n">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fac</span><span class="p">(</span><span class="mi">498</span><span class="p">)</span><span class="o">:</span> <span class="n">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fac</span><span class="p">(</span><span class="mi">499</span><span class="p">)</span><span class="o">:</span> <span class="n">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fac</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span><span class="o">:</span> <span class="n">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>Only when we get to the <strong>base case</strong> <code class="language-plaintext highlighter-rouge">n==0</code>, we get a value for <code class="language-plaintext highlighter-rouge">r</code> which is 1. Then the stack is popped and the next call to <code class="language-plaintext highlighter-rouge">fac</code> at the top will be evaluated until the initial call to <code class="language-plaintext highlighter-rouge">fac(500)</code>. If we defined this in Haskell, this would probably look like:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fac</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> 
<span class="n">fac</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">fac</span> <span class="mi">500</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="mi">500</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">fac</span> <span class="mi">499</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="mi">499</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="mi">499</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="mi">499</span> <span class="o">*</span> <span class="n">fac</span> <span class="mi">498</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="p">(</span><span class="mi">499</span> <span class="o">*</span> <span class="p">(</span><span class="mi">498</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="mi">498</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
	 <span class="o">...</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">499</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span> <span class="n">fac</span> <span class="mi">0</span>
<span class="o">=&gt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">499</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span> <span class="mi">1</span> <span class="c1">-- multiplication can finally be evaluated</span>
<span class="o">=&gt;</span> <span class="n">multiplication</span> <span class="n">is</span> <span class="n">evaluated</span>
</code></pre></div></div>

<p>This <strong>naive way</strong> of evaluating recursion builds up large expressions (with lots of closures) because <strong>nothing forces</strong> the expressions to get evaluated at intermediate steps.</p>

<ul>
  <li>The multiplication can never be reduced until the end because at <strong>no</strong> point do we have the <strong>second argument</strong> until we reach the base case.</li>
  <li>Hence, <strong>deep recursion</strong> in imperative languages could cause your program to run out of memory, which is called a <strong>stack overflow.</strong></li>
</ul>

<blockquote class="extra"><b>FYI.</b> There is a ‚Äútrick‚Äù called <a href="https://en.wikipedia.org/wiki/Tail_call">tail-call optimisation</a> that programming languages can use to prevent a stack overflow for certain kinds of recursive functions. 
  <br /><br />In functional programming languages, tail call optimisation is often guaranteed by the language standard, as it allows tail recursion to use a similar amount of memory as a loop in an imperative language. If you are interested, read more <a href="https://www.codurance.com/publications/2017/12/05/on-tail-call-optimisation">here</a>.</blockquote>

<h3 id="optimised-recursive-functions-in-haskell">Optimised Recursive Functions in Haskell</h3>

<p>The Haskell compiler optimises this for us by recreating the function we call (i.e <code class="language-plaintext highlighter-rouge">fac</code>) with another function that has an <strong>accumulating parameter</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Here m is the accumulating parameter</span>
<span class="n">fac'</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fac'</span> <span class="mi">0</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
<span class="n">fac'</span> <span class="n">n</span> <span class="n">m</span> <span class="o">=</span> <span class="n">fac'</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="c1">-- fac is then rewritten with fac'</span>
<span class="n">fac</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">fac</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fac'</span> <span class="n">n</span> <span class="mi">1</span>
</code></pre></div></div>

<p>What this does is that the result of earlier calls to <code class="language-plaintext highlighter-rouge">fac</code> is evaluated and ‚Äúaccumulates‚Äù in the second argument <code class="language-plaintext highlighter-rouge">m</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">fac</span> <span class="mi">500</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="mi">500</span> <span class="mi">1</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">500</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">500</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span> <span class="c1">-- 500-1 needs to be evaluated to continue</span>
<span class="o">=&gt;</span> <span class="kr">case</span> <span class="n">x0</span> <span class="kr">of</span>           <span class="c1">-- Since x0 = 500 - 1 and needs to be evaluated</span>
     <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">y0</span>
     <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">fac'</span> <span class="n">x1</span> <span class="n">y1</span>
   <span class="kr">where</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">y0</span> <span class="o">=</span> <span class="mi">500</span><span class="o">*</span><span class="mi">1</span>
         <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">y1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">*</span> <span class="n">y0</span>
<span class="o">=&gt;</span> <span class="kr">case</span> <span class="n">x0</span> <span class="kr">of</span>           
     <span class="mi">0</span> <span class="o">-&gt;</span> <span class="n">y0</span>
     <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">fac'</span> <span class="n">x1</span> <span class="n">y1</span>
   <span class="kr">where</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">499</span>       <span class="c1">-- We evaluate 500 - 1 = 499, and x0 is updated with </span>
         <span class="n">y0</span> <span class="o">=</span> <span class="mi">500</span><span class="o">*</span><span class="mi">1</span>     <span class="c1">-- this new value, and now the case expression can</span>
         <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="mi">1</span>    <span class="c1">-- proceed</span>
         <span class="n">y1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">*</span> <span class="n">y0</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">499</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">499</span><span class="o">*</span><span class="mi">500</span><span class="o">*</span><span class="mi">1</span><span class="p">)</span> <span class="c1">-- This continues for (499-1), (498-1) ...</span>
<span class="o">=&gt;</span> <span class="n">fac'</span> <span class="p">(</span><span class="mi">498</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">498</span><span class="o">*</span><span class="p">(</span><span class="mi">499</span><span class="o">*</span><span class="p">(</span><span class="mi">500</span><span class="o">*</span><span class="mi">1</span><span class="p">)))</span>
   <span class="o">...</span>
</code></pre></div></div>

<p>As you can see, <code class="language-plaintext highlighter-rouge">fac'</code> <strong>forces</strong> the evaluation of the first argument at <strong>every step</strong> by pattern-matching on it. While the second argument will build up into a long list of closures if is evaluated <strong>lazily</strong>, the difference with <strong>naive recursion</strong> is that it <strong>can</strong> be <strong>forced</strong> to be evaluated because all arguments are present for <strong>multiplication</strong>.</p>

<h3 id="useful-recursive-functions">Useful recursive functions</h3>

<p>There are a number of recursive functions which are useful to be able to lookup to see the schema, or just to be able to reproduce in some contexts</p>

<h4 id="quick-sort">Quick sort</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">quicksort</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>  
    <span class="n">quicksort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>  
    <span class="n">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>   
        <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">]</span>  
            <span class="n">biggerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">]</span>  
        <span class="kr">in</span>  <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>  
</code></pre></div></div>

<p>Implementation taken from <em>Learn You a Haskell for Great Good! A Beginner‚Äôs Guide, Lipovaca, Miran</em></p>

<p>This can be expressed more neatly than merge sort, as due to the implementation of lists as linked lists, it is less efficient to split arrays in two in Haskell as is required for merge sort</p>


            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="higher-order-functions">Higher order functions</h1>
       
            <p>Higher order functions are functions which operate on other functions, either taking another function as a parameter, or returning one as a result</p>

<p>The process of currying, discussed earlier, is a higher order function, as a function takes a parameter, and returns another functioned, specialised by that parameter</p>

<h2 id="sections">Sections</h2>

<p>Sections are partial applications of infix operators. If you give only one argument to an infix operator, it returns a function of the ‚Äúmissing‚Äù side of the operation, for example, if the left side of the infix exponent is given, a function taking the exponent as the parameter is returned, but if the right side is given, the function takes the base as parameter. This is written as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">2</span>

<span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">)</span>
<span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">^</span> <span class="n">x</span>
</code></pre></div></div>

<h2 id="examples-of-higher-order-functions">Examples of higher order functions</h2>

<h3 id="map">Map</h3>

<p>A function that takes a list and a function, and returns a new list, with every element in the old one having had the function applied to it</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>  
<span class="n">map</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>  
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>  
</code></pre></div></div>

<h3 id="filter">Filter</h3>

<p>A function that takes a list and a predicate (a function which indicates the truth value of its parameter), and returns the list containing only the true values in the original list</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filter</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>  
<span class="n">filter</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>  
<span class="n">filter</span> <span class="n">p</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>   
    <span class="o">|</span> <span class="n">p</span> <span class="n">x</span>       <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>  
    <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>  
</code></pre></div></div>

<h4 id="quicksort-using-filter">Quicksort using filter</h4>

<p>We can neatly write sorting algorithms using this, such as quicksort (with the pivot being picked as the middle in this case)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">quicksort</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>    
<span class="n">quicksort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>    
<span class="n">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>     
    <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>  
        <span class="n">biggerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>   
    <span class="kr">in</span>  <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>  
</code></pre></div></div>

<h3 id="folds">Folds</h3>

<p>Folds are a class of function which repeatedly reduce a list, having an accumulator value, and a function which takes values from the list elementwise, and combines them into the accumulator. It is described in a <a href="https://stackoverflow.com/a/25150003">stack overflow answer</a> as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In:
    initial value
    way to combine stuff with initial value
    collection
Out:
    combined stuff
</code></pre></div></div>

<p>We actually write this in code using the following syntax</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initialAccumulator</span> <span class="o">::</span> <span class="n">a</span>
<span class="n">combinationFunction</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="n">foo</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">foo</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">accumulator</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">combinationFunction</span> <span class="n">accumulator</span> <span class="n">x</span><span class="p">)</span> <span class="n">initialAccumulator</span> <span class="n">xs</span>
</code></pre></div></div>

<p>There are two common implementations, <code class="language-plaintext highlighter-rouge">foldl</code>, and <code class="language-plaintext highlighter-rouge">foldr</code>, which start by applying the function to the first and last elements respectively. These two folds have different properties, and there is an additional type <code class="language-plaintext highlighter-rouge">foldl'</code>, which strengthens the properties of <code class="language-plaintext highlighter-rouge">foldl</code>. <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl%27">Additional source #1</a> <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl%27">Additional source #2</a></p>

<h4 id="foldr">Foldr</h4>

<p><code class="language-plaintext highlighter-rouge">foldr</code> generates the entire expression before evaluation, with <code class="language-plaintext highlighter-rouge">foldr f z [1,2,3]</code> evaluating to <code class="language-plaintext highlighter-rouge">f 1 (f 2 (f 3 z))</code></p>

<p>For example  <code class="language-plaintext highlighter-rouge">foldr (+) [1..1000]</code> evaluates as <code class="language-plaintext highlighter-rouge">1 + (2 + (3 + (...)))</code>. As the chain of operations doesn‚Äôt contain a <strong>redex</strong> (reducible expression) until the entire chain is built, the entire expression must be generated before it can be evaluated. This means it will cause stack overflows on large lists.</p>

<p>If the combination function is able to produce part of the result independent of the recursive case, so the rest of the result is never demanded, the recursion will stop, allowing use on infinite lists</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">))))</span> <span class="kt">[]</span>
<span class="o">=&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">))))</span>
</code></pre></div></div>

<h4 id="foldl">Foldl</h4>

<p><code class="language-plaintext highlighter-rouge">foldl</code> applies the function as it goes along, with <code class="language-plaintext highlighter-rouge">foldl f z [1,2,3]</code> evaluating to <code class="language-plaintext highlighter-rouge">f (f (f z 1) 2) 3</code></p>

<p>For example <code class="language-plaintext highlighter-rouge">foldl (+) [1..1000]</code> evaluates as <code class="language-plaintext highlighter-rouge">(((0 + 1) + 2) + 3) + ...</code>. This seems like it would reduce as is goes along, as each bracket is its own redex, but due to Haskell‚Äôs lazy evaluation, it doesn‚Äôt, so it still causes stack overflows on large lists. It can never handle infinite lists, and will always recurse forever if they are given</p>

<p>An example case of execution is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">((</span><span class="mi">0</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(((</span><span class="mi">0</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">((((</span><span class="mi">0</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="kt">[]</span>
<span class="o">=&gt;</span> <span class="p">((((</span><span class="mi">0</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="foldl-1">Foldl‚Äô</h4>

<p><code class="language-plaintext highlighter-rouge">foldl'</code> is a modification of <code class="language-plaintext highlighter-rouge">foldl</code> which forces Haskell to evaluate each redex as it goes, despite lazy evaluation, allowing avoiding stack overflows for large lists, but inherently sacrificing the other benefits of lazy evaluation</p>

<p>An example case of execution is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">8</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">10</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="kt">[]</span>
<span class="o">=&gt;</span> <span class="mi">11</span>
</code></pre></div></div>

<p>We can see this differs from the standard <code class="language-plaintext highlighter-rouge">foldl</code>, as at each step it reduces the accumulated expression</p>

<h3 id="function-composition">Function composition</h3>

<p>A function which chains the output of one function into the input of the other</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>We can then use this to write code more neatly with fewer brackets, for example, the following statments are equivalent:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="n">h</span> <span class="n">x</span><span class="p">))</span>
<span class="n">f</span> <span class="o">.</span> <span class="n">g</span> <span class="o">.</span> <span class="n">h</span> <span class="n">x</span>
</code></pre></div></div>


            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="data-types">Data Types</h1>
       
            <h2 id="data-type-definition">Data Type Definition</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span>
<span class="kr">data</span> <span class="kt">Module</span> <span class="o">=</span> <span class="kt">CS141</span> <span class="o">|</span> <span class="kt">CS256</span> <span class="o">|</span> <span class="kt">CS118</span> <span class="o">|</span> <span class="kt">CS132</span> <span class="o">...</span>
<span class="kr">data</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="kt">Unit</span>
<span class="n">not</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">not</span> <span class="kt">True</span>  <span class="o">=</span> <span class="kt">False</span> <span class="c1">-- Pattern matching on constructors</span>
<span class="n">not</span> <span class="kt">False</span> <span class="o">=</span> <span class="kt">True</span>  <span class="c1">-- Constructors as values</span>
</code></pre></div></div>

<p>This is the definition of the data type for <code class="language-plaintext highlighter-rouge">Bool</code>. ‚ÄúBool‚Äù is the name of the type, and ‚ÄúFalse‚Äù and ‚ÄúTrue‚Äù are <strong>data constructors.</strong></p>

<ul>
  <li>We can pattern-match on data constructors</li>
  <li>We can use data constructors as values</li>
  <li>We can have as many number of data constructors as we want</li>
  <li>Name of the type is not the same as the data constructor (although we can name them the same)</li>
  <li>Data constructors can have parameters.</li>
</ul>

<h3 id="parametrised-data-constructors">Parametrised Data Constructors</h3>

<p>We can add parameters to a data constructor by adding their types after the constructor‚Äôs name.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="kt">Rect</span> <span class="kt">Double</span> <span class="kt">Double</span>
           <span class="o">|</span> <span class="kt">Circle</span> <span class="kt">Double</span>
</code></pre></div></div>

<p>We can treat data constructors like a function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Rect</span>   <span class="o">::</span> <span class="kt">Double</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="kt">Circle</span> <span class="o">::</span> <span class="kt">Double</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
</code></pre></div></div>

<h2 id="recursive-data-types">Recursive Data Types</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">Succ</span> <span class="kt">Nat</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">BinTree</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">BinTree</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="type-aliases">Type Aliases</h2>

<p>We can define aliases for a certain type.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">String</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="kr">type</span> <span class="kt">Memory</span> <span class="o">=</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span> <span class="c1">-- Recall coursework 2</span>
<span class="kr">type</span> <span class="kt">Predicate</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<h2 id="derivable-type-classes">Derivable Type Classes</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Type Classes</th>
      <th style="text-align: center">Extension needed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Eq</code>, <code class="language-plaintext highlighter-rouge">Ord</code>, <code class="language-plaintext highlighter-rouge">Enum</code>, <code class="language-plaintext highlighter-rouge">Bounded</code>, <code class="language-plaintext highlighter-rouge">Show</code>, <code class="language-plaintext highlighter-rouge">Read</code></td>
      <td style="text-align: center">¬†</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Typeable</code>, <code class="language-plaintext highlighter-rouge">Data</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">XDeriveDataTypeable</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Generic</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">XDeriveGeneric</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Functor</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">XDeriveFunctor</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Foldable</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">XDeriveFoldable</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Traversable</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">XDeriveTraversable</code></td>
    </tr>
  </tbody>
</table>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="equational-reasoning-in-haskell">Equational Reasoning in Haskell</h1>
       
            <h2 id="intro">Intro</h2>

<p>Functions in Haskell are pure ‚Äì they have no side-effects and their results only depend on their arguments. Because of that we are able to easily prove formal properties about our functions.</p>

<blockquote>
  <p>We can‚Äôt use equational reasoning on impure functions, because their results may depend on values other than the arguments, thereby rendering any properties we prove invalid.</p>
</blockquote>

<h2 id="techniques">Techniques</h2>

<h3 id="direct-proof">Direct proof</h3>

<p>The steps for performing a direct proof are:</p>

<ol>
  <li>Write down the types of all of the variables</li>
  <li>Write down the definitions of all of the relevant functions</li>
  <li>Repeatedly apply internal steps to get from the LHS to the RHS
    <ul>
      <li>It is often worth working from both sides in towards the middle</li>
    </ul>
  </li>
</ol>

<p>The are only a small number of internal steps that can be made in a direct proof:</p>

<ul>
  <li>Function application or unapplication</li>
  <li>Applying a known assumption</li>
  <li>Eta-conversion</li>
  <li>Variable renaming (alpha equivalence)
    <ul>
      <li>Mostly don‚Äôt use this, as there are strict rules around it</li>
    </ul>
  </li>
</ul>

<h4 id="function-application-and-unapplication">Function application and unapplication</h4>

<p>Consider the function definition:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">double</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</code></pre></div></div>

<p>This can also be viewed as a property when reasoning about functions, allowing us to exchange the statement <code class="language-plaintext highlighter-rouge">double x</code> freely with <code class="language-plaintext highlighter-rouge">x + x</code>. This can be written as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	double x
= {function application}
	x + x
= {function unapplication}
	double x
</code></pre></div></div>

<h5 id="non-overlapping-pattern-matching">Non-overlapping pattern matching</h5>

<p>The following function definition is fairly common-place:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isZero</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">isZero</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">isZero</span> <span class="n">n</span> <span class="o">=</span> <span class="kt">False</span>
</code></pre></div></div>

<p>However, we cannot take the second statement <code class="language-plaintext highlighter-rouge">isZero n = False</code> in isolation when using function application/unapplication, as it is dependent on not hitting the pattern match above it, checking that it isn‚Äôt zero</p>

<p>Hence, it is often convenient to re-write function without implicit precedence from pattern matching, as such:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isZero</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">isZero</span> <span class="n">n</span>
	<span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>	<span class="o">=</span> <span class="kt">True</span>
	<span class="o">|</span> <span class="n">n</span> <span class="o">/=</span> <span class="mi">0</span>	<span class="o">=</span> <span class="kt">False</span>
</code></pre></div></div>

<h5 id="case-analysis">Case analysis</h5>

<p>This leads us onto case analysis, were we can apply values to a function based on the case it will take. For example, consider the function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">not</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">not</span> <span class="kt">False</span>	<span class="o">=</span> <span class="kt">True</span>
<span class="n">not</span> <span class="kt">True</span>	<span class="o">=</span> <span class="kt">False</span>
</code></pre></div></div>

<p>We can then apply cases to simplify expressions, as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	not (not False)
= {application to the inner `not`}
	not True
= {application to the `not`}
	False
</code></pre></div></div>

<h4 id="applying-an-assumption">Applying an assumption</h4>

<p>If an assumption, e.g. a function definition or inductive hypothesis fits the pattern of a part of the proof, it can be re-written with it - this is fairly self-explanatory</p>

<h4 id="eta-conversion">Eta-conversion</h4>

<p>Eta conversion is the ‚Äúadding or dropping of abstraction over a function‚Äù <a href="https://wiki.haskell.org/Eta_conversion">source</a>.</p>

<p>This means that we can say the following are equivalent:</p>

<ul>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">abs</span> <span class="n">x</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abs</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="induction">Induction</h3>

<p>The steps for performing a proof by induction are:</p>

<ol>
  <li>
    <p>Select the variable to perform induction on. This may be the most used one, or the one which is used equally on both sides</p>
  </li>
  <li>
    <p>Write out the proposition in terms of the variable to perform induction on, and with any other variables being arbitrary fixed constants of a given type</p>
  </li>
  <li>
    <p>Prove the <strong>base case</strong></p>

    <ol>
      <li>This is normally a direct proof. However, there is sometimes an additional nested inductive proof</li>
    </ol>
  </li>
  <li>
    <p>Prove the <strong>inductive step</strong></p>

    <ol>
      <li>
        <p>Write out the inductive hypothesis</p>
      </li>
      <li>
        <p>Use the inductive hypothesis in the proof of the inductive step. Commonly, the operations are in the following order:</p>

        <ol>
          <li>Function application</li>
          <li>Apply inductive hypothesis</li>
          <li>Function unapplication</li>
        </ol>

        <p>However, there is sometimes an additional nested inductive proof</p>
      </li>
    </ol>
  </li>
  <li>
    <p>State the conclusion that the proposition is true by induction</p>
  </li>
</ol>

<h2 id="examples">Examples</h2>

<h3 id="direct-proof-1">Direct proof</h3>

<h4 id="reversing-a-singleton-list">Reversing a singleton list</h4>

<p>Consider the function to reverse a list:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reverse</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">reverse</span> <span class="kt">[]</span> 	   <span class="o">=</span> <span class="kt">[]</span>
<span class="n">reverse</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">reverse</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</code></pre></div></div>

<p>We can then directly prove that the reverse of a singleton list is itself</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	reverse [x]
= {Using list notation}
	reverse (x : [])
= {function application of `reverse`}
	reverse [] ++ [x]
= {function application of `reverse`}
	[] ++ [x]
= {function application of `++`}
	[x]
</code></pre></div></div>

<h3 id="proof-by-induction">Proof by induction</h3>

<h4 id="addition-on-recursively-defined-numbers">Addition on recursively defined numbers</h4>

<p>Consider the definition of the natural numbers, and the function to add them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Data type for natural numbers</span>
<span class="kr">data</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="kt">Zero</span>
		 <span class="o">|</span> <span class="kt">Succ</span> <span class="kt">Nat</span>
		 
<span class="c1">-- Addition function</span>
<span class="n">add</span> <span class="o">::</span> <span class="kt">Nat</span> <span class="o">-&gt;</span> <span class="kt">Nat</span> <span class="o">-&gt;</span> <span class="kt">Nath</span>
<span class="n">add</span> <span class="kt">Zero</span> <span class="n">m</span>	   <span class="o">=</span> <span class="n">m</span>
<span class="n">add</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span> <span class="o">=</span> <span class="kt">Succ</span> <span class="p">(</span><span class="n">add</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="adding-zero-results-in-no-change">Adding zero results in no change</h5>

<p>Proving the statement that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For all
	n :: Nat
	
add n Zero = n
</code></pre></div></div>

<p>Let P(<code class="language-plaintext highlighter-rouge">n</code>) be the proposition that <code class="language-plaintext highlighter-rouge">n</code> + <code class="language-plaintext highlighter-rouge">Zero</code> = <code class="language-plaintext highlighter-rouge">n</code></p>

<p>First, consider the <strong>base case</strong> P(<code class="language-plaintext highlighter-rouge">Zero</code>), which is <code class="language-plaintext highlighter-rouge">add Zero Zero = Zero</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	add Zero Zero						(LHS)
= {function application of `add`}
	Zero								(RHS)
</code></pre></div></div>

<p>Next, consider the <strong>inductive step</strong>, showing <code class="language-plaintext highlighter-rouge">P(n)</code> \(\implies\)<code class="language-plaintext highlighter-rouge">P(Succ n)</code>. This means that the inductive hypothesis is <code class="language-plaintext highlighter-rouge">add n Zero = n</code>. Hence, we want to prove <code class="language-plaintext highlighter-rouge">add (Succ n) Zero = Succ n</code>, which is done as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	add (Succ n) Zero					(LHS)
= {function application on `add`}
	Succ (add n Zero)
= {inductive hypothesis}
	Succ n								(RHS)
</code></pre></div></div>

<p>By the principle of induction, since the base case P(<code class="language-plaintext highlighter-rouge">Zero</code>) and the inductive step P(<code class="language-plaintext highlighter-rouge">n</code>) \(\implies\) P(<code class="language-plaintext highlighter-rouge">Succ n</code>) are proven, the proposition is proven for all values of <code class="language-plaintext highlighter-rouge">n</code></p>

<h5 id="associativity-of-natural-numbers">Associativity of natural numbers</h5>

<p>Proving the statement that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For all
	x :: Nat,
	y :: Nat,
	z :: Nat
	
add x (add y z) =  add (add x y) z
</code></pre></div></div>

<p>There are three variables, and we want to show it is true for all values of all of them, but we can‚Äôt easily do induction on all of them. Since <code class="language-plaintext highlighter-rouge">x</code> is the first parameter in one of the two <code class="language-plaintext highlighter-rouge">add</code> functions on both sides, it is likely a good item to pick for induction.</p>

<p>Let P(<code class="language-plaintext highlighter-rouge">x</code>) be the proposition that <code class="language-plaintext highlighter-rouge">add x (add y z) =  add (add x y) z</code> for some fixed <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code></p>

<p>First, consider the <strong>base case</strong> P(<code class="language-plaintext highlighter-rouge">Zero</code>), which is <code class="language-plaintext highlighter-rouge">add Zero (add y z) = add (add Zero y) z</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	add Zero (add y z)						(LHS)
= {function application on `add`}
	add y z
= {function unapplication on `add`}
	add (add Zero y) z						(RHS)
</code></pre></div></div>

<p>Next, consider the <strong>inductive step</strong>, showing <code class="language-plaintext highlighter-rouge">P(n)</code> \(\implies\)<code class="language-plaintext highlighter-rouge">P(Succ n)</code>. This means that the inductive hypothesis is <code class="language-plaintext highlighter-rouge">add x (add y z) = add (add x y) z</code>. Hence, we want to prove <code class="language-plaintext highlighter-rouge">add (Succ x) (add y z) =  add (add (Succ x) y) z</code>, which is done as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	add (Succ x) (add y z)					(LHS)
= {function application on outer `add`}
	Succ (add x (add y z))
= {inductive hypothesis}
	Succ (add (add x y)) z
= {function unapplication on outer `add`}
	add (Succ (add x y)) z
= {function unapplication on inner `add`}
	add (add (Succ x) y) z					(RHS)
</code></pre></div></div>

<p>By the principle of induction, since the base case P(<code class="language-plaintext highlighter-rouge">Zero</code>) and the inductive step P(<code class="language-plaintext highlighter-rouge">x</code>) \(\implies\) P(<code class="language-plaintext highlighter-rouge">Succ x</code>) are proven, the statement is proven for all <code class="language-plaintext highlighter-rouge">x</code>, and fixed arbitrary values of <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>.</p>

<p>This is sufficient to prove the whole statement, as <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> are fixed on both the RHS and the LHS.</p>

<h4 id="induction-on-lists">Induction on lists</h4>

<p>Consider the definition on lists, and the cons operation:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Data type for the list</span>
<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Empty</span>
			<span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span>

<span class="c1">-- Cons operation on the list</span>
<span class="kr">data</span> <span class="kt">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">[]</span>
		  <span class="o">|</span> <span class="p">(</span><span class="o">:</span><span class="p">)</span> <span class="n">a</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div></div>

<h5 id="proving-map-fusion">Proving map fusion</h5>

<p>Proving the statement that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For all
	f :: b -&gt; c
	g :: a -&gt; b
	xs :: [a]
	
map f (map g xs) == map (f . g) xs
</code></pre></div></div>

<p>We take the following function definitions as assumptions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map</span> <span class="n">f</span> <span class="kt">[]</span>	 <span class="o">=</span> <span class="kt">[]</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>

<span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>We need to know what <code class="language-plaintext highlighter-rouge">xs</code> is to evaluate this statement, so we use induction on <code class="language-plaintext highlighter-rouge">xs</code></p>

<p>Let P(<code class="language-plaintext highlighter-rouge">xs</code>) be the proposition that <code class="language-plaintext highlighter-rouge">map f (map g xs) = map (f . g) xs</code> for all <code class="language-plaintext highlighter-rouge">xs</code>, and some fixed <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code></p>

<p>First, consider the <strong>base case</strong> P(<code class="language-plaintext highlighter-rouge">[]</code>), which is<code class="language-plaintext highlighter-rouge">map f (map g []) = map (f . g) []</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	map f (map g [])						(LHS)
= {function application on `map`}
	map f []
= {function application on `map`}
	[]
= {function unapplication on `map`}
	map (f . g) []							(RHS)
</code></pre></div></div>

<p>Next, consider the <strong>inductive step</strong>, showing <code class="language-plaintext highlighter-rouge">P(xs)</code> \(\implies\)<code class="language-plaintext highlighter-rouge">P(x : xs)</code>. This means that the inductive hypothesis is <code class="language-plaintext highlighter-rouge">map f (map g xs) = map (f . g) xs</code>. Hence, we want to prove <code class="language-plaintext highlighter-rouge">map f (map g (x:xs)) = map (f . g) (x:xs)</code>, which is done as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	map f (map g (x:xs))
= {function application on `map`}
	map f (g x : map g xs)
= {function application on `map`}
	f (g x) : map f (map g xs)
= {inductive hypothesis}
	f (g x) : map (f . g) xs
= {function unapplication on `(.)`}
	(f . g) x : map (f . g) xs
= {function unapplication on `map`}
	map (f . g) (x:xs)
</code></pre></div></div>


            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="functors-applicatives-monads">Functors, Applicatives, Monads</h1>
       
            <h2 id="functor-factory">Functor Factory</h2>

<blockquote>
  <p>A type is a <strong>functor</strong> if it can represent a ‚Äúcontext‚Äù for values of some arbitrary type that we <strong>can apply functions</strong> to.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</code></pre></div></div>

<p><strong>Pro Tip.</strong> When writing down the instance of a type class like <code class="language-plaintext highlighter-rouge">functor</code> here, always write down the <strong>specialised type signatures</strong> of the function we‚Äôre defining first</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span>
<span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>  <span class="o">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Leaf</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span> 
  <span class="c1">-- fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">x</span><span class="p">)</span>   <span class="o">=</span> <span class="kt">Leaf</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="functor-laws">Functor Laws</h3>

<p>A type <code class="language-plaintext highlighter-rouge">f</code> is a functor if there is a function</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the following laws apply for it:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fmap</span> <span class="n">id</span> <span class="o">=</span> <span class="n">id</span>
<span class="n">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span><span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span>
</code></pre></div></div>

<blockquote>
  <p>These laws imply that a data structure‚Äôs ‚Äúshape‚Äù does not change when we use <code class="language-plaintext highlighter-rouge">fmap</code> - we are just operating/changing the elements inside the data structure.</p>
</blockquote>

<h2 id="applicative-academy">Applicative Academy</h2>

<blockquote>
  <p>A type is an <strong>applicative</strong> functor if its values represent some form of context that we <strong>can lift function application</strong> into.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
  
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
  <span class="c1">-- pure :: a -&gt; Maybe a</span>
  <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">x</span>
  <span class="c1">-- (&lt;*&gt;) :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</span>
  <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="kr">_</span>        <span class="o">&lt;*&gt;</span> <span class="kr">_</span>        <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>Suppose that f is a function with two parameters e.g.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
<span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
<span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<h3 id="applicative-laws">Applicative Laws</h3>

<p>In Haskell, a type <code class="language-plaintext highlighter-rouge">f</code> is an applicative functor if there are functions <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
	<span class="n">pure</span>  <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
	<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>and the following laws apply for them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             <span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
         <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
              <span class="n">m</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">m</span>
<span class="n">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="left-and-right-apply">Left and Right Apply</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">x</span> <span class="o">&lt;*</span> <span class="n">y</span> <span class="o">=</span> <span class="n">const</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">x</span> <span class="o">*&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">flip</span> <span class="n">const</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<h3 id="limitations-of-applicatives">Limitations of Applicatives</h3>

<p>Applicative effects cannot depend on the result of the previous computation, which is why we have <strong>monads</strong>.</p>

<p>Consider the example of looking up the grandmother of a person from a dictionary which maps people to their mothers. This dictionary can be represented as a value of type <code class="language-plaintext highlighter-rouge">[(String, String)]</code> and we can then use the <code class="language-plaintext highlighter-rouge">lookup :: Eq a =&gt; a -&gt; [(a,b)] -&gt; Maybe b</code> function from the standard library to retrieve the name of the mother of a given person:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">grandmother</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="n">grandmother</span> <span class="n">x</span> <span class="n">dict</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">mother</span> <span class="o">&lt;-</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">dict</span>
  <span class="n">lookup</span> <span class="n">mother</span> <span class="n">dict</span>
</code></pre></div></div>

<p>If there is no mapping for a person‚Äôs name to their mother, then <code class="language-plaintext highlighter-rouge">Nothing</code> is returned. Therefore, to look up a person‚Äôs grandmother, we first need to look up their mother‚Äôs name and then the name of their mother‚Äôs mother.</p>

<h2 id="writer-type">Writer Type</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MkWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></div>

<p>The writer type is a good example of a <strong>functor</strong> that is <strong>not</strong> an <strong>applicative functor</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">w</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">MkWriter</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">o</span><span class="p">))</span> <span class="o">=</span> <span class="kt">MkWriter</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
</code></pre></div></div>

<p>It cannot be an applicative functor because we need to be able to write an instance for <code class="language-plaintext highlighter-rouge">pure</code>. Looking at the typing for <code class="language-plaintext highlighter-rouge">pure</code>, we can see that we need to use the <code class="language-plaintext highlighter-rouge">MkWriter</code> constructor, which expects a pair of type <code class="language-plaintext highlighter-rouge">(a,w)</code> as argument. While we have a value of type <code class="language-plaintext highlighter-rouge">a</code> that can be given to <code class="language-plaintext highlighter-rouge">pure</code> as argument, we do not have a value for <code class="language-plaintext highlighter-rouge">w</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span>
</code></pre></div></div>

<p>Hence, since it is not possible to write a suitable definition, the <code class="language-plaintext highlighter-rouge">Writer</code> type is not an <strong>applicative functor</strong>. Even if we find some way to write a definition, it will not obey the relevant applicative laws.</p>

<h2 id="state-type">State Type</h2>

<p><code class="language-plaintext highlighter-rouge">State</code> has two parameters and therefore is a of kind <code class="language-plaintext highlighter-rouge">* -&gt; * -&gt; *</code>. From type signature of <code class="language-plaintext highlighter-rouge">St</code>, we can see that we are storing functions that produces pairs.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">St</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
<span class="kt">St</span> <span class="o">::</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span>

<span class="n">runState</span> <span class="o">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="n">runState</span> <span class="p">(</span><span class="kt">St</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">m</span>
</code></pre></div></div>

<p>A value of type <code class="language-plaintext highlighter-rouge">State s a</code> represents a <strong>computation</strong> that accepts and initial state of type <code class="language-plaintext highlighter-rouge">s</code> and uses it to produce a result of type <code class="language-plaintext highlighter-rouge">a</code> and a resulting state of type <code class="language-plaintext highlighter-rouge">s</code>.</p>

<blockquote>
  <p>The main idea behind this is that by combining values of type <code class="language-plaintext highlighter-rouge">State</code> in some way, we could automatically propagate state throughout a program in a way that appears <strong>as if</strong> the state was mutable.</p>
</blockquote>

<h2 id="monad-merry-go-round">Monad Merry-Go-Round</h2>

<blockquote>
  <p>A type is a <strong>monad</strong> if its value represent some form of context that permits us to apply a function to all the elements in one context, producing one new context each which <strong>can then</strong> all <strong>be joined</strong> together into one final context.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span> 
  <span class="c1">-- (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; m b) -&gt; m b</span>
  <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
  <span class="kt">Nothing</span>  <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>You can also characterise a monad with the <code class="language-plaintext highlighter-rouge">join</code> function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">join</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span> <span class="o">&gt;&gt;=</span> <span class="n">id</span>

<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">join</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<p>In theory, either function characterises a monad and can be used to define the other function. Haskell‚Äôs <code class="language-plaintext highlighter-rouge">Monad</code> type class requires us to define <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>, while <code class="language-plaintext highlighter-rouge">join</code> is defined in terms of <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code></p>

<h3 id="monad-laws">Monad Laws</h3>

<p>In Haskell, a type <code class="language-plaintext highlighter-rouge">m</code> is a monad if there are functions <code class="language-plaintext highlighter-rouge">return</code> and <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  <span class="n">return</span> <span class="o">::</span>   <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></div></div>

<p>and the following laws apply for them:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Left Identity</span>
<span class="n">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
<span class="c1">-- Right Identity</span>
<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">=</span> <span class="n">m</span>
<span class="c1">-- Associativity</span>
<span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="additional-resources">Additional resources</h3>

<p>The following chapters in <em>Learn You a Haskell for Great Good! A Beginner‚Äôs Guide, Lipovaca, Miran</em> cover functors, applicative functors and monads in gratuitous detail:</p>

<ul>
  <li><a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass">The functor typeclass</a></li>
  <li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">Functors, applicative functors, and monoids</a></li>
  <li><a href="http://learnyouahaskell.com/a-fistful-of-monads">A fistful of monads</a></li>
  <li><a href="http://learnyouahaskell.com/for-a-few-monads-more">For a few monads more</a></li>
</ul>

<p>However, a simpler more intuitive description of them (which does skim over some points), is available here:</p>

<ul>
  <li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, applicatives and monads in pictures</a></li>
</ul>

            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/><h1 id="type-level-programming">Type Level Programming</h1>
       
            <h2 id="kinds">Kinds</h2>

<blockquote>
  <p>Just like how expressions have <strong>types</strong>, types have <strong>kinds</strong>.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expression</span> <span class="o">::</span> <span class="kr">type</span> <span class="c1">-- type signature</span>
<span class="kr">type</span>  <span class="o">::</span> <span class="n">kind</span>      <span class="c1">-- kind signature</span>
<span class="kt">Bool</span>  <span class="o">::</span> <span class="o">*</span>
<span class="kt">Maybe</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span>
</code></pre></div></div>

<p>For example, the type <code class="language-plaintext highlighter-rouge">Bool</code> has kind <code class="language-plaintext highlighter-rouge">*</code> (star) because <code class="language-plaintext highlighter-rouge">Bool</code> has no parameters. On the other hand, <code class="language-plaintext highlighter-rouge">Maybe</code> is of kind <code class="language-plaintext highlighter-rouge">* -&gt; *</code> (star to star), as we know that <code class="language-plaintext highlighter-rouge">Maybe</code> is a <strong>type constructor</strong> and has 1 parameter.</p>

<p><code class="language-plaintext highlighter-rouge">* -&gt; *</code> basically says that if you give this <strong>kind</strong> a type as an argument, then it gives back a type.</p>

<p><code class="language-plaintext highlighter-rouge">[] :: * -&gt; *</code> is another example ‚Äì given a type <code class="language-plaintext highlighter-rouge">a</code> to the <strong>list</strong> type constructor and it will give <code class="language-plaintext highlighter-rouge">[a]</code> (a list of <code class="language-plaintext highlighter-rouge">a</code>).</p>

<h3 id="kinds--better-code">Kinds = Better Code</h3>

<p>Kinds help us code instances better, as long as we understand it.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Monad</span> <span class="o">::</span> <span class="p">(</span><span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Either</span> <span class="kr">where</span> <span class="o">...</span> 
<span class="c1">-- Error: Expected kind * -&gt; * but Either has kind * -&gt; * -&gt; *</span>
</code></pre></div></div>

<p>In this example, it is easy to see why we get an error, because <code class="language-plaintext highlighter-rouge">Monad</code> is a type class that takes a type of kind <code class="language-plaintext highlighter-rouge">* -&gt; *</code> (basically a type constructor) and gives a <code class="language-plaintext highlighter-rouge">Constraint</code>. So giving it a type of kind <code class="language-plaintext highlighter-rouge">* -&gt; * -&gt; *</code> violates this constraint.</p>

<p>You can think of type classes as a constraint constructor, although this isn‚Äôt a standard term so don‚Äôt use it!</p>

<h3 id="finding-the-kind">Finding the kind</h3>

<p>In the Haskell repl, we have seen we can use <code class="language-plaintext highlighter-rouge">:t &lt;VALUE&gt;</code> to find the type of a given value or variable. Similarly, we can find the kind of a type using <code class="language-plaintext highlighter-rouge">:k &lt;TYPE&gt;</code>, and additionally reduce the type to a normal form with <code class="language-plaintext highlighter-rouge">:kind! &lt;TYPE&gt;</code>.</p>

<h2 id="type-promotion">Type promotion</h2>

<p>Using Haskell language extensions, we are able to create our own <strong>kinds</strong> of types. This feature is not in Haskell by default, so we need to add a language extension to use it. We can use the Haskell extension <code class="language-plaintext highlighter-rouge">XDataKinds</code> in three ways:</p>

<ol>
  <li>
    <p>Writing the following at the top of our source file, as <em>language pragma</em>:</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE XDataKinds #-}</span>
   
<span class="kr">module</span> <span class="nn">Program</span> <span class="kr">where</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Modifying the <code class="language-plaintext highlighter-rouge">.cabal</code> file for the entire target</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>library
        ...
    default-extensions: DataKinds
</code></pre></div>    </div>
  </li>
  <li>
    <p>With flags on the command line (requires specification every time)</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ghc Program.hs <span class="nt">-XDataKinds</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>Usually we use Language Pragmas.</p>

<blockquote>
  <p><strong>DataKinds</strong> is the language extension that allows us to create our own <strong>kinds</strong>.</p>
</blockquote>

<p>With <code class="language-plaintext highlighter-rouge">DataKinds</code> enabled, each data type we define not only introduces a type with some constructor but also introduces</p>

<ul>
  <li>a new kind which has the same name as the data type</li>
  <li>additional data types ‚Äì have the same name as the data constructors but preceded with a <code class="language-plaintext highlighter-rouge">'</code>.
    <ul>
      <li>These additional data types are of the new kind that is introduced.</li>
    </ul>
  </li>
</ul>

<p><strong>Example.</strong> Here we are getting a <strong>type-level</strong> boolean of <strong>kind</strong> <code class="language-plaintext highlighter-rouge">Bool</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
  <span class="kt">True</span>  <span class="o">::</span> <span class="kt">Bool</span> <span class="c1">-- type signature</span>
  <span class="kt">False</span> <span class="o">::</span> <span class="kt">Bool</span>
<span class="c1">-- With DataKinds enabled, the 'True and 'False data types are introduced</span>
  <span class="kt">'True</span>  <span class="o">::</span> <span class="kt">Bool</span> <span class="c1">-- kind signature (do not confuse with typings)</span>
  <span class="kt">'False</span> <span class="o">::</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>To visualise this you can look at the table below. The right-most column is what the <code class="language-plaintext highlighter-rouge">DataKinds</code> language extension adds in addition to what happens normally when you define a type with <code class="language-plaintext highlighter-rouge">data</code>.</p>

<table class="centeredtable">
  <thead>
    <tr>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">Normally</th>
      <th style="text-align: center">DataKinds Additions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Kind-Level</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">*</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Bool</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Type-Level</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">Bool</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">'True</code> and <code class="language-plaintext highlighter-rouge">'False</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Value-level</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code></td>
      <td style="text-align: center">¬†</td>
    </tr>
  </tbody>
</table>

<h2 id="gadts">GADTs</h2>

<blockquote>
  <p><strong>Generalised Algebraic Data Types</strong> (GADTs) allow us to define <strong>more expressive</strong> data type definitions. The language extension is <code class="language-plaintext highlighter-rouge">GADTs</code>.</p>
</blockquote>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- ADT syntax</span>
<span class="kr">data</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">a</span><span class="p">)</span>
  <span class="cm">{- 
     Behind the scenes we get 
       Nil :: Vector a
       Cons :: a -&gt; Vector a -&gt; Vector a 
  -}</span>
<span class="c1">-- with GADT syntax</span>
<span class="kr">data</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Nil</span>  <span class="o">::</span> <span class="kt">Vector</span> <span class="n">a</span>
  <span class="kt">Cons</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">a</span>
</code></pre></div></div>

<p>Currently, the <code class="language-plaintext highlighter-rouge">head</code> function on <code class="language-plaintext highlighter-rouge">lists</code> will break if given an empty list. So we can fix that by returning a <code class="language-plaintext highlighter-rouge">Maybe</code> or <code class="language-plaintext highlighter-rouge">Either</code> type and then deal with the result in another function.</p>

<p>But <code class="language-plaintext highlighter-rouge">GADTs</code> together with <strong>another extension,</strong> <code class="language-plaintext highlighter-rouge">XKindSignatures</code>, will allow us to define a <code class="language-plaintext highlighter-rouge">head</code> function for <code class="language-plaintext highlighter-rouge">Vector</code> that will reject an empty list at compile-time ‚Äì removing the need for us to handle the results of <code class="language-plaintext highlighter-rouge">Maybe</code> or <code class="language-plaintext highlighter-rouge">Either</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Nil</span>  <span class="o">::</span> <span class="kt">Vector</span> <span class="kt">'Zero</span>
  <span class="kt">Cons</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">n</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">a</span>
  
<span class="n">vhead</span> <span class="o">::</span> <span class="kt">Vector</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">vhead</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>

<span class="kr">data</span> <span class="kt">Nat</span> <span class="kr">where</span>         <span class="c1">-- Behind the scenes we get </span>
  <span class="kt">Zero</span> <span class="o">::</span> <span class="kt">Nat</span>          <span class="c1">--   'Zero :: Nat</span>
  <span class="kt">Succ</span> <span class="o">::</span> <span class="kt">Nat</span> <span class="o">-&gt;</span> <span class="kt">Nat</span>   <span class="c1">--   'Succ :: Nat -&gt; Nat</span>
</code></pre></div></div>

<p>In the new definition of <code class="language-plaintext highlighter-rouge">Vector</code> we have placed a specification on the 1st parameter <code class="language-plaintext highlighter-rouge">n</code>. <code class="language-plaintext highlighter-rouge">(n :: Nat)</code> essentially says that the type <code class="language-plaintext highlighter-rouge">n</code> has to be of <strong>kind</strong> <code class="language-plaintext highlighter-rouge">Nat</code>. And in the new definition of <code class="language-plaintext highlighter-rouge">Nil</code> and <code class="language-plaintext highlighter-rouge">Cons</code>, we are able to specify that <code class="language-plaintext highlighter-rouge">Nil</code> will only accept an element of type <code class="language-plaintext highlighter-rouge">Vector 'Zero</code> and <code class="language-plaintext highlighter-rouge">Cons</code> will always give a <code class="language-plaintext highlighter-rouge">Vector</code> 1 element larger.</p>

<p>In this example, GADTs allow us to specify <strong>more constrained</strong> return types for data constructors.</p>

<h3 id="singleton-types">Singleton Types</h3>

<blockquote>
  <p>Types where there is a 1:1 correspondence between types and values. Essentially a particular singleton type will only ever have one value that is associated with it.</p>
</blockquote>

<p>From above we have seen that with <code class="language-plaintext highlighter-rouge">DataKinds</code> and <code class="language-plaintext highlighter-rouge">GADTs</code> we are able to encode information about the value of a certain element through its <strong>type</strong>. In specific cases, we may want to make use of this to define <strong>singleton types</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">SNat</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">SZero</span> <span class="o">::</span> <span class="kt">SNat</span> <span class="kt">'Zero</span>
  <span class="kt">SSucc</span> <span class="o">::</span> <span class="kt">SNat</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="kt">SNat</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>In this example, we are defining a singleton type for natural numbers. If we try to define <code class="language-plaintext highlighter-rouge">sone</code> or <code class="language-plaintext highlighter-rouge">stwo</code>, their types will be unique.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sone</span> <span class="o">::</span> <span class="kt">SNat</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="kt">'Zero</span><span class="p">)</span>
<span class="n">sone</span> <span class="o">=</span> <span class="kt">SSucc</span> <span class="kt">SZero</span>

<span class="n">stwo</span> <span class="o">::</span> <span class="kt">SNat</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="kt">'Zero</span><span class="p">))</span>
<span class="n">stwo</span> <span class="o">::</span> <span class="kt">SSucc</span> <span class="n">sone</span>
</code></pre></div></div>

<h2 id="reification">Reification</h2>

<blockquote>
  <p>Reification is the process of <strong>converting types to values</strong>, typically using <strong>type classes</strong>.</p>
</blockquote>

<p>There are a few ways to implement the instances for the type classes and one way (which is used in the lectures) is to use <strong>proxy types</strong>.</p>

<h3 id="proxy-types">Proxy Types</h3>

<p>We don‚Äôt have types at runtime due to <strong>type erasure</strong>, so we can‚Äôt write a function that takes types as arguments in Haskell, even though we sometimes want to.</p>

<blockquote>
  <p>Functions only accept arguments whose types are of kind <code class="language-plaintext highlighter-rouge">*</code>. Proxy types are used to establish a link between types of other kinds and types of kind <code class="language-plaintext highlighter-rouge">*</code>, thus ‚Äúcarrying‚Äù types of other kinds into the scope of a function‚Äôs type.</p>
</blockquote>

<p><strong>For example,</strong> we might want to define a function</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fromNat</span> <span class="o">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>which takes a type-level natural number <code class="language-plaintext highlighter-rouge">n</code> of kind <code class="language-plaintext highlighter-rouge">Nat</code> as input and returns the corresponding <code class="language-plaintext highlighter-rouge">Int</code> value. However, <strong>only</strong> types of kind <code class="language-plaintext highlighter-rouge">*</code> have values at run-time in Haskell. Since there are <strong>no values</strong> of types of kind <code class="language-plaintext highlighter-rouge">Nat</code>, we cannot define a <code class="language-plaintext highlighter-rouge">fromNat</code> function of the given type.</p>

<blockquote>
  <p>Proxy types provide a partial work around Haskell‚Äôs limitations <strong>for cases where</strong> knowing what type is given to a function as its ‚Äúargument‚Äù at compile-time is sufficient.</p>

  <p><strong>TLDR.</strong> A proxy type is a type of kind <code class="language-plaintext highlighter-rouge">k -&gt; *</code> (where <code class="language-plaintext highlighter-rouge">k</code> can be specialised to the kind of whatever types you want to give to a function as argument). Only types of kind <code class="language-plaintext highlighter-rouge">*</code> have values, so we apply our proxy <strong>type constructor</strong> to some argument of kind <code class="language-plaintext highlighter-rouge">k</code> to get a type of kind <code class="language-plaintext highlighter-rouge">*</code> which then makes a suitable parameter for a function.</p>
</blockquote>

<p>In the following <strong>example</strong>, we will show how this allows us to convert a type into a corresponding value. In other words, we show how to take information from the <strong>type level</strong> and convert it to information at the <strong>value level</strong> (reification).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">NatProxy</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">=</span> <span class="kt">MkProxy</span>
</code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">NatProxy</code> <strong>type constructor</strong> is of kind <code class="language-plaintext highlighter-rouge">Nat -&gt; *</code>, meaning it takes some type <code class="language-plaintext highlighter-rouge">n</code> of kind <code class="language-plaintext highlighter-rouge">Nat</code> and gives back a type of kind <code class="language-plaintext highlighter-rouge">*</code> which has a value at run-time. <code class="language-plaintext highlighter-rouge">MkProxy</code> is the <strong>data constructor</strong> for <code class="language-plaintext highlighter-rouge">NatProxy</code> and is of type <code class="language-plaintext highlighter-rouge">NatProxy n</code>.</p>

<p>Now with our <strong>proxy type</strong>, we can define a <code class="language-plaintext highlighter-rouge">fromNat</code> function with a slightly modified type. Since <code class="language-plaintext highlighter-rouge">NatProxy :: Nat -&gt; *</code>, <code class="language-plaintext highlighter-rouge">NatProxy n</code> is a valid parameter type for a function since it is of kind <code class="language-plaintext highlighter-rouge">*</code>. We use a type class to overload this <code class="language-plaintext highlighter-rouge">fromNat</code> function so that we can provide different implementations for it, depending on which type <code class="language-plaintext highlighter-rouge">n</code> is. For example, if <code class="language-plaintext highlighter-rouge">n</code> is <code class="language-plaintext highlighter-rouge">'Zero</code> we just define <code class="language-plaintext highlighter-rouge">fromNat</code> to return <code class="language-plaintext highlighter-rouge">0</code> as shown:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">FromNat</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fromNat</span> <span class="o">::</span> <span class="kt">NatProxy</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="kt">Int</span>

<span class="kr">instance</span> <span class="kt">FromNat</span> <span class="kt">'Zero</span> <span class="kr">where</span> <span class="c1">-- 'Zero is a type defined by Nat in GADT section</span>
  <span class="c1">-- fromNat :: NatProxy 'Zero -&gt; Int</span>
  <span class="n">fromNat</span> <span class="kr">_</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p><strong>Next,</strong> the instance for any other <code class="language-plaintext highlighter-rouge">n</code> requires us to constrain the <code class="language-plaintext highlighter-rouge">n</code> in the instance head to be an instance of <code class="language-plaintext highlighter-rouge">FromNat</code> so that we can define the instance for <code class="language-plaintext highlighter-rouge">'Succ n</code> <strong>recursively</strong>. The recursive call to <code class="language-plaintext highlighter-rouge">fromNat</code> is given <code class="language-plaintext highlighter-rouge">MkProxy</code> as argument, with an <strong>explicit type annotation</strong> instructing the compiler to choose the <code class="language-plaintext highlighter-rouge">fromNat</code> implementation for <code class="language-plaintext highlighter-rouge">n</code>. (Read the comments in the code snippet.)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="kr">instance</span> <span class="kt">FromNat</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="kt">FromNat</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="n">n</span><span class="p">)</span> <span class="kr">where</span>
  <span class="c1">-- fromNat :: FromNat n =&gt; NatProxy ('Succ n) -&gt; Int</span>
  <span class="n">fromNat</span> <span class="kr">_</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fromNat</span> <span class="p">(</span><span class="kt">MkProxy</span> <span class="o">::</span> <span class="kt">NatProxy</span> <span class="n">n</span><span class="p">)</span>
  <span class="c1">-- (MkProxy :: NatProxy n) essentially means the n in "NatProxy n" </span>
  <span class="c1">-- is the same n as that in the instance head. </span>
  <span class="c1">-- ScopedTypeVariables extension has to be enabled for this to work.</span>
  
  <span class="n">vlength</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">n</span> <span class="n">a</span> <span class="o">.</span> <span class="kt">FromNat</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="kt">Vector</span> <span class="n">n</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Int</span> 
  <span class="n">vlength</span> <span class="kr">_</span> <span class="o">=</span> <span class="n">fromNat</span> <span class="p">(</span><span class="kt">MkProxy</span> <span class="o">::</span> <span class="kt">NatProxy</span> <span class="n">n</span><span class="p">)</span>
  <span class="c1">-- Here "forall n a" is required for ScopedTypeVariables to work correctly</span>
</code></pre></div></div>

<p>Although we use proxy types to implement the reification process here, they are <strong>independent techniques</strong>. That is, proxy types have uses outside of reification and reification can be accomplished without proxy types, which is <strong>not</strong> covered in the module.</p>

<h3 id="additional-example-type-application">Additional Example (Type Application)</h3>

<blockquote class="extra">
  <b>FYI.</b> This section is additional material and is not tested in the exams.
  I have included an example that Michael showed me, to illustrate how we may reify types without using proxy types. 
</blockquote>

<p>Quoting Michael,</p>

<p><em>‚ÄúI just typed straight into Slack, so it may not compile as is, but conceptually this [is how we would do it]‚Äù</em></p>

<p>This example makes use of a few language extensions which are shown.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE TypeApplication, AllowAmbiguousTypes, ScopedTypeVariables #-}</span>
<span class="kr">class</span> <span class="kt">FromNat</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">fromNat</span> <span class="o">::</span> <span class="kt">Int</span>
   
<span class="kr">instance</span> <span class="kt">FromNat</span> <span class="kt">Zero</span> <span class="kr">where</span>
   <span class="n">fromNat</span> <span class="o">=</span> <span class="mi">0</span>
   
<span class="kr">instance</span> <span class="kt">FromNat</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="kt">FromNat</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="kr">where</span>
   <span class="n">fromNat</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fromNat</span> <span class="o">@</span><span class="n">n</span>
   
<span class="kr">type</span> <span class="kt">Test</span> <span class="o">=</span> <span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)</span>

<span class="n">test</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">fromNat</span> <span class="o">@</span><span class="kt">Test</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">@</code> is type application which is used to explicitly supply an argument for a universal quantifier. Universal quantifiers are usually implicit in Haskell, but in some cases it is useful to make them explicit when writing down typings. In the case of <code class="language-plaintext highlighter-rouge">fromNat</code>, its type is as follows with the universal quantifiers made explicit:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fromNat</span> <span class="o">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">.</span> <span class="kt">FromNat</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>When we write <code class="language-plaintext highlighter-rouge">fromNat @Test</code> (last line), the <code class="language-plaintext highlighter-rouge">n</code> gets instantiated with <code class="language-plaintext highlighter-rouge">Test</code> and we get <code class="language-plaintext highlighter-rouge">FromNat Test =&gt; Int</code> as the type. Because <code class="language-plaintext highlighter-rouge">Test</code> expands to something that has an instance of <code class="language-plaintext highlighter-rouge">FromNat</code>, the constraint is satisfied and the compiler can pick the right implementation of <code class="language-plaintext highlighter-rouge">fromNat</code> to use, which is how the reification ‚Äúworks‚Äù.</p>

<blockquote>
  <p>Type application can be used with other variables, for example <code class="language-plaintext highlighter-rouge">something</code>. As long as these have an instance of <code class="language-plaintext highlighter-rouge">FromNat</code> defined for them. So if we write <code class="language-plaintext highlighter-rouge">fromNat @something</code> then <code class="language-plaintext highlighter-rouge">n</code> will be instantiated with <code class="language-plaintext highlighter-rouge">something</code>.</p>
</blockquote>

<h3 id="concluding-reification">Concluding Reification</h3>

<p>Here, we have provided two examples of how we can reify types. You have seen how useful type classes  are as they allow us overload the <code class="language-plaintext highlighter-rouge">fromNat</code> function for different types of <code class="language-plaintext highlighter-rouge">n</code>. This <strong>resolves</strong> to the <strong>correct instances</strong> at <strong>compile-time</strong> so the <strong>right implementation</strong> of the function is <strong>evaluated at runtime</strong>.</p>

<h2 id="type-families">Type Families</h2>

<p><em>Language extension:</em> <code class="language-plaintext highlighter-rouge">TypeFamilies</code></p>

<p>Type families are type-level functions and allow us to <strong>perform computation</strong> at the type-level. There are two main types of type families, <strong>closed type families</strong> and <strong>associated (open) type families</strong>.</p>

<blockquote>
  <p><strong>Associated (open) type families</strong> are ‚Äúattached‚Äù to <strong>type classes</strong> and is open to further extension when defining <strong>instances</strong>.</p>

  <p><strong>Closed type families</strong> are very much like ‚Äúnormal‚Äù functions in the sense that you ‚Äúknow‚Äù what kind of types the <strong>type family</strong> will deal with and the effect to be achieved, and you just define it as such.</p>
</blockquote>

<h3 id="closed-type-families">Closed Type Families</h3>

<p>I think the best way to explain this is through an example. As you can see, the syntax for <strong>type families</strong> is different from anything we‚Äôve seen before. The example below should be pretty self explanatory and you can see that the head of definition sort of resembles the type signature of a normal function, and the definition of the actual <code class="language-plaintext highlighter-rouge">Add</code> function is just pattern matching on the type of <code class="language-plaintext highlighter-rouge">Nat</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE TypeFamilies #-}</span>
<span class="kr">type</span> <span class="n">family</span> <span class="kt">Add</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Nat</span> <span class="kr">where</span>
  <span class="c1">-- Add :: Nat -&gt; Nat -&gt; Nat</span>
  <span class="kt">Add</span> <span class="kt">'Zero</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
  <span class="kt">Add</span> <span class="p">(</span><span class="kt">'Succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span> <span class="o">=</span> <span class="kt">'Succ</span> <span class="p">(</span><span class="kt">Add</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div>

<p>If we enable the <code class="language-plaintext highlighter-rouge">TypeOperators</code> language extension, we can use operators in our <strong>type family</strong> definition, which in turn allow us to use it very nicely in the <code class="language-plaintext highlighter-rouge">vappend</code> example below.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE TypeOperators #-}</span>
<span class="kr">type</span> <span class="n">family</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Nat</span> <span class="kr">where</span>
<span class="c1">-- or</span>
<span class="kr">type</span> <span class="n">family</span> <span class="p">(</span><span class="n">n</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="kt">Nat</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Nat</span> <span class="kr">where</span>

<span class="n">vappend</span> <span class="o">::</span> <span class="kt">Vector</span> <span class="n">n</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="n">a</span>
<span class="n">vappend</span> <span class="kt">Nil</span>         <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span>
<span class="n">vappend</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">xs</span><span class="p">)</span> <span class="n">ys</span> <span class="o">=</span> <span class="kt">Cons</span> <span class="n">x</span> <span class="p">(</span><span class="n">vappend</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="how-to-test-in-repl">How to test in REPL</h4>

<p>We can get REPL to evaluate types for us by using the <code class="language-plaintext highlighter-rouge">:kind!</code> syntax. This evaluates the type to its normal form.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Lecture</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">kind</span><span class="o">!</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="kt">'Zero</span> <span class="kt">'Zero</span>
<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="kt">'Zero</span> <span class="kt">'Zero</span> <span class="o">::</span> <span class="kt">Nat</span>
<span class="o">=</span> <span class="kt">'Zero</span>
</code></pre></div></div>

<h3 id="associated-open-type-families">Associated (Open) Type Families</h3>

<blockquote>
  <p><strong>Motivation for Associated Type Families.</strong> Sometimes, when we define a certain type class, we want it to be as general as possible but because of certain constraint requirements for different instances of the type class, it is difficult without type families.</p>
</blockquote>

<p><strong>Example.</strong> Let‚Äôs say we want to define a <strong>type class</strong> <code class="language-plaintext highlighter-rouge">Collection</code> for various data structures like lists or trees etc.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Collection</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="c1">-- c :: * -&gt; *</span>
  <span class="n">empty</span>  <span class="o">::</span> <span class="n">c</span> <span class="n">a</span> 
  <span class="n">insert</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="n">a</span>
  <span class="n">member</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="c1">-- Checks if `a` is part of a collection</span>
</code></pre></div></div>

<p>Now when we try to define an instance of <code class="language-plaintext highlighter-rouge">Collection</code> for lists, we could try to implement it this way. However, we get a type error due to our usage of <code class="language-plaintext highlighter-rouge">elem</code>, which requires elements in the list to have the <code class="language-plaintext highlighter-rouge">Eq</code> constraint.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Collection</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">empty</span>       <span class="o">=</span> <span class="kt">[]</span>
  <span class="n">insert</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">xs</span>
  <span class="n">member</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">xs</span> 
  <span class="c1">-- however we get a type error:</span>
  <span class="c1">-- No instance for Eq a arising from use of elem</span>
</code></pre></div></div>

<p>We could add an <code class="language-plaintext highlighter-rouge">Eq a</code> constraint onto the <strong>type class</strong> definition for member. However, this makes the <code class="language-plaintext highlighter-rouge">Collection</code> type class too <strong>restrictive</strong> for other data structures. Furthermore, we can‚Äôt predict what kind of data structures that other people will create, and <code class="language-plaintext highlighter-rouge">Collection</code> should be as <strong>general</strong> as possible.</p>

<h4 id="associated-type-families-to-the-rescue">Associated type families to the rescue</h4>

<p>Associated type families allow us to associate a <strong>type family</strong> with our <strong>type class</strong>. This allows to do ‚Äúsomething‚Äù based on the instance of the type class which depends on the problem we are trying to solve.</p>

<blockquote>
  <p>Regarding the example above, our goal is to have some way of placing constraints on the <strong>type</strong> of the elements contained inside <code class="language-plaintext highlighter-rouge">c</code>, so that our instances for the <strong>type class</strong> type checks.</p>
</blockquote>

<p>So for any instance of collection, the <code class="language-plaintext highlighter-rouge">Elem</code> type family, given <code class="language-plaintext highlighter-rouge">c</code>, will return the type of elements in <code class="language-plaintext highlighter-rouge">c</code>. This establishes a relation between <code class="language-plaintext highlighter-rouge">c</code> and some type of kind <code class="language-plaintext highlighter-rouge">*</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Collection</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="n">family</span> <span class="kt">Elem</span> <span class="n">c</span> <span class="o">::</span> <span class="o">*</span>
  
  <span class="n">empty</span>  <span class="o">::</span> <span class="n">c</span>
  <span class="n">insert</span> <span class="o">::</span> <span class="kt">Elem</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span>
  <span class="n">member</span> <span class="o">::</span> <span class="kt">Elem</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>If we write down the specialised type signatures for <code class="language-plaintext highlighter-rouge">insert</code> and <code class="language-plaintext highlighter-rouge">member</code> for this instance of <code class="language-plaintext highlighter-rouge">Collection</code> for lists, we can see that the associated type family <code class="language-plaintext highlighter-rouge">Elem</code> tells the compiler that the <code class="language-plaintext highlighter-rouge">a</code> contained inside the list, is the same <code class="language-plaintext highlighter-rouge">a</code> that is used in the rest of the instance definition. We can now place an <code class="language-plaintext highlighter-rouge">Eq</code> constraint on <code class="language-plaintext highlighter-rouge">a</code> and everything type checks.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Collection</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span> 
  <span class="kr">type</span> <span class="kt">Elem</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="c1">-- this isn't a type alias; it's a type family instance.</span>
  
  <span class="n">empty</span>       <span class="o">=</span> <span class="kt">[]</span>
  <span class="c1">-- insert :: Elem [a] -&gt; [a] -&gt; [a] (Specialised type signature)</span>
  <span class="n">insert</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">xs</span>
  <span class="c1">-- member :: Elem [a] -&gt; [a] -&gt; Bool</span>
  <span class="n">member</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">xs</span>
</code></pre></div></div>

<h3 id="overloaded-lists">Overloaded Lists</h3>

<p><em>Language Extension:</em> <code class="language-plaintext highlighter-rouge">OverloadedLists</code></p>

<p>This is a neat language extension that allows us to use list notation for other data types as long as the data type has an instance of <code class="language-plaintext highlighter-rouge">IsList</code> defined for it.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Without</span>
<span class="n">poultree</span> <span class="o">::</span> <span class="kt">Tree</span> <span class="kt">String</span>
<span class="n">poultree</span> <span class="o">=</span> <span class="kt">Node</span> <span class="kt">Black</span>
             <span class="p">(</span><span class="kt">Node</span> <span class="kt">Black</span> <span class="kt">Leaf</span> <span class="s">"Chicken"</span> <span class="kt">Leaf</span><span class="p">)</span>
             <span class="s">"Duck"</span>
             <span class="p">(</span><span class="kt">Node</span> <span class="kt">Black</span> <span class="kt">Leaf</span> <span class="s">"Goose"</span> <span class="kt">Leaf</span><span class="p">)</span>
<span class="c1">-- With</span>
<span class="cp">{-# LANGUAGE OverloadedLists #-}</span>
<span class="n">poultree</span> <span class="o">::</span> <span class="kt">Tree</span> <span class="kt">String</span>
<span class="n">poultree</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Duck"</span><span class="p">,</span> <span class="s">"Goose"</span><span class="p">,</span> <span class="s">"Chicken"</span><span class="p">]</span>
</code></pre></div></div>

<p>Below we show an example with the <code class="language-plaintext highlighter-rouge">Tree</code> data structure from one of the labs.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- IsList is defined in GHC.Exts</span>
<span class="kr">class</span> <span class="kt">IsList</span> <span class="n">l</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="n">family</span> <span class="kt">Item</span> <span class="n">l</span> <span class="o">::</span> <span class="o">*</span>
  
  <span class="n">fromList</span>  <span class="o">::</span> <span class="p">[</span><span class="kt">Item</span> <span class="n">l</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">l</span>
  <span class="n">fromListN</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Item</span> <span class="n">l</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">l</span>
  <span class="n">fromListN</span> <span class="kr">_</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">fromList</span> <span class="n">xs</span>
  <span class="n">toList</span>    <span class="o">::</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Item</span> <span class="n">l</span><span class="p">]</span>
  
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">IsList</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Item</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
  
  <span class="n">toList</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">toList</span>
  <span class="n">fromList</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="n">flip</span> <span class="kt">L</span><span class="o">.</span><span class="n">insert</span><span class="p">)</span> <span class="kt">L</span><span class="o">.</span><span class="n">empty</span>
</code></pre></div></div>


            <br/>
            <hr style="
                padding: 5px;
                border-radius: 1em;
                background-color: whitesmoke;
            ">
            <br/>


                <footer class="site-footer">

                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>
</html>