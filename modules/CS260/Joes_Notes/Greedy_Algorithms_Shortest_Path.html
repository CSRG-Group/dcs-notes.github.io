<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="/assets/js/tocNav.js"></script>
    
    <!-- seo used to be here -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link id="mainCS" rel="stylesheet" href="/assets/css/style.css">
    <title>notes Greedy Algorithms Shortest Path</title>
</head>

<body>
    <div id="mainGrid" class="container">
        <header style="padding:10px;" class="page-header notes-header" role="banner">
            
            
            <h1 class="project-name">Greedy Algorithms Shortest Path</h1>
        </header>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul class="table-of-contents"><li><a href="#shortest-path-problems">Shortest path problems</a><ul><li><a href="#single-pair-shortest-path-problem">Single-Pair Shortest path problem</a></li><li><a href="#single-source-shortest-path-problem">Single-Source shortest path problem</a></li></ul></li><li><a href="#dijkstras-algorithm-greedy">Dijkstra‚Äôs algorithm Greedy</a><ul><li><a href="#proof">Proof</a></li></ul></li><li><a href="#dijkstras-algorithm-efficient">Dijkstra‚Äôs algorithm Efficient</a><ul><li><a href="#optimization-1">Optimization 1</a></li><li><a href="#optimization-2">Optimization 2</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#complexity">Complexity</a></li></ul></li></ul>
</div>
        </div>
        
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav">












    
    
    
    
    
    
    
    
    <a href="Greedy_Algorithms_Scheduling.html" title="Greedy_Algorithms_Scheduling.html">üëàPrev</a><a href="./" title="Joes Notes Home">üè°Joes Notes</a><a href="Minimum_Spanning_Tree.html" title="Minimum_Spanning_Tree.html">Nextüëâ</a>
    
    
    
    
    
    
    
    
    
    
    
    



</div>
                <!-- Main Content of markdown or sub-layouts-->
                <h2 id="shortest-path-problems">Shortest path problems</h2>

<h3 id="single-pair-shortest-path-problem">Single-Pair Shortest path problem</h3>
<p><strong>Input</strong>:</p>
<ul>
  <li>A weighted graph/digraph</li>
  <li>A source node(start)</li>
  <li>A destination node(end)
<strong>Output</strong>:</li>
  <li>A shortest path through the graph from the source to the destination</li>
</ul>

<h3 id="single-source-shortest-path-problem">Single-Source shortest path problem</h3>
<ul>
  <li>A weighted graph/digraph</li>
  <li>A source node(start)
<strong>Output</strong>:</li>
  <li>A set of shortest paths through the graph from the source to every node in the graph</li>
  <li>Can be represented as a tree with the source as the node</li>
</ul>

<h2 id="dijkstras-algorithm-greedy">Dijkstra‚Äôs algorithm Greedy</h2>

<p>Maintain a set of explored nodes \(S\)</p>

<p>let \(d[u]\) be the length of a shortest \(s \rightarrow u\) path</p>

<p>initialize \(S \leftarrow \{s\}\) , \(d[s] \leftarrow 0\)</p>

<p>repeatedly:</p>
<ul>
  <li>choose unexplored node \(v\notin S\) that minimises \(\pi(v)\) where:</li>
</ul>

\[\pi(v) = \min_{e = (u,v):u \in S}\]

<ul>
  <li>add \(v\) to \(S\) , \(d[v]\leftarrow \pi(v)\)</li>
  <li>prev[v] \(\leftarrow e\)</li>
</ul>

<p>The shortest path can then be found by traversing from any point to the start by following prev</p>

<h3 id="proof">Proof</h3>
<p>Prove:</p>
<blockquote>
  <p>For every node \(u \in S\), \(d[u]\) is the shortest path \(s \rightarrow u\)</p>
</blockquote>

<p>strategy:
induction</p>

<p>base Case:</p>

<p>when \(\vert S \vert = 1\) is easy as \(S = \{s\}\), as \(s[s]=0\) there is no shorter solution</p>

<p>Inductive case:</p>

<p>Assume is true for \(\vert S \vert \geq 1\)</p>

<p>Let \(v\) be the next path added to \(S\) and let \((u,v)\) be the edge</p>

<p>A shortest path \(s \rightarrow u\) + \(L(u,v)\) is a \(s \rightarrow v\) path of length \(\pi(v)\)</p>

<p>Consider anther path \(P\)</p>
<ul>
  <li>let \(e = (x,y)\) be the first edge in \(P\) that leaves \(S\)
    <ul>
      <li>so \(x \in S \land y \notin nS\)</li>
    </ul>
  </li>
  <li>let \(P'\) be the subpath of \(s \rightarrow x\)</li>
  <li>the length of \(P \geq \pi(v)\) as soon as it reaches y</li>
</ul>

\[L(P) \geq L(P')+ L(e) \geq d[x]+L(e) \geq \pi(y) \geq \pi(v)\]

<p>when L determines the length of a path or edge</p>

<h2 id="dijkstras-algorithm-efficient">Dijkstra‚Äôs algorithm Efficient</h2>
<p>Efficient algorithm can be found by implementing some optimizations on the previous strategy.</p>

<h3 id="optimization-1">Optimization 1</h3>
<p>For each unexplored node \(v \in S\)</p>

<p>Maintain \(\pi(v)\) instead of computing form the definition</p>

<p>As elements are added to \(S\) for some \(v\notin S , \pi(v)\) can only decrease.</p>

<p>Suppose \(u\) is added to \(S\) if there is an edge \(e=(u,v)\) leaving \(u\)</p>

<p>then:</p>

<p>\(pi(v) \leftarrow \min {\pi(v), \pi(u)+L(e)}\)</p>
<h3 id="optimization-2">Optimization 2</h3>

<p>Use a min-optimized priority queue to chose an unexplored node that minimises \(\pi(v)\)</p>

<h3 id="implementation">Implementation</h3>

<pre><code class="language-Java">graph &lt;- graph to search
s &lt;- start node

dist &lt;- array of distances
prev &lt;- array of previous nodes

//initialize start values
pq = priorityQueue()
for each vertex in graph{
    dist[vertex] = INFINITY
    prev[vertex] = UNDEFINED
}
dist[s] = 0;
for each vertex in graph{
    pq.insert(s,dist[s]);
}
// calculate minimum path
while (pq.empty =false){
    u = pq.removeMin();
    for edge in graph.edgesFrom(u){
        v = edge.goingTo() 
        if (dist[v] &gt; dist[u]+edge.weight){
            dist[v]=dist[u]+edge.weight
            pq.decreaseKey(v,dist[v])
            prev[v]=u
        }
    }

}
</code></pre>

<p>The shortest path for a node can be found by traversing prev from the node to the start</p>

<h3 id="complexity">Complexity</h3>
<p>The time complexity fo the algorithm depends on the priority queue algorithm chosen and the ratio of edges to nodes.</p>

<p>For a dense graph \(e\) is \(O(n^2)\) (where \(e\) is the number of edges and \(n\) is the number of nodes) using an array bases implementation is optimal as <code class="language-plaintext highlighter-rouge">decreaseKey</code> is \(O(1)\)</p>

<p>For a sparse graph  \(e\) is \(O(n)\) then a heap based method is better as <code class="language-plaintext highlighter-rouge">removeMin</code> is \(O(n)\)</p>




                <footer class="site-footer">

                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                </footer>
            </main>
        </div>
    </div>
</body>

</html>
</html>